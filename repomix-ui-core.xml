This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: frontend/src/components/generations/*.tsx, frontend/src/components/storyboard/*.tsx, frontend/src/components/layout/*.tsx, frontend/src/app/projects/[id]/generate/page.tsx, frontend/src/app/projects/[id]/storyboard/page.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
frontend/
  src/
    app/
      projects/
        [id]/
          generate/
            page.tsx
          storyboard/
            page.tsx
    components/
      generations/
        ABLightbox.tsx
        AnimateModal.tsx
        AudioInput.tsx
        AudioInputModal.tsx
        ElementPicker.tsx
        EngineLibraryModal.tsx
        EngineSelector.tsx
        EngineSelectorV2.tsx
        GenerationCard.tsx
        GenerationForm.tsx
        GenerationResults.tsx
        GenerationSearch.tsx
        ImageMaskEditor.tsx
        MagicPromptButton.tsx
        ParameterManager.tsx
        RenderQueuePanel.tsx
        SaveElementModal.tsx
        SessionSidebar.tsx
        ShotNavigator.tsx
        VideoMaskEditor.tsx
        VideoScopes.tsx
      layout/
        Sidebar.tsx
        StudioLayout.tsx
        StudioSidebar.tsx
      storyboard/
        CameraControlPanel.tsx
        CameraPresetSelector.tsx
        CastModal.tsx
        CinematicTagsModal.tsx
        CreateStyleModal.tsx
        EditElementModal.tsx
        ElementReferencePicker.tsx
        FoundationImagePanel.tsx
        GenerationPickerModal.tsx
        GenreSelector.tsx
        PreviewModal.tsx
        SceneBlock.tsx
        SceneCard.tsx
        SceneGeneratorModal.tsx
        ShotActionsPanel.tsx
        ShotStyleEditorModal.tsx
        StoryboardHeader.tsx
        StoryboardShot.tsx
        StoryConceptInput.tsx
        StyleSelectorModal.tsx
        TemplateSelector.tsx
        TimelineView.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/components/storyboard/StoryConceptInput.tsx">
'use client';

import React, { useState, useCallback, useMemo } from 'react';
import { Film, Sparkles, ChevronDown, AlertTriangle } from 'lucide-react';
import clsx from 'clsx';

import { Genre } from '@/data/CameraPresets';
import {
  GENRE_TEMPLATES,
  getGroupedGenreOptions,
  isContentGenre,
  isRestrictedGenre,
} from '@/data/GenreTemplates';
import {
  YOUTUBE_ARCHETYPES,
  ADULT_ARCHETYPES,
  getArchetypesForGenre,
  getDefaultArchetype,
} from '@/data/CreatorArchetypes';
import { CreatorControls } from './modules/CreatorControls';

interface StoryConceptInputProps {
  onSubmit?: (data: StoryConceptData) => void;
  isLoading?: boolean;
  initialGenre?: Genre;
  initialConcept?: string;
}

export interface StoryConceptData {
  genre: Genre;
  genreType: 'narrative' | 'content';
  concept: string;
  // Narrative-specific
  visualStyle?: string;
  // Content-specific
  archetype?: string;
  hook?: string;
  styleHint?: string;
}

export const StoryConceptInput = ({
  onSubmit,
  isLoading = false,
  initialGenre,
  initialConcept = '',
}: StoryConceptInputProps) => {
  // State
  const [isMature, setIsMature] = useState(false);
  const [selectedGenreId, setSelectedGenreId] = useState<Genre | ''>(initialGenre || '');
  const [concept, setConcept] = useState(initialConcept);

  // Content creator state
  const [archetype, setArchetype] = useState<string>('');
  const [hook, setHook] = useState('');

  // Narrative state (placeholder for cinema controls)
  const [visualStyle, setVisualStyle] = useState('');

  // Derived state
  const selectedGenre = selectedGenreId ? GENRE_TEMPLATES[selectedGenreId] : null;
  const isContent = selectedGenreId ? isContentGenre(selectedGenreId) : false;
  const isAdult = selectedGenreId === 'onlyfans';

  // Get grouped options for dropdown
  const genreGroups = useMemo(() => getGroupedGenreOptions(isMature), [isMature]);

  // Get archetypes for selected genre
  const currentArchetypes = useMemo(() => {
    if (!selectedGenreId || !isContent) return {};
    return getArchetypesForGenre(selectedGenreId);
  }, [selectedGenreId, isContent]);

  // Handle genre change
  const handleGenreChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    const newGenre = e.target.value as Genre;
    setSelectedGenreId(newGenre);

    // Reset content-specific state when switching to content genre
    if (isContentGenre(newGenre)) {
      setArchetype(getDefaultArchetype(newGenre));
      setHook('');
    }
  }, []);

  // Handle mature toggle
  const handleMatureToggle = useCallback(() => {
    const newState = !isMature;
    setIsMature(newState);

    // Safety: If turning OFF and currently on a restricted genre, reset selection
    if (!newState && selectedGenreId && isRestrictedGenre(selectedGenreId)) {
      setSelectedGenreId('');
      setArchetype('');
      setHook('');
    }
  }, [isMature, selectedGenreId]);

  // Handle submit
  const handleSubmit = useCallback(() => {
    if (!selectedGenreId || !concept.trim()) return;

    const data: StoryConceptData = {
      genre: selectedGenreId,
      genreType: isContent ? 'content' : 'narrative',
      concept: concept.trim(),
    };

    if (isContent) {
      data.archetype = archetype;
      data.hook = hook;
      data.styleHint = currentArchetypes[archetype]?.styleHint;
    } else {
      data.visualStyle = visualStyle;
    }

    onSubmit?.(data);
  }, [selectedGenreId, concept, isContent, archetype, hook, currentArchetypes, visualStyle, onSubmit]);

  const canSubmit = selectedGenreId && concept.trim().length > 0 && !isLoading;

  return (
    <div className="space-y-6 rounded-xl border border-zinc-800 bg-zinc-950 p-6">
      {/* Genre Selector */}
      <div className="space-y-2">
        <label className="flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-zinc-500">
          <Film className="h-3 w-3" />
          Content Format
        </label>
        <div className="relative">
          <select
            value={selectedGenreId}
            onChange={handleGenreChange}
            className="w-full appearance-none rounded-lg border border-zinc-700 bg-zinc-900 p-3 pr-10 text-white outline-none transition-colors focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20"
          >
            <option value="" disabled>
              Select a genre...
            </option>

            <optgroup label="Narrative / Film">
              {genreGroups.narrative.map((g) => (
                <option key={g.value} value={g.value}>
                  {g.icon} {g.label}
                </option>
              ))}
            </optgroup>

            <optgroup label="Social / Content">
              {genreGroups.content.map((g) => (
                <option key={g.value} value={g.value}>
                  {g.icon} {g.label}
                </option>
              ))}
            </optgroup>
          </select>
          <ChevronDown className="pointer-events-none absolute right-3 top-1/2 h-4 w-4 -translate-y-1/2 text-zinc-500" />
        </div>

        {/* Genre description */}
        {selectedGenre && (
          <p className="text-xs text-zinc-500">{selectedGenre.description}</p>
        )}
      </div>

      {/* Dynamic Module Injection */}
      {isContent ? (
        <CreatorControls
          archetypes={currentArchetypes}
          selectedArchetype={archetype}
          onArchetypeChange={setArchetype}
          hook={hook}
          onHookChange={setHook}
          isAdult={isAdult}
        />
      ) : selectedGenreId ? (
        // Placeholder for Cinema Controls (Visual Style, Pacing, etc.)
        <div className="space-y-4 rounded-lg border border-dashed border-zinc-700 p-4">
          <div className="text-center text-sm text-zinc-500">
            <Film className="mx-auto mb-2 h-6 w-6 text-zinc-600" />
            Visual Style & Pacing Controls
            <span className="mt-1 block text-[10px] text-zinc-600">
              (Narrative Mode - use existing style selectors)
            </span>
          </div>
          {/* You can integrate your existing CinemaControls here */}
          <div className="space-y-2">
            <label className="text-xs font-bold uppercase tracking-wider text-zinc-500">
              Visual Style Notes
            </label>
            <input
              type="text"
              value={visualStyle}
              onChange={(e) => setVisualStyle(e.target.value)}
              placeholder="e.g., Wes Anderson symmetry, neon noir lighting..."
              className="w-full rounded-lg border border-zinc-700 bg-zinc-900 p-3 text-white outline-none focus:border-purple-500"
            />
          </div>
        </div>
      ) : null}

      {/* Concept Input */}
      <div className="space-y-2">
        <label className="text-xs font-bold uppercase tracking-wider text-zinc-500">
          {isContent ? 'Video Topic / Body' : 'Story Concept'}
        </label>
        <textarea
          value={concept}
          onChange={(e) => setConcept(e.target.value)}
          placeholder={
            isContent
              ? "What is the video about? (e.g., 'I built a secret room in my house to hide from my family...')"
              : "Describe your story concept... (e.g., 'A noir detective in 1940s LA investigates a disappearance...')"
          }
          className="h-32 w-full resize-none rounded-lg border border-zinc-700 bg-zinc-900 p-3 text-white outline-none transition-colors focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20"
        />
      </div>

      {/* Submit Button */}
      <button
        onClick={handleSubmit}
        disabled={!canSubmit}
        className={clsx(
          'w-full rounded-lg py-4 font-bold text-white shadow-lg transition-all',
          canSubmit
            ? isAdult
              ? 'bg-gradient-to-r from-red-600 to-pink-600 shadow-red-900/20 hover:from-red-500 hover:to-pink-500'
              : 'bg-gradient-to-r from-purple-600 to-blue-600 shadow-purple-900/20 hover:from-purple-500 hover:to-blue-500'
            : 'cursor-not-allowed bg-zinc-800 text-zinc-500'
        )}
      >
        {isLoading ? (
          <span className="flex items-center justify-center gap-2">
            <Sparkles className="h-4 w-4 animate-spin" />
            Generating...
          </span>
        ) : (
          <span className="flex items-center justify-center gap-2">
            <Sparkles className="h-4 w-4" />
            {isContent ? 'Generate Viral Script' : 'Generate Screenplay'}
          </span>
        )}
      </button>

      {/* Mature Toggle Footer */}
      <div className="flex items-center gap-3 border-t border-zinc-800 pt-4">
        <button
          onClick={handleMatureToggle}
          className={clsx(
            'relative h-6 w-10 rounded-full transition-colors',
            isMature ? 'bg-red-600' : 'bg-zinc-700'
          )}
        >
          <div
            className={clsx(
              'absolute top-1 h-4 w-4 rounded-full bg-white transition-all',
              isMature ? 'left-5' : 'left-1'
            )}
          />
        </button>
        <div className="flex-1">
          <div className="flex items-center gap-2 text-xs font-bold text-zinc-300">
            MATURE CONTENT
            {isMature && <AlertTriangle className="h-3 w-3 text-red-400" />}
          </div>
          <div className="text-[10px] text-zinc-500">
            {isMature
              ? 'Unrestricted genres unlocked (18+).'
              : 'Standard safety filters active.'}
          </div>
        </div>
      </div>
    </div>
  );
};

export default StoryConceptInput;
</file>

<file path="frontend/src/components/generations/AudioInputModal.tsx">
'use client';

import { X, Music } from 'lucide-react';
import { AudioInput } from './AudioInput';

interface AudioInputModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAudioChange: (file: File | null) => void;
  currentFile: File | null;
}

export function AudioInputModal({
  isOpen,
  onClose,
  onAudioChange,
  currentFile,
}: AudioInputModalProps) {
  if (!isOpen) return null;

  return (
    <div className="animate-in fade-in fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm duration-200">
      <div className="animate-in zoom-in-95 relative w-full max-w-md rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl duration-200">
        {/* Header */}
        <div className="flex items-center justify-between border-b border-white/10 p-4">
          <h3 className="flex items-center gap-2 text-sm font-bold text-white">
            <Music className="h-4 w-4 text-blue-400" />
            Audio Source
          </h3>
          <button onClick={onClose} className="text-gray-400 transition-colors hover:text-white">
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-4">
          <p className="mb-4 text-xs text-gray-400">
            Upload an audio file or record your voice to drive the avatar's animation.
          </p>

          <AudioInput onAudioChange={onAudioChange} className="border-0 bg-white/5" />
        </div>

        {/* Footer */}
        <div className="flex justify-end border-t border-white/10 p-4">
          <button
            onClick={onClose}
            className="rounded-lg bg-blue-600 px-4 py-2 text-xs font-medium text-white transition-colors hover:bg-blue-500"
          >
            Done
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/ElementPicker.tsx">
'use client';

import { X, Check } from 'lucide-react';
import { Element } from '@/lib/store';
import { clsx } from 'clsx';

interface ElementPickerProps {
  isOpen: boolean;
  onClose: () => void;
  elements: Element[];
  selectedElementIds: string[];
  onToggleElement: (element: Element) => void;
}

export function ElementPicker({
  isOpen,
  onClose,
  elements,
  selectedElementIds,
  onToggleElement,
}: ElementPickerProps) {
  console.log('ElementPicker elements:', elements);
  if (!isOpen) return null;

  return (
    <div className="animate-in fade-in zoom-in-95 absolute right-0 bottom-full z-50 mb-4 flex max-h-[500px] w-96 flex-col rounded-xl border border-white/20 bg-[#1a1a1a] shadow-2xl duration-200">
      <div className="flex items-center justify-between border-b border-white/10 p-4">
        <h3 className="text-sm font-bold tracking-wider text-white uppercase">Select Elements</h3>
        <button onClick={onClose} className="text-gray-400 hover:text-white">
          <X className="h-4 w-4" />
        </button>
      </div>

      <div className="flex-1 space-y-4 overflow-y-auto p-2">
        {elements.length === 0 ? (
          <div className="py-8 text-center text-sm text-gray-500">
            No elements found. Upload some in the Elements tab!
          </div>
        ) : (
          Object.entries(
            elements.reduce(
              (acc, el) => {
                const sessionName = el.session?.name || 'Global / Unassigned';
                if (!acc[sessionName]) acc[sessionName] = [];
                acc[sessionName].push(el);
                return acc;
              },
              {} as Record<string, Element[]>
            )
          ).map(([sessionName, sessionElements]) => (
            <div key={sessionName}>
              <h4 className="mb-2 px-1 text-xs font-bold tracking-wider text-gray-500 uppercase">
                {sessionName}
              </h4>
              <div className="grid grid-cols-3 gap-2">
                {sessionElements.map(el => {
                  const isSelected = selectedElementIds.includes(el.id);
                  return (
                    <button
                      key={el.id}
                      onClick={() => onToggleElement(el)}
                      className={clsx(
                        'group relative aspect-square overflow-hidden rounded-lg border-2 transition-all',
                        isSelected ? 'border-blue-500' : 'border-transparent hover:border-white/20'
                      )}
                    >
                      {el.type === 'video' ? (
                        <video src={el.url} className="h-full w-full object-cover" />
                      ) : (
                        <img src={el.url} className="h-full w-full object-cover" />
                      )}

                      <div
                        className={clsx(
                          'absolute inset-0 flex items-center justify-center bg-black/40 transition-opacity',
                          isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'
                        )}
                      >
                        {isSelected && <Check className="h-6 w-6 text-blue-500" />}
                      </div>

                      <div className="absolute right-0 bottom-0 left-0 truncate bg-black/60 p-1 text-[10px] text-white">
                        {el.name}
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/EngineSelector.tsx">
import { useState, useEffect } from 'react';
import { Cloud, Server, Settings } from 'lucide-react';
import { clsx } from 'clsx';

interface EngineConfig {
  type: 'fal' | 'comfy';
  comfyUrl?: string;
  falKey?: string;
  falModel?: string; // 'fal-ai/flux/dev' | 'fal-ai/flux-2-flex'
}

interface EngineSelectorProps {
  config: EngineConfig;
  onChange: (config: EngineConfig) => void;
}

export function EngineSelector({ config, onChange }: EngineSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [localUrl, setLocalUrl] = useState(config.comfyUrl || 'http://127.0.0.1:8188');

  const handleTypeChange = (type: 'fal' | 'comfy') => {
    onChange({ ...config, type });
  };

  const handleUrlChange = (url: string) => {
    setLocalUrl(url);
    onChange({ ...config, comfyUrl: url });
  };

  const handleModelChange = (model: string) => {
    onChange({ ...config, falModel: model });
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-xs text-gray-300 transition-colors hover:bg-white/10"
      >
        {config.type === 'fal' ? (
          <Cloud className="h-3 w-3 text-blue-400" />
        ) : (
          <Server className="h-3 w-3 text-green-400" />
        )}
        <span className="font-medium">
          {config.type === 'fal'
            ? config.falModel?.includes('wan')
              ? 'Cloud (Wan 2.2)'
              : config.falModel?.includes('ltx')
                ? 'Cloud (LTX-Video)'
                : config.falModel?.includes('kling')
                  ? 'Cloud (Kling 2.1)'
                  : config.falModel?.includes('flux-2')
                    ? 'Cloud (Flux 2)'
                    : 'Cloud (Flux 1)'
            : 'Local (ComfyUI)'}
        </span>
        <Settings className="ml-1 h-3 w-3 opacity-50" />
      </button>

      {isOpen && (
        <>
          <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)} />
          <div className="absolute right-0 bottom-full z-50 mb-2 w-64 space-y-4 rounded-xl border border-white/20 bg-[#1a1a1a] p-4 shadow-xl">
            <div>
              <h3 className="mb-2 text-xs font-bold tracking-wider text-gray-500 uppercase">
                Generation Engine
              </h3>
              <div className="grid grid-cols-2 gap-2">
                <button
                  onClick={() => handleTypeChange('fal')}
                  className={clsx(
                    'flex flex-col items-center gap-2 rounded-lg border p-3 transition-all',
                    config.type === 'fal'
                      ? 'border-blue-500 bg-blue-500/10 text-blue-400'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                  )}
                >
                  <Cloud className="h-5 w-5" />
                  <span className="text-xs font-medium">Cloud</span>
                </button>
                <button
                  onClick={() => handleTypeChange('comfy')}
                  className={clsx(
                    'flex flex-col items-center gap-2 rounded-lg border p-3 transition-all',
                    config.type === 'comfy'
                      ? 'border-green-500 bg-green-500/10 text-green-400'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                  )}
                >
                  <Server className="h-5 w-5" />
                  <span className="text-xs font-medium">Local</span>
                </button>
              </div>
            </div>

            {config.type === 'comfy' && (
              <div>
                <label className="mb-1 block text-[10px] font-bold tracking-wider text-gray-500 uppercase">
                  ComfyUI URL
                </label>
                <input
                  type="text"
                  value={localUrl}
                  onChange={e => handleUrlChange(e.target.value)}
                  className="w-full rounded border border-white/10 bg-black/50 px-2 py-1.5 font-mono text-xs text-white outline-none focus:border-green-500"
                />
                <p className="mt-1 text-[10px] text-gray-500">
                  Ensure ComfyUI is running with <code>--listen</code> or CORS enabled.
                </p>
              </div>
            )}

            {config.type === 'fal' && (
              <div>
                <label className="mb-1 block text-[10px] font-bold tracking-wider text-gray-500 uppercase">
                  Model Selection
                </label>
                <div className="space-y-2">
                  <button
                    onClick={() => handleModelChange('fal-ai/flux/dev')}
                    className={clsx(
                      'flex w-full items-center justify-between rounded border p-2 text-left transition-all',
                      !config.falModel || config.falModel === 'fal-ai/flux/dev'
                        ? 'border-blue-500 bg-blue-500/20 text-white'
                        : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                    )}
                  >
                    <span className="text-xs">Flux.1 [dev]</span>
                    {(!config.falModel || config.falModel === 'fal-ai/flux/dev') && (
                      <div className="h-2 w-2 rounded-full bg-blue-400" />
                    )}
                  </button>
                  <button
                    onClick={() => handleModelChange('fal-ai/flux-2-flex')}
                    className={clsx(
                      'flex w-full items-center justify-between rounded border p-2 text-left transition-all',
                      config.falModel === 'fal-ai/flux-2-flex'
                        ? 'border-blue-500 bg-blue-500/20 text-white'
                        : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                    )}
                  >
                    <span className="text-xs">Flux 2 [flex]</span>
                    {config.falModel === 'fal-ai/flux-2-flex' && (
                      <div className="h-2 w-2 rounded-full bg-blue-400" />
                    )}
                  </button>
                  <button
                    onClick={() => handleModelChange('fal-ai/wan-t2v')}
                    className={clsx(
                      'flex w-full items-center justify-between rounded border p-2 text-left transition-all',
                      config.falModel?.includes('wan')
                        ? 'border-blue-500 bg-blue-500/20 text-white'
                        : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                    )}
                  >
                    <span className="text-xs">Wan 2.2 [video]</span>
                    {config.falModel?.includes('wan') && (
                      <div className="h-2 w-2 rounded-full bg-blue-400" />
                    )}
                  </button>
                  <button
                    onClick={() => handleModelChange('fal-ai/ltx-video/image-to-video')}
                    className={clsx(
                      'flex w-full items-center justify-between rounded border p-2 text-left transition-all',
                      config.falModel?.includes('ltx')
                        ? 'border-blue-500 bg-blue-500/20 text-white'
                        : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                    )}
                  >
                    <span className="text-xs">LTX-Video [video]</span>
                    {config.falModel?.includes('ltx') && (
                      <div className="h-2 w-2 rounded-full bg-blue-400" />
                    )}
                  </button>
                  <button
                    onClick={() =>
                      handleModelChange('fal-ai/kling-video/v2.1/standard/image-to-video')
                    }
                    className={clsx(
                      'flex w-full items-center justify-between rounded border p-2 text-left transition-all',
                      config.falModel?.includes('kling')
                        ? 'border-blue-500 bg-blue-500/20 text-white'
                        : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                    )}
                  >
                    <span className="text-xs">Kling 2.1 [video]</span>
                    {config.falModel?.includes('kling') && (
                      <div className="h-2 w-2 rounded-full bg-blue-400" />
                    )}
                  </button>
                </div>
                <p className="mt-2 text-[10px] text-blue-300">
                  {config.falModel === 'fal-ai/flux-2-flex'
                    ? 'Newest Flux model. Higher quality & flexibility.'
                    : config.falModel?.includes('video') ||
                        config.falModel?.includes('wan') ||
                        config.falModel?.includes('ltx') ||
                        config.falModel?.includes('kling')
                      ? 'Video generation model.'
                      : 'Standard Flux.1 Dev model. Reliable & fast.'}
                </p>
              </div>
            )}
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/SaveElementModal.tsx">
'use client';

import { useState } from 'react';
import { X, Loader2 } from 'lucide-react';

interface SaveElementModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (name: string, type: string) => Promise<void>;
  initialName?: string;
  initialType?: string;
  isBatch?: boolean;
  title?: string;
}

const STANDARD_TYPES = [
  { value: 'character', label: 'Character' },
  { value: 'location', label: 'Location' },
  { value: 'prop', label: 'Prop' },
  { value: 'style', label: 'Style' },
  { value: 'reference', label: 'Reference' },
];

export function SaveElementModal({
  isOpen,
  onClose,
  onSave,
  initialName = '',
  initialType = 'character',
  isBatch = false,
  title,
}: SaveElementModalProps) {
  const [name, setName] = useState(initialName);
  const [type, setType] = useState(initialType);
  const [isSaving, setIsSaving] = useState(false);

  if (!isOpen) return null;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Name is required only if NOT batch
    if (!isBatch && !name.trim()) return;
    if (!type.trim()) return;

    setIsSaving(true);
    try {
      await onSave(name, type);
      onClose();
    } catch (error) {
      console.error('Failed to save element:', error);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="animate-in fade-in fixed inset-0 z-[100] flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm duration-200">
      <div className="animate-in zoom-in-95 relative w-full max-w-md rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl duration-200">
        <div className="flex items-center justify-between border-b border-white/10 p-4">
          <h3 className="text-sm font-bold text-white">
            {title || (isBatch ? 'Save Elements' : 'Save as Element')}
          </h3>
          <button onClick={onClose} className="text-gray-400 transition-colors hover:text-white">
            <X className="h-5 w-5" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4 p-4">
          {/* Name Input - Only show if single item */}
          {!isBatch && (
            <div>
              <label className="mb-1 block text-xs font-medium text-gray-400">Element Name</label>
              <input
                type="text"
                value={name}
                onChange={e => setName(e.target.value)}
                placeholder="e.g. My Avatar"
                className="w-full rounded-lg border border-white/10 bg-black/50 px-3 py-2 text-sm text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                autoFocus
              />
            </div>
          )}

          {/* Type Selector (Customizable) */}
          <div>
            <label className="mb-1 block text-xs font-medium text-gray-400">
              Element Type (or Custom)
            </label>
            <div className="relative">
              <input
                list="element-types"
                type="text"
                value={type}
                onChange={e => setType(e.target.value)}
                placeholder="Select or type custom..."
                className="w-full rounded-lg border border-white/10 bg-black/50 px-3 py-2 text-sm text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
              />
              <datalist id="element-types">
                {STANDARD_TYPES.map(t => (
                  <option key={t.value} value={t.value}>
                    {t.label}
                  </option>
                ))}
              </datalist>
            </div>
            <p className="mt-1 text-[10px] text-gray-500">
              Type anything to create a new category (e.g. "Face Reference")
            </p>
          </div>

          <div className="flex justify-end gap-2 pt-2">
            <button
              type="button"
              onClick={onClose}
              className="rounded-lg bg-white/5 px-4 py-2 text-sm font-medium text-gray-300 transition-colors hover:bg-white/10"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isSaving || (!isBatch && !name.trim()) || !type.trim()}
              className="flex items-center gap-2 rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-blue-500 disabled:cursor-not-allowed disabled:opacity-50"
            >
              {isSaving && <Loader2 className="h-4 w-4 animate-spin" />}
              {isBatch ? 'Save All' : 'Save Element'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/SessionSidebar.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Plus, Folder, MoreVertical, Trash2, Edit2 } from 'lucide-react';
import { clsx } from 'clsx';
import { fetchAPI } from '@/lib/api';

interface Session {
  id: string;
  name: string;
  description: string | null;
  createdAt: string;
  _count?: {
    generations: number;
  };
}

interface SessionSidebarProps {
  projectId: string;
  selectedSessionId: string | null;
  onSelectSession: (sessionId: string | null) => void;
}

export function SessionSidebar({
  projectId,
  selectedSessionId,
  onSelectSession,
}: SessionSidebarProps) {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [isCreating, setIsCreating] = useState(false);
  const [newSessionName, setNewSessionName] = useState('');

  useEffect(() => {
    loadSessions();
  }, [projectId]);

  const loadSessions = async () => {
    try {
      const data = await fetchAPI(`/projects/${projectId}/sessions`);
      setSessions(data);
    } catch (error) {
      console.error('Failed to load sessions:', error);
    }
  };

  const handleCreateSession = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newSessionName.trim()) return;

    try {
      const newSession = await fetchAPI(`/projects/${projectId}/sessions`, {
        method: 'POST',
        body: JSON.stringify({ name: newSessionName }),
      });
      setSessions([newSession, ...sessions]);
      setNewSessionName('');
      setIsCreating(false);
      onSelectSession(newSession.id);
    } catch (error) {
      console.error('Failed to create session:', error);
    }
  };

  return (
    <div className="flex h-full w-64 flex-col border-r border-white/10 bg-[#121212]">
      <div className="flex items-center justify-between border-b border-white/10 p-4">
        <h2 className="text-sm font-bold tracking-wider text-gray-400 uppercase">Sessions</h2>
        <button
          onClick={() => setIsCreating(true)}
          className="rounded-lg p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
        >
          <Plus className="h-4 w-4" />
        </button>
      </div>

      <div className="flex-1 space-y-1 overflow-y-auto p-2">
        <button
          onClick={() => onSelectSession(null)}
          className={clsx(
            'flex w-full items-center gap-2 rounded-lg px-3 py-2 text-left text-sm font-medium transition-colors',
            selectedSessionId === null
              ? 'bg-blue-600/20 text-blue-400'
              : 'text-gray-400 hover:bg-white/5 hover:text-white'
          )}
        >
          <Folder className="h-4 w-4" />
          All Generations
        </button>

        {isCreating && (
          <form onSubmit={handleCreateSession} className="px-2 py-1">
            <input
              autoFocus
              type="text"
              value={newSessionName}
              onChange={e => setNewSessionName(e.target.value)}
              placeholder="New Session Name..."
              className="w-full rounded border border-blue-500/50 bg-black/30 px-2 py-1 text-sm text-white focus:outline-none"
              onBlur={() => !newSessionName && setIsCreating(false)}
            />
          </form>
        )}

        {sessions.map(session => (
          <button
            key={session.id}
            onClick={() => onSelectSession(session.id)}
            className={clsx(
              'group flex w-full items-center justify-between rounded-lg px-3 py-2 text-left text-sm font-medium transition-colors',
              selectedSessionId === session.id
                ? 'bg-blue-600/20 text-blue-400'
                : 'text-gray-400 hover:bg-white/5 hover:text-white'
            )}
          >
            <span className="truncate">{session.name}</span>
            {session._count?.generations ? (
              <span className="text-xs opacity-50">{session._count.generations}</span>
            ) : null}
          </button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/VideoMaskEditor.tsx">
import React, { useRef, useState, useEffect } from 'react';
import { X, Check, Eraser, Pencil, Undo } from 'lucide-react';
import { clsx } from 'clsx';

interface VideoMaskEditorProps {
  videoUrl: string;
  isOpen: boolean;
  onClose: () => void;
  onSave: (maskDataUrl: string) => void;
}

export function VideoMaskEditor({ videoUrl, isOpen, onClose, onSave }: VideoMaskEditorProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [brushSize, setBrushSize] = useState(20);
  const [tool, setTool] = useState<'brush' | 'eraser'>('brush');
  const [videoSize, setVideoSize] = useState({ width: 0, height: 0 });

  // Initialize canvas when video loads
  useEffect(() => {
    if (isOpen && videoUrl) {
      const video = document.createElement('video');
      video.src = videoUrl;
      video.crossOrigin = 'anonymous';
      video.onloadedmetadata = () => {
        setVideoSize({ width: video.videoWidth, height: video.videoHeight });
        if (canvasRef.current) {
          canvasRef.current.width = video.videoWidth;
          canvasRef.current.height = video.videoHeight;
          // Clear canvas
          const ctx = canvasRef.current.getContext('2d');
          if (ctx) {
            ctx.clearRect(0, 0, video.videoWidth, video.videoHeight);
            // Fill with transparent black if needed, but for mask we usually want:
            // White = Inpaint area
            // Black = Keep area
            // Or Transparent = Keep area?
            // Fal VACE usually expects a B&W mask image.
            // Let's assume we draw White on Black.
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, video.videoWidth, video.videoHeight);
          }
        }
      };
    }
  }, [isOpen, videoUrl]);

  const startDrawing = (
    e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>
  ) => {
    setIsDrawing(true);
    draw(e);
  };

  const stopDrawing = () => {
    setIsDrawing(false);
    if (canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) ctx.beginPath(); // Reset path
    }
  };

  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Calculate coordinates
    const rect = canvas.getBoundingClientRect();
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

    // Map client coords to canvas coords
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;

    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.strokeStyle = tool === 'brush' ? 'white' : 'black';

    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  };

  const handleSave = () => {
    if (canvasRef.current) {
      const dataUrl = canvasRef.current.toDataURL('image/png');
      onSave(dataUrl);
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black/90 p-4">
      <div className="flex h-[90vh] w-full max-w-4xl flex-col gap-4">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-bold text-white">Retake / Inpaint</h2>
          <div className="flex gap-2">
            <button onClick={onClose} className="rounded-full p-2 hover:bg-white/10">
              <X className="h-6 w-6 text-white" />
            </button>
          </div>
        </div>

        {/* Editor Area */}
        <div className="relative flex flex-1 items-center justify-center overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a]">
          <div className="relative" ref={containerRef}>
            {/* Background Video (First Frame / Poster) */}
            <video
              src={videoUrl}
              className="max-h-[70vh] max-w-full object-contain opacity-50"
              muted
              playsInline
            />

            {/* Canvas Overlay */}
            <canvas
              ref={canvasRef}
              className="absolute inset-0 h-full w-full cursor-crosshair touch-none"
              onMouseDown={startDrawing}
              onMouseUp={stopDrawing}
              onMouseOut={stopDrawing}
              onMouseMove={draw}
              onTouchStart={startDrawing}
              onTouchEnd={stopDrawing}
              onTouchMove={draw}
            />
          </div>
        </div>

        {/* Toolbar */}
        <div className="flex items-center justify-between gap-4 rounded-xl border border-white/10 bg-[#1a1a1a] p-4">
          <div className="flex items-center gap-4">
            <div className="flex rounded-lg bg-black/50 p-1">
              <button
                onClick={() => setTool('brush')}
                className={clsx(
                  'rounded-md p-2 transition-colors',
                  tool === 'brush' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'
                )}
              >
                <Pencil className="h-5 w-5" />
              </button>
              <button
                onClick={() => setTool('eraser')}
                className={clsx(
                  'rounded-md p-2 transition-colors',
                  tool === 'eraser' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'
                )}
              >
                <Eraser className="h-5 w-5" />
              </button>
            </div>

            <div className="flex items-center gap-2">
              <span className="text-xs text-gray-400">Size</span>
              <input
                type="range"
                min="5"
                max="100"
                value={brushSize}
                onChange={e => setBrushSize(parseInt(e.target.value))}
                className="w-32 accent-blue-600"
              />
            </div>
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={handleSave}
              className="flex items-center gap-2 rounded-lg bg-blue-600 px-6 py-2 font-medium text-white hover:bg-blue-500"
            >
              <Check className="h-4 w-4" />
              Apply Retake
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/CastModal.tsx">
'use client';

import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';

interface CastModalProps {
  isOpen: boolean;
  onClose: () => void;
  projectId: string;
}

export function CastModal({ isOpen, onClose, projectId }: CastModalProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <div
          className="fixed inset-0 z-[100] flex items-center justify-center bg-black/50 p-4 backdrop-blur-sm"
          onClick={onClose}
        >
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            className="relative flex w-full max-w-sm flex-col overflow-hidden rounded-2xl bg-white shadow-2xl"
            onClick={e => e.stopPropagation()}
          >
            {/* Close Button */}
            <button
              onClick={onClose}
              className="absolute top-4 right-4 z-10 rounded-full bg-black/5 p-1 text-gray-500 transition-colors hover:bg-black/10"
            >
              <X className="h-5 w-5" />
            </button>

            {/* Content */}
            <div className="p-6 pt-12 text-center">
              {/* Avatar Grid Placeholder */}
              <div className="mb-6 grid grid-cols-3 gap-2 opacity-80">
                {[...Array(6)].map((_, i) => (
                  <div key={i} className="aspect-square overflow-hidden rounded-lg bg-gray-100">
                    <img
                      src={`https://api.dicebear.com/7.x/avataaars/svg?seed=${i}`}
                      alt="Cast member"
                      className="h-full w-full object-cover"
                    />
                  </div>
                ))}
              </div>

              <h2 className="mb-2 text-xl font-bold text-gray-900">See your cast in Elements</h2>
              <p className="mb-8 text-sm text-gray-500">
                Check out this project's characters, major props, locations, and more, in the
                Elements section.
              </p>

              <div className="flex items-center justify-center gap-3">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm font-medium text-gray-600 transition-colors hover:text-gray-900"
                >
                  Got it
                </button>
                <Link
                  href={`/projects/${projectId}/elements`}
                  className="rounded-lg bg-blue-600 px-6 py-2 text-sm font-medium text-white shadow-lg shadow-blue-600/20 transition-colors hover:bg-blue-700"
                >
                  Explore Elements
                </Link>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="frontend/src/components/storyboard/GenerationPickerModal.tsx">
import { useState, useEffect } from 'react';
import { fetchAPI } from '@/lib/api';
import { X, Loader2, Play } from 'lucide-react';
import { clsx } from 'clsx';

interface GenerationPickerModalProps {
  projectId: string;
  isOpen: boolean;
  onClose: () => void;
  onSelect: (generation: any) => void;
}

export function GenerationPickerModal({
  projectId,
  isOpen,
  onClose,
  onSelect,
}: GenerationPickerModalProps) {
  const [generations, setGenerations] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (isOpen) {
      loadGenerations();
    }
  }, [isOpen]);

  const loadGenerations = async () => {
    setLoading(true);
    try {
      const data = await fetchAPI(`/projects/${projectId}/generations`);
      // Filter for only succeeded generations
      setGenerations(data.filter((g: any) => g.status === 'succeeded'));
    } catch (err) {
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
      <div className="flex max-h-[80vh] w-full max-w-4xl flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl">
        <div className="flex items-center justify-between border-b border-white/10 p-6">
          <h2 className="text-xl font-bold text-white">Select a Shot</h2>
          <button onClick={onClose} className="text-gray-400 transition-colors hover:text-white">
            <X className="h-5 w-5" />
          </button>
        </div>

        <div className="flex-1 overflow-y-auto p-6">
          {loading ? (
            <div className="flex justify-center py-12">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
            </div>
          ) : generations.length === 0 ? (
            <div className="py-12 text-center text-gray-500">
              No generated shots found. Go to the Generate tab to create some!
            </div>
          ) : (
            <div className="grid grid-cols-2 gap-4 md:grid-cols-3 lg:grid-cols-4">
              {generations.map(gen => (
                <button
                  key={gen.id}
                  onClick={() => onSelect(gen)}
                  className="group relative aspect-video overflow-hidden rounded-lg border border-white/10 bg-black/50 text-left transition-all hover:border-blue-500 hover:ring-2 hover:ring-blue-500/50"
                >
                  {gen.outputs?.[0] ? (
                    <img src={gen.outputs[0].url} className="h-full w-full object-cover" />
                  ) : (
                    <div className="flex h-full w-full items-center justify-center text-gray-600">
                      No Image
                    </div>
                  )}
                  <div className="absolute inset-0 flex flex-col justify-end bg-gradient-to-t from-black/80 via-transparent to-transparent p-3 opacity-0 transition-opacity group-hover:opacity-100">
                    <p className="line-clamp-2 text-xs text-white">{gen.inputPrompt}</p>
                  </div>
                </button>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/PreviewModal.tsx">
import { useState, useEffect, useRef } from 'react';
import { X, Play, Pause, SkipBack, SkipForward, Maximize2, Minimize2 } from 'lucide-react';
import { clsx } from 'clsx';

interface PreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  scenes: any[];
}

interface PlaylistItem {
  id: string;
  url: string;
  type: 'image' | 'video';
  duration: number; // in seconds
  sceneName: string;
  shotIndex: number;
}

export function PreviewModal({ isOpen, onClose, scenes }: PreviewModalProps) {
  const [playlist, setPlaylist] = useState<PlaylistItem[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [progress, setProgress] = useState(0); // 0 to 100
  const [isFullscreen, setIsFullscreen] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const progressIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const imageTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Build playlist when scenes change or modal opens
  useEffect(() => {
    if (isOpen && scenes) {
      const newPlaylist: PlaylistItem[] = [];
      scenes.forEach(scene => {
        if (scene.shots) {
          scene.shots.forEach((shot: any) => {
            const output = shot.generation?.outputs?.[0];
            if (output) {
              newPlaylist.push({
                id: shot.id,
                url: output.url,
                type: output.type === 'video' || output.url.endsWith('.mp4') ? 'video' : 'image',
                duration: 3, // Default duration for images
                sceneName: scene.name,
                shotIndex: shot.index,
              });
            }
          });
        }
      });
      setPlaylist(newPlaylist);
      setCurrentIndex(0);
      setIsPlaying(true); // Auto-play
    } else {
      setIsPlaying(false);
      setCurrentIndex(0);
      setProgress(0);
    }
  }, [isOpen, scenes]);

  // Handle Playback Logic
  useEffect(() => {
    if (!isOpen || playlist.length === 0) return;

    const currentItem = playlist[currentIndex];

    // Clear previous timers
    if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
    if (imageTimerRef.current) clearTimeout(imageTimerRef.current);

    if (!isPlaying) return;

    if (currentItem.type === 'image') {
      // Image Logic
      const startTime = Date.now();
      const durationMs = currentItem.duration * 1000;

      // Progress Timer
      progressIntervalRef.current = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const p = Math.min((elapsed / durationMs) * 100, 100);
        setProgress(p);
      }, 50);

      // Next Item Timer
      imageTimerRef.current = setTimeout(() => {
        handleNext();
      }, durationMs);
    } else {
      // Video Logic is handled by onEnded and onTimeUpdate events on the video element
      // But we need to make sure video plays
      if (videoRef.current) {
        videoRef.current.currentTime = 0;
        videoRef.current.play().catch(console.error);
      }
    }

    return () => {
      if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
      if (imageTimerRef.current) clearTimeout(imageTimerRef.current);
    };
  }, [currentIndex, isPlaying, isOpen, playlist]);

  const handleNext = () => {
    if (currentIndex < playlist.length - 1) {
      setCurrentIndex(prev => prev + 1);
      setProgress(0);
    } else {
      setIsPlaying(false); // End of playlist
      setProgress(100);
    }
  };

  const handlePrev = () => {
    if (currentIndex > 0) {
      setCurrentIndex(prev => prev - 1);
      setProgress(0);
    }
  };

  const togglePlay = () => {
    setIsPlaying(!isPlaying);
    if (videoRef.current) {
      if (!isPlaying) videoRef.current.play();
      else videoRef.current.pause();
    }
  };

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
      setIsFullscreen(true);
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
        setIsFullscreen(false);
      }
    }
  };

  if (!isOpen) return null;

  const currentItem = playlist[currentIndex];

  return (
    <div className="fixed inset-0 z-[100] flex flex-col bg-black">
      {/* Header */}
      <div className="pointer-events-none absolute top-0 right-0 left-0 z-10 flex h-16 items-center justify-between bg-gradient-to-b from-black/80 to-transparent px-6">
        <div className="pointer-events-auto">
          <h2 className="text-lg font-bold text-white drop-shadow-md">
            {currentItem ? `${currentItem.sceneName} - Shot ${currentItem.shotIndex}` : 'Preview'}
          </h2>
        </div>
        <button
          onClick={onClose}
          className="pointer-events-auto rounded-full bg-black/40 p-2 text-white backdrop-blur-sm transition-colors hover:bg-white/20"
        >
          <X className="h-6 w-6" />
        </button>
      </div>

      {/* Content */}
      <div className="relative flex flex-1 items-center justify-center bg-black">
        {currentItem ? (
          currentItem.type === 'video' ? (
            <video
              ref={videoRef}
              src={currentItem.url}
              className="max-h-full max-w-full object-contain"
              onEnded={handleNext}
              onTimeUpdate={e => {
                const video = e.currentTarget;
                if (video.duration) {
                  setProgress((video.currentTime / video.duration) * 100);
                }
              }}
              onClick={togglePlay}
            />
          ) : (
            <img
              src={currentItem.url}
              className="animate-in fade-in max-h-full max-w-full object-contain duration-500"
              alt="Shot Preview"
            />
          )
        ) : (
          <div className="text-gray-500">No shots to preview</div>
        )}
      </div>

      {/* Controls */}
      <div className="absolute right-0 bottom-0 left-0 z-10 flex h-24 flex-col justify-end bg-gradient-to-t from-black/90 to-transparent px-8 pb-6">
        {/* Progress Bar */}
        <div className="group mb-4 h-1 w-full cursor-pointer overflow-hidden rounded-full bg-white/20">
          <div
            className="h-full bg-blue-500 transition-all duration-100 ease-linear"
            style={{ width: `${progress}%` }}
          />
        </div>

        <div className="flex items-center justify-between">
          <div className="w-20 font-mono text-sm text-gray-400">
            {currentIndex + 1} / {playlist.length}
          </div>

          <div className="flex items-center gap-6">
            <button
              onClick={handlePrev}
              disabled={currentIndex === 0}
              className="p-2 text-white/70 transition-colors hover:text-white disabled:opacity-30"
            >
              <SkipBack className="h-6 w-6" />
            </button>

            <button
              onClick={togglePlay}
              className="rounded-full bg-white p-4 text-black shadow-lg shadow-white/10 transition-transform hover:scale-105"
            >
              {isPlaying ? (
                <Pause className="h-6 w-6 fill-black" />
              ) : (
                <Play className="ml-1 h-6 w-6 fill-black" />
              )}
            </button>

            <button
              onClick={handleNext}
              disabled={currentIndex === playlist.length - 1}
              className="p-2 text-white/70 transition-colors hover:text-white disabled:opacity-30"
            >
              <SkipForward className="h-6 w-6" />
            </button>
          </div>

          <div className="flex w-20 justify-end">
            <button
              onClick={toggleFullscreen}
              className="p-2 text-white/70 transition-colors hover:text-white"
            >
              {isFullscreen ? <Minimize2 className="h-5 w-5" /> : <Maximize2 className="h-5 w-5" />}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/SceneBlock.tsx">
'use client';

import { Scene } from '@/lib/store';
import { motion } from 'framer-motion';
import { Clock, MoreVertical, Play } from 'lucide-react';

interface SceneBlockProps {
  scene: Scene;
  isActive: boolean;
  onClick: () => void;
}

export function SceneBlock({ scene, isActive, onClick }: SceneBlockProps) {
  return (
    <motion.div
      layout
      onClick={onClick}
      className={`relative aspect-video w-64 flex-shrink-0 cursor-pointer overflow-hidden rounded-xl border-2 transition-colors ${
        isActive
          ? 'border-blue-500 shadow-lg shadow-blue-500/20'
          : 'border-white/10 hover:border-white/30'
      }`}
    >
      {/* Background Image/Video Thumbnail */}
      {scene.thumbnailUrl || scene.videoUrl ? (
        <img
          src={scene.thumbnailUrl || '/placeholder-scene.jpg'}
          alt="Scene thumbnail"
          className="h-full w-full object-cover"
        />
      ) : (
        <div className="flex h-full w-full items-center justify-center bg-white/5">
          <span className="text-xs text-gray-500">Generating...</span>
        </div>
      )}

      {/* Overlay Info */}
      <div className="absolute inset-0 flex flex-col justify-end bg-gradient-to-t from-black/90 via-transparent to-transparent p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="rounded bg-blue-600 px-1.5 py-0.5 text-[10px] font-bold">
              #{scene.order + 1}
            </span>
            <div className="flex items-center gap-1 text-xs text-gray-300">
              <Clock className="h-3 w-3" />
              <span>{scene.duration}s</span>
            </div>
          </div>
          <button className="rounded-full p-1 hover:bg-white/20">
            <MoreVertical className="h-3 w-3" />
          </button>
        </div>
        <p className="mt-1 line-clamp-2 text-xs text-gray-400">{scene.prompt}</p>
      </div>

      {/* Active Indicator */}
      {isActive && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/20 backdrop-blur-[1px]">
          <div className="flex h-10 w-10 items-center justify-center rounded-full bg-white/20 backdrop-blur-md">
            <Play className="ml-0.5 h-4 w-4 fill-white text-white" />
          </div>
        </div>
      )}
    </motion.div>
  );
}
</file>

<file path="frontend/src/components/storyboard/SceneCard.tsx">
import { Plus, Sparkles, Check } from 'lucide-react';
import { Skeleton } from '@/components/ui/Skeleton';

interface SceneCardProps {
  scene: any;
  selectedSceneIds: string[];
  toggleSceneSelection: (id: string) => void;
  openGenerator: (id: string) => void;
  openPicker: (id: string) => void;
  setEditingShot: (shot: any) => void;
  setSelectedGeneration: (gen: any) => void;
  setIsEditModalOpen: (isOpen: boolean) => void;
}

export const SceneCard = ({
  scene,
  selectedSceneIds,
  toggleSceneSelection,
  openGenerator,
  openPicker,
  setEditingShot,
  setSelectedGeneration,
  setIsEditModalOpen,
}: SceneCardProps) => {
  const isSelected = selectedSceneIds.includes(scene.id);

  return (
    <article
      className="rounded-xl border border-white/10 bg-white/5 p-6"
      aria-label={`Scene: ${scene.name}`}
    >
      <div className="mb-4 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <button
            onClick={() => toggleSceneSelection(scene.id)}
            role="checkbox"
            aria-checked={isSelected}
            aria-label={`Select scene: ${scene.name}`}
            className={`flex h-5 w-5 cursor-pointer items-center justify-center rounded border transition-colors focus:ring-2 focus:ring-blue-400 focus:ring-offset-1 focus:ring-offset-black focus:outline-none ${
              isSelected
                ? 'border-blue-500 bg-blue-500'
                : 'border-white/50 bg-black/50 hover:border-white'
            }`}
          >
            {isSelected && <Check className="h-3 w-3 text-white" />}
          </button>
          <h3 className="text-xl font-bold">{scene.name}</h3>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => openGenerator(scene.id)}
            className="flex items-center gap-2 rounded-lg bg-purple-600/20 px-3 py-1.5 text-sm font-medium text-purple-400 transition-colors hover:bg-purple-600/30 focus:ring-2 focus:ring-purple-400 focus:outline-none"
            aria-label={`Generate shots for scene: ${scene.name}`}
          >
            <Sparkles className="h-4 w-4" aria-hidden="true" /> Generate Scene
          </button>
          <button
            onClick={() => openPicker(scene.id)}
            className="flex items-center gap-2 rounded-lg bg-blue-600/20 px-3 py-1.5 text-sm font-medium text-blue-400 transition-colors hover:bg-blue-600/30 focus:ring-2 focus:ring-blue-400 focus:outline-none"
            aria-label={`Add shot to scene: ${scene.name}`}
          >
            <Plus className="h-4 w-4" aria-hidden="true" /> Add Shot
          </button>
        </div>
      </div>

      <div
        className="scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent flex gap-4 overflow-x-auto pb-4"
        role="list"
        aria-label={`Shots in ${scene.name}`}
      >
        {scene.shots?.length === 0 && (
          <div className="flex aspect-video w-64 flex-col items-center justify-center gap-2 rounded-lg border border-dashed border-white/10 bg-white/5 p-4 text-sm text-gray-500">
            <span>No shots yet</span>
            <span className="text-xs text-gray-600">
              Click &quot;Add Shot&quot; or &quot;Generate Scene&quot; to get started
            </span>
          </div>
        )}
        {scene.shots?.map((shot: any) => (
          <div
            key={shot.id}
            className="group relative aspect-video w-64 flex-shrink-0 overflow-hidden rounded-lg border border-white/5 bg-black/50"
            role="listitem"
          >
            {shot.generation?.status === 'queued' || shot.generation?.status === 'running' ? (
              <Skeleton className="h-full w-full bg-white/5" aria-label="Loading shot..." />
            ) : shot.generation?.outputs?.[0] ? (
              <img
                src={shot.generation.outputs[0].url}
                className="h-full w-full object-cover"
                loading="lazy"
                alt={`Shot ${shot.index} - ${shot.generation?.inputPrompt?.slice(0, 50) || 'Generated image'}`}
              />
            ) : (
              <div
                className="flex h-full w-full items-center justify-center text-xs text-red-500"
                role="alert"
              >
                Generation failed
              </div>
            )}
            <div className="absolute bottom-2 left-2 rounded bg-black/60 px-2 py-1 text-xs text-white backdrop-blur-sm">
              Shot {shot.index}
            </div>

            {/* Edit Style Button */}
            <button
              onClick={() => setEditingShot(shot)}
              className="absolute top-2 right-2 rounded-full bg-black/60 p-1.5 text-white opacity-0 backdrop-blur-sm transition-all group-hover:opacity-100 hover:bg-purple-600 focus:opacity-100 focus:ring-2 focus:ring-purple-400 focus:outline-none"
              aria-label={`Edit style for Shot ${shot.index}`}
            >
              <Sparkles className="h-3 w-3" aria-hidden="true" />
            </button>
            <button
              onClick={() => {
                setSelectedGeneration(shot.generation);
                setIsEditModalOpen(true);
              }}
              className="absolute top-2 right-9 rounded-full bg-black/60 p-1.5 text-white opacity-0 backdrop-blur-sm transition-all group-hover:opacity-100 hover:bg-blue-600 focus:opacity-100 focus:ring-2 focus:ring-blue-400 focus:outline-none"
              aria-label={`Edit details for Shot ${shot.index}`}
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="lucide lucide-pencil"
                aria-hidden="true"
              >
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                <path d="m15 5 4 4" />
              </svg>
            </button>
          </div>
        ))}
      </div>
    </article>
  );
};
</file>

<file path="frontend/src/components/storyboard/StoryboardHeader.tsx">
'use client';

import { Monitor, Users, Wand2, Play, Download, Undo, Redo } from 'lucide-react';
import { clsx } from 'clsx';

interface StoryboardHeaderProps {
  aspectRatio: string;
  onAspectRatioChange: (ratio: string) => void;
  onStyleClick: () => void;
  onCastClick: () => void;
  onPreview: () => void;
}

const ASPECT_RATIOS = ['16:9', '9:16', '1:1', '2.35:1', '4:3'];

export function StoryboardHeader({
  aspectRatio,
  onAspectRatioChange,
  onStyleClick,
  onCastClick,
  onPreview,
}: StoryboardHeaderProps) {
  return (
    <div className="sticky top-0 z-50 flex h-16 items-center justify-between border-b border-white/10 bg-[#1a1a1a] px-6">
      {/* Left Controls */}
      <div className="flex items-center gap-4">
        {/* Aspect Ratio Selector */}
        <div className="group relative">
          <button className="flex items-center gap-2 rounded-lg bg-white/5 px-3 py-1.5 text-sm font-medium text-gray-300 transition-colors hover:bg-white/10">
            <Monitor className="h-4 w-4" />
            {aspectRatio}
          </button>
          <div className="absolute top-full left-0 hidden w-32 pt-2 group-hover:block">
            <div className="overflow-hidden rounded-lg border border-white/10 bg-[#1a1a1a] shadow-xl">
              {ASPECT_RATIOS.map(ratio => (
                <button
                  key={ratio}
                  onClick={() => onAspectRatioChange(ratio)}
                  className={clsx(
                    'w-full px-4 py-2 text-left text-sm transition-colors hover:bg-white/5',
                    aspectRatio === ratio ? 'text-blue-400' : 'text-gray-400'
                  )}
                >
                  {ratio}
                </button>
              ))}
            </div>
          </div>
        </div>

        <div className="h-6 w-px bg-white/10" />

        {/* Style Button */}
        <button
          onClick={onStyleClick}
          className="flex items-center gap-2 rounded-lg bg-white/5 px-3 py-1.5 text-sm font-medium text-gray-300 transition-colors hover:bg-white/10"
        >
          <Wand2 className="h-4 w-4" />
          Style
        </button>

        {/* Cast Button */}
        <button
          onClick={onCastClick}
          className="flex items-center gap-2 rounded-lg bg-white/5 px-3 py-1.5 text-sm font-medium text-gray-300 transition-colors hover:bg-white/10"
        >
          <Users className="h-4 w-4" />
          Cast
        </button>
      </div>

      {/* Right Controls */}
      <div className="flex items-center gap-4">
        {/* Undo/Redo (Visual only) */}
        <div className="mr-4 flex items-center gap-1">
          <button className="p-2 text-gray-500 transition-colors hover:text-gray-300 disabled:opacity-50">
            <Undo className="h-4 w-4" />
          </button>
          <button className="p-2 text-gray-500 transition-colors hover:text-gray-300 disabled:opacity-50">
            <Redo className="h-4 w-4" />
          </button>
        </div>

        <button
          onClick={onPreview}
          className="flex items-center gap-2 rounded-lg bg-white/10 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-white/20"
        >
          <Play className="h-4 w-4 fill-white" />
          Preview
        </button>

        <button className="flex items-center gap-2 rounded-lg bg-white px-4 py-2 text-sm font-bold text-black transition-colors hover:bg-gray-200">
          <Download className="h-4 w-4" />
          Export
        </button>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/TemplateSelector.tsx">
import React from 'react';
import { WORKFLOW_TEMPLATES, WorkflowTemplate } from '../../data/workflowTemplates';
import { clsx } from 'clsx';

interface TemplateSelectorProps {
  onSelect: (template: WorkflowTemplate) => void;
  selectedId?: string;
}

export function TemplateSelector({ onSelect, selectedId }: TemplateSelectorProps) {
  return (
    <div className="grid grid-cols-2 gap-4">
      {WORKFLOW_TEMPLATES.map(template => (
        <button
          key={template.id}
          onClick={() => onSelect(template)}
          className={clsx(
            'flex flex-col items-start rounded-xl border p-4 text-left transition-all hover:bg-white/5',
            selectedId === template.id
              ? 'border-blue-500 bg-blue-600/20 ring-1 ring-blue-500'
              : 'border-white/10 bg-black/30'
          )}
        >
          <div className="mb-2 flex items-center gap-3">
            <span className="text-2xl">{template.icon}</span>
            <span className="font-medium text-white">{template.name}</span>
          </div>
          <p className="line-clamp-2 text-xs text-gray-400">{template.description}</p>
        </button>
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/ImageMaskEditor.tsx">
import React, { useRef, useState, useEffect } from 'react';
import { X, Check, Eraser, Pencil, Undo } from 'lucide-react';
import { clsx } from 'clsx';
import { Tooltip } from '@/components/ui/Tooltip';

interface ImageMaskEditorProps {
  imageUrl: string;
  isOpen: boolean;
  onClose: () => void;
  onSave: (
    maskDataUrl: string,
    prompt: string,
    negativePrompt: string,
    strength: number,
    seed?: number
  ) => void;
  initialPrompt?: string;
}

export function ImageMaskEditor({
  imageUrl,
  isOpen,
  onClose,
  onSave,
  initialPrompt = '',
}: ImageMaskEditorProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [brushSize, setBrushSize] = useState(40);
  const [tool, setTool] = useState<'brush' | 'eraser'>('brush');
  const [prompt, setPrompt] = useState(initialPrompt);
  const [negativePrompt, setNegativePrompt] = useState('');
  const [strength, setStrength] = useState(1.0);
  const [seed, setSeed] = useState<string>(''); // Seed as string for input
  const [imageSize, setImageSize] = useState({ width: 0, height: 0 });

  // Initialize canvas when image loads
  useEffect(() => {
    if (isOpen && imageUrl) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = imageUrl;
      img.onload = () => {
        setImageSize({ width: img.width, height: img.height });
        if (canvasRef.current) {
          canvasRef.current.width = img.width;
          canvasRef.current.height = img.height;
          // Clear canvas (transparent)
          const ctx = canvasRef.current.getContext('2d');
          if (ctx) {
            ctx.clearRect(0, 0, img.width, img.height);
          }
        }
      };
    }
  }, [isOpen, imageUrl]);

  const startDrawing = (
    e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>
  ) => {
    setIsDrawing(true);
    draw(e);
  };

  const stopDrawing = () => {
    setIsDrawing(false);
    if (canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) ctx.beginPath(); // Reset path
    }
  };

  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Calculate coordinates
    const rect = canvas.getBoundingClientRect();
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

    // Map client coords to canvas coords
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;

    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // We draw with White for the mask (Inpaint area)
    // If eraser, we use 'destination-out' to make it transparent again
    ctx.globalCompositeOperation = tool === 'brush' ? 'source-over' : 'destination-out';
    ctx.strokeStyle = 'white'; // Always white for mask

    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);

    // Reset composite operation
    ctx.globalCompositeOperation = 'source-over';
  };

  const handleSave = () => {
    if (canvasRef.current) {
      // Create a temporary canvas to composite the mask
      // We need a Black background (Keep) and White foreground (Inpaint)
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvasRef.current.width;
      tempCanvas.height = canvasRef.current.height;
      const tCtx = tempCanvas.getContext('2d');

      if (tCtx) {
        // 1. Fill with Black (Keep area)
        tCtx.fillStyle = 'black';
        tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // 2. Draw the user's mask (White/Transparent) on top
        tCtx.drawImage(canvasRef.current, 0, 0);

        try {
          const dataUrl = tempCanvas.toDataURL('image/png');
          const seedNumber = seed ? parseInt(seed) : undefined;
          onSave(dataUrl, prompt, negativePrompt, strength, seedNumber);
          onClose();
        } catch (e) {
          console.error('Failed to export mask from canvas:', e);
          alert('Failed to create mask. The image might be protected or failed to load correctly.');
        }
      }
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black/90 p-4">
      <div className="flex h-[90vh] w-full max-w-5xl flex-col gap-4">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-bold text-white">Inpaint Image</h2>
          <div className="flex gap-2">
            <button onClick={onClose} className="rounded-full p-2 hover:bg-white/10">
              <X className="h-6 w-6 text-white" />
            </button>
          </div>
        </div>

        {/* Editor Area */}
        <div className="relative flex flex-1 items-center justify-center overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a]">
          <div className="relative" ref={containerRef}>
            {/* Background Image */}
            <img
              src={imageUrl}
              crossOrigin="anonymous"
              className="max-h-[60vh] max-w-full object-contain opacity-50"
            />

            {/* Canvas Overlay */}
            <canvas
              ref={canvasRef}
              className="absolute inset-0 h-full w-full cursor-crosshair touch-none"
              onMouseDown={startDrawing}
              onMouseUp={stopDrawing}
              onMouseOut={stopDrawing}
              onMouseMove={draw}
              onTouchStart={startDrawing}
              onTouchEnd={stopDrawing}
              onTouchMove={draw}
            />
          </div>
        </div>

        {/* Controls & Prompt */}
        <div className="flex flex-col gap-4 rounded-xl border border-white/10 bg-[#1a1a1a] p-4">
          <div className="grid grid-cols-2 gap-4">
            {/* Prompt Input */}
            <div className="flex flex-col gap-2">
              <label className="text-xs font-bold tracking-wider text-gray-500 uppercase">
                Inpaint Prompt
              </label>
              <input
                type="text"
                value={prompt}
                onChange={e => setPrompt(e.target.value)}
                placeholder="Describe what you want to see..."
                className="w-full rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:border-blue-500 focus:outline-none"
              />
            </div>

            {/* Negative Prompt Input */}
            <div className="flex flex-col gap-2">
              <label className="text-xs font-bold tracking-wider text-gray-500 uppercase">
                Negative Prompt
              </label>
              <input
                type="text"
                value={negativePrompt}
                onChange={e => setNegativePrompt(e.target.value)}
                placeholder="What to avoid (e.g. clothes, bad quality)..."
                className="w-full rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:border-red-500/50 focus:outline-none"
              />
            </div>
          </div>

          <div className="flex items-center justify-between gap-4 border-t border-white/5 pt-4">
            <div className="flex items-center gap-4">
              <div className="flex rounded-lg bg-black/50 p-1">
                <Tooltip content="Brush (Mask)" side="top">
                  <button
                    onClick={() => setTool('brush')}
                    className={clsx(
                      'rounded-md p-2 transition-colors',
                      tool === 'brush' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'
                    )}
                  >
                    <Pencil className="h-5 w-5" />
                  </button>
                </Tooltip>
                <Tooltip content="Eraser (Unmask)" side="top">
                  <button
                    onClick={() => setTool('eraser')}
                    className={clsx(
                      'rounded-md p-2 transition-colors',
                      tool === 'eraser' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'
                    )}
                  >
                    <Eraser className="h-5 w-5" />
                  </button>
                </Tooltip>
              </div>

              <div className="flex items-center gap-2">
                <span className="text-xs text-gray-400">Brush Size</span>
                <input
                  type="range"
                  min="5"
                  max="100"
                  value={brushSize}
                  onChange={e => setBrushSize(parseInt(e.target.value))}
                  className="w-24 accent-blue-600"
                />
              </div>

              <div className="flex items-center gap-2 border-l border-white/10 pl-4">
                <span className="text-xs text-gray-400">Strength ({strength})</span>
                <input
                  type="range"
                  min="0.1"
                  max="1.0"
                  step="0.05"
                  value={strength}
                  onChange={e => setStrength(parseFloat(e.target.value))}
                  className="w-24 accent-green-600"
                />
              </div>

              <div className="flex items-center gap-2 border-l border-white/10 pl-4">
                <span className="text-xs text-gray-400">Seed</span>
                <input
                  type="text"
                  value={seed}
                  onChange={e => setSeed(e.target.value.replace(/[^0-9]/g, ''))}
                  placeholder="Random"
                  className="w-32 rounded border border-white/10 bg-black/50 px-2 py-1 text-xs text-white focus:border-purple-500 focus:outline-none"
                />
              </div>
            </div>

            <div className="flex items-center gap-2">
              <button
                onClick={handleSave}
                className="flex items-center gap-2 rounded-lg bg-blue-600 px-6 py-2 font-medium text-white hover:bg-blue-500"
              >
                <Check className="h-4 w-4" />
                Generate
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/MagicPromptButton.tsx">
import { useState } from 'react';
import { Sparkles, Loader2 } from 'lucide-react';
import { fetchAPI } from '@/lib/api';
import { clsx } from 'clsx';
import { Tooltip } from '@/components/ui/Tooltip';

interface MagicPromptButtonProps {
  currentPrompt: string;
  onPromptEnhanced: (enhancedPrompt: string) => void;
  className?: string;
}

export function MagicPromptButton({
  currentPrompt,
  onPromptEnhanced,
  className,
}: MagicPromptButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  const handleEnhance = async () => {
    if (!currentPrompt.trim()) return;

    setIsLoading(true);
    try {
      const response = await fetchAPI('/llm/generate', {
        method: 'POST',
        body: JSON.stringify({
          prompt: `Enhance this image generation prompt to be more descriptive, artistic, and detailed. Keep the core subject but improve the style and lighting descriptions. Output ONLY the enhanced prompt, no other text.
                    
                    Original Prompt: "${currentPrompt}"`,
          model: 'dolphin-llama3', // Use Ollama for enhanced prompting
          temperature: 0.7,
          maxTokens: 200,
        }),
      });

      if (response.content) {
        let enhanced = response.content.trim();
        // Remove surrounding quotes if present
        if (enhanced.startsWith('"') && enhanced.endsWith('"')) {
          enhanced = enhanced.slice(1, -1);
        }
        // Remove JSON wrapper if present (e.g. {"prompt": "..."})
        if (enhanced.startsWith('{') && enhanced.endsWith('}')) {
          try {
            const parsed = JSON.parse(enhanced);
            if (parsed.prompt) enhanced = parsed.prompt;
            else if (parsed.content) enhanced = parsed.content;
          } catch (e) {
            // If parse fails, just use the string but maybe strip braces?
            // For now, assume if it parses, we use it.
          }
        }
        onPromptEnhanced(enhanced);
      }
    } catch (error) {
      console.error('Failed to enhance prompt:', error);
      // Optional: Show toast error
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Tooltip content="Enhance Prompt with AI" side="top">
      <button
        type="button"
        onClick={handleEnhance}
        disabled={isLoading || !currentPrompt.trim()}
        className={clsx(
          'relative rounded-lg p-2 transition-all',
          isLoading
            ? 'bg-purple-500/20 text-purple-300'
            : 'text-gray-400 hover:bg-purple-500/20 hover:text-purple-300',
          className
        )}
      >
        {isLoading ? <Loader2 className="h-5 w-5 animate-spin" /> : <Sparkles className="h-5 w-5" />}
      </button>
    </Tooltip>
  );
}
</file>

<file path="frontend/src/components/generations/VideoScopes.tsx">
/**
 * VideoScopes - Director's Loupe
 *
 * Professional RGB Histogram and Luma Waveform scopes for quality control.
 * Helps identify clipping, exposure issues, and color balance.
 *
 * Features:
 * - RGB Histogram: Shows R/G/B channel distribution
 * - Luma Waveform: Shows brightness levels (BT.709)
 * - Clipping Indicators: Red bars for crushed blacks/clipped highlights
 */

import { useEffect, useRef, useState, useCallback } from 'react';
import { clsx } from 'clsx';
import { Activity, BarChart3 } from 'lucide-react';

type ScopeType = 'histogram' | 'waveform';

interface VideoScopesProps {
  imageUrl?: string;
  videoRef?: React.RefObject<HTMLVideoElement>;
  className?: string;
  defaultType?: ScopeType;
}

export function VideoScopes({
  imageUrl,
  videoRef,
  className,
  defaultType = 'histogram',
}: VideoScopesProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [scopeType, setScopeType] = useState<ScopeType>(defaultType);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const animationFrameRef = useRef<number | undefined>(undefined);

  // BT.709 Luma coefficients
  const LUMA_R = 0.2126;
  const LUMA_G = 0.7152;
  const LUMA_B = 0.0722;

  const analyzeFrame = useCallback((sourceCanvas: HTMLCanvasElement) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    // Get source image data
    const sourceCtx = sourceCanvas.getContext('2d');
    if (!sourceCtx) return;

    const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
    const data = imageData.data;

    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);

    if (scopeType === 'histogram') {
      drawHistogram(ctx, data, width, height);
    } else {
      drawWaveform(ctx, data, sourceCanvas.width, sourceCanvas.height, width, height);
    }
  }, [scopeType]);

  const drawHistogram = (
    ctx: CanvasRenderingContext2D,
    data: Uint8ClampedArray,
    width: number,
    height: number
  ) => {
    // Initialize histogram bins
    const rHist = new Array(256).fill(0);
    const gHist = new Array(256).fill(0);
    const bHist = new Array(256).fill(0);

    // Count pixel values
    for (let i = 0; i < data.length; i += 4) {
      rHist[data[i]]++;
      gHist[data[i + 1]]++;
      bHist[data[i + 2]]++;
    }

    // Find max value for normalization
    const maxVal = Math.max(
      ...rHist.slice(1, 254),
      ...gHist.slice(1, 254),
      ...bHist.slice(1, 254)
    );

    const barWidth = width / 256;
    const padding = 10;
    const graphHeight = height - padding * 2;

    // Draw each channel
    const drawChannel = (hist: number[], color: string, alpha: number) => {
      ctx.fillStyle = color;
      ctx.globalAlpha = alpha;

      for (let i = 0; i < 256; i++) {
        const barHeight = (hist[i] / maxVal) * graphHeight;
        ctx.fillRect(
          i * barWidth,
          height - padding - barHeight,
          barWidth,
          barHeight
        );
      }
    };

    // Draw in order: Blue, Green, Red (so red is on top)
    drawChannel(bHist, '#3b82f6', 0.6);
    drawChannel(gHist, '#22c55e', 0.6);
    drawChannel(rHist, '#ef4444', 0.6);

    ctx.globalAlpha = 1;

    // Draw clipping indicators
    const clipThreshold = maxVal * 0.8;

    // Crushed blacks
    if (rHist[0] > clipThreshold || gHist[0] > clipThreshold || bHist[0] > clipThreshold) {
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, 0, 4, height);
    }

    // Clipped highlights
    if (rHist[255] > clipThreshold || gHist[255] > clipThreshold || bHist[255] > clipThreshold) {
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(width - 4, 0, 4, height);
    }

    // Draw scale lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const x = (i / 4) * width;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
  };

  const drawWaveform = (
    ctx: CanvasRenderingContext2D,
    data: Uint8ClampedArray,
    sourceWidth: number,
    sourceHeight: number,
    width: number,
    height: number
  ) => {
    const padding = 10;
    const graphHeight = height - padding * 2;

    // Draw IRE scale (0-100)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.font = '9px monospace';
    ctx.textAlign = 'right';

    for (let ire = 0; ire <= 100; ire += 20) {
      const y = height - padding - (ire / 100) * graphHeight;
      ctx.fillText(`${ire}`, 20, y + 3);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.beginPath();
      ctx.moveTo(25, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }

    // Sample columns for waveform
    const sampleStep = Math.max(1, Math.floor(sourceWidth / (width - 30)));

    // Create waveform data
    ctx.globalAlpha = 0.15;

    for (let col = 0; col < sourceWidth; col += sampleStep) {
      for (let row = 0; row < sourceHeight; row++) {
        const idx = (row * sourceWidth + col) * 4;
        const r = data[idx];
        const g = data[idx + 1];
        const b = data[idx + 2];

        // Calculate luma using BT.709
        const luma = LUMA_R * r + LUMA_G * g + LUMA_B * b;
        const ire = luma / 255;

        const x = 30 + ((col / sourceWidth) * (width - 30));
        const y = height - padding - (ire * graphHeight);

        // Draw colored dot based on RGB dominance
        if (r > g && r > b) {
          ctx.fillStyle = '#ef4444';
        } else if (g > r && g > b) {
          ctx.fillStyle = '#22c55e';
        } else if (b > r && b > g) {
          ctx.fillStyle = '#3b82f6';
        } else {
          ctx.fillStyle = '#ffffff';
        }

        ctx.fillRect(x, y, 1, 1);
      }
    }

    ctx.globalAlpha = 1;

    // Draw clipping indicators
    // Check for crushed blacks (lots of 0 luma)
    let blackCount = 0;
    let whiteCount = 0;
    const totalPixels = sourceWidth * sourceHeight;

    for (let i = 0; i < data.length; i += 4) {
      const luma = LUMA_R * data[i] + LUMA_G * data[i + 1] + LUMA_B * data[i + 2];
      if (luma < 5) blackCount++;
      if (luma > 250) whiteCount++;
    }

    if (blackCount / totalPixels > 0.05) {
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, height - 4, width, 4);
      ctx.fillStyle = '#fff';
      ctx.font = '8px sans-serif';
      ctx.fillText('CRUSHED', 5, height - 6);
    }

    if (whiteCount / totalPixels > 0.05) {
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, 0, width, 4);
      ctx.fillStyle = '#fff';
      ctx.font = '8px sans-serif';
      ctx.fillText('CLIPPED', 5, 10);
    }
  };

  // Analyze from image URL
  useEffect(() => {
    if (!imageUrl || videoRef?.current) return;

    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      const tempCtx = tempCanvas.getContext('2d');
      if (tempCtx) {
        tempCtx.drawImage(img, 0, 0);
        analyzeFrame(tempCanvas);
      }
    };
    img.src = imageUrl;
  }, [imageUrl, analyzeFrame]);

  // Analyze from video
  useEffect(() => {
    if (!videoRef?.current) return;

    const video = videoRef.current;

    const captureFrame = () => {
      if (video.readyState >= 2) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = video.videoWidth || 640;
        tempCanvas.height = video.videoHeight || 360;
        const tempCtx = tempCanvas.getContext('2d');
        if (tempCtx) {
          tempCtx.drawImage(video, 0, 0);
          analyzeFrame(tempCanvas);
        }
      }
      animationFrameRef.current = requestAnimationFrame(captureFrame);
    };

    if (!video.paused) {
      setIsAnalyzing(true);
      captureFrame();
    }

    const handlePlay = () => {
      setIsAnalyzing(true);
      captureFrame();
    };

    const handlePause = () => {
      setIsAnalyzing(false);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      // Capture one last frame
      captureFrame();
    };

    const handleSeeked = () => {
      // Capture frame after seek
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = video.videoWidth || 640;
      tempCanvas.height = video.videoHeight || 360;
      const tempCtx = tempCanvas.getContext('2d');
      if (tempCtx) {
        tempCtx.drawImage(video, 0, 0);
        analyzeFrame(tempCanvas);
      }
    };

    video.addEventListener('play', handlePlay);
    video.addEventListener('pause', handlePause);
    video.addEventListener('seeked', handleSeeked);

    // Initial capture if paused
    if (video.paused && video.readyState >= 2) {
      handleSeeked();
    }

    return () => {
      video.removeEventListener('play', handlePlay);
      video.removeEventListener('pause', handlePause);
      video.removeEventListener('seeked', handleSeeked);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [videoRef, analyzeFrame]);

  return (
    <div className={clsx('rounded-lg border border-white/10 bg-black/80 p-2', className)}>
      {/* Scope Type Toggle */}
      <div className="mb-2 flex items-center justify-between">
        <div className="flex gap-1">
          <button
            onClick={() => setScopeType('histogram')}
            className={clsx(
              'flex items-center gap-1 rounded px-2 py-1 text-xs transition-colors',
              scopeType === 'histogram'
                ? 'bg-cyan-500/20 text-cyan-400'
                : 'text-gray-500 hover:text-white'
            )}
          >
            <BarChart3 className="h-3 w-3" />
            RGB Histogram
          </button>
          <button
            onClick={() => setScopeType('waveform')}
            className={clsx(
              'flex items-center gap-1 rounded px-2 py-1 text-xs transition-colors',
              scopeType === 'waveform'
                ? 'bg-cyan-500/20 text-cyan-400'
                : 'text-gray-500 hover:text-white'
            )}
          >
            <Activity className="h-3 w-3" />
            Luma Waveform
          </button>
        </div>
        {isAnalyzing && (
          <span className="text-xs text-green-400"> Live</span>
        )}
      </div>

      {/* Scope Canvas */}
      <canvas
        ref={canvasRef}
        width={280}
        height={120}
        className="w-full rounded bg-black"
      />

      {/* Legend */}
      <div className="mt-1 flex justify-center gap-3 text-[10px]">
        <span className="flex items-center gap-1">
          <span className="h-2 w-2 rounded-full bg-red-500" />
          R
        </span>
        <span className="flex items-center gap-1">
          <span className="h-2 w-2 rounded-full bg-green-500" />
          G
        </span>
        <span className="flex items-center gap-1">
          <span className="h-2 w-2 rounded-full bg-blue-500" />
          B
        </span>
        {scopeType === 'waveform' && (
          <span className="text-gray-500">| IRE 0-100</span>
        )}
      </div>
    </div>
  );
}

export default VideoScopes;
</file>

<file path="frontend/src/components/layout/StudioLayout.tsx">
'use client';

import { StudioSidebar } from './StudioSidebar';

interface StudioLayoutProps {
  children: React.ReactNode;
  projectId?: string;
}

export function StudioLayout({ children, projectId }: StudioLayoutProps) {
  return (
    <div className="flex min-h-screen bg-[var(--background)] font-sans text-[var(--foreground)]">
      <StudioSidebar projectId={projectId} />
      <main className="relative h-screen flex-1 overflow-x-hidden overflow-y-auto">
        {/* Cinematic Background Gradient Spotlights */}
        <div className="pointer-events-none fixed inset-0 z-0">
          <div
            className="absolute top-[-20%] left-[-10%] h-[50%] w-[50%] animate-pulse rounded-full bg-purple-900/10 mix-blend-screen blur-[120px]"
            style={{ animationDuration: '8s' }}
          />
          <div
            className="absolute right-[-10%] bottom-[-10%] h-[60%] w-[40%] animate-pulse rounded-full bg-indigo-900/10 mix-blend-screen blur-[120px]"
            style={{ animationDuration: '12s' }}
          />
        </div>

        <div className="relative z-10 mx-auto max-w-[1920px] p-6">{children}</div>
      </main>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/CameraControlPanel.tsx">
import React from 'react';
import {
  ArrowUp,
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ZoomIn,
  ZoomOut,
  Move,
  RotateCw,
  RotateCcw,
} from 'lucide-react';
import { Tooltip } from '@/components/ui/Tooltip';

export interface CameraMovement {
  type: 'pan' | 'tilt' | 'zoom' | 'roll' | 'static';
  direction?: 'left' | 'right' | 'up' | 'down' | 'in' | 'out' | 'cw' | 'ccw';
  intensity?: number; // 1-10
}

interface CameraControlPanelProps {
  value: CameraMovement;
  onChange: (value: CameraMovement) => void;
}

export function CameraControlPanel({ value, onChange }: CameraControlPanelProps) {
  const handleDirection = (
    type: CameraMovement['type'],
    direction: CameraMovement['direction']
  ) => {
    onChange({ type, direction, intensity: 5 });
  };

  const isActive = (type: string, dir?: string) => {
    if (value.type !== type) return false;
    if (dir && value.direction !== dir) return false;
    return true;
  };

  const btnClass = (active: boolean) =>
    `p-2 rounded-lg border transition-all ${
      active
        ? 'bg-blue-500/20 border-blue-500 text-blue-400'
        : 'bg-zinc-800 border-zinc-700 hover:bg-zinc-700 text-zinc-400'
    }`;

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-zinc-300">Camera Movement</label>
        {value.type !== 'static' && (
          <button
            onClick={() => onChange({ type: 'static' })}
            className="text-xs text-zinc-500 hover:text-zinc-300"
          >
            Reset
          </button>
        )}
      </div>

      <div className="grid grid-cols-2 gap-4">
        {/* Pan & Tilt Control Pad */}
        <div className="flex flex-col items-center justify-center gap-2 rounded-xl border border-zinc-800 bg-zinc-900/50 p-3">
          <span className="mb-1 text-xs text-zinc-500">Pan & Tilt</span>
          <div className="grid grid-cols-3 gap-1">
            <div />
            <Tooltip content="Tilt Up" side="top">
              <button
                className={btnClass(isActive('tilt', 'up'))}
                onClick={() => handleDirection('tilt', 'up')}
              >
                <ArrowUp size={16} />
              </button>
            </Tooltip>
            <div />

            <Tooltip content="Pan Left" side="left">
              <button
                className={btnClass(isActive('pan', 'left'))}
                onClick={() => handleDirection('pan', 'left')}
              >
                <ArrowLeft size={16} />
              </button>
            </Tooltip>
            <div className="flex h-8 w-8 items-center justify-center rounded-full bg-zinc-800">
              <Move size={14} className="text-zinc-600" />
            </div>
            <Tooltip content="Pan Right" side="right">
              <button
                className={btnClass(isActive('pan', 'right'))}
                onClick={() => handleDirection('pan', 'right')}
              >
                <ArrowRight size={16} />
              </button>
            </Tooltip>

            <div />
            <Tooltip content="Tilt Down" side="top">
              <button
                className={btnClass(isActive('tilt', 'down'))}
                onClick={() => handleDirection('tilt', 'down')}
              >
                <ArrowDown size={16} />
              </button>
            </Tooltip>
            <div />
          </div>
        </div>

        {/* Zoom & Roll */}
        <div className="space-y-3">
          <div className="rounded-xl border border-zinc-800 bg-zinc-900/50 p-3">
            <span className="mb-2 block text-xs text-zinc-500">Zoom</span>
            <div className="flex gap-2">
              <button
                className={`flex flex-1 items-center justify-center gap-2 ${btnClass(isActive('zoom', 'in'))}`}
                onClick={() => handleDirection('zoom', 'in')}
              >
                <ZoomIn size={16} />
                <span className="text-xs">In</span>
              </button>
              <button
                className={`flex flex-1 items-center justify-center gap-2 ${btnClass(isActive('zoom', 'out'))}`}
                onClick={() => handleDirection('zoom', 'out')}
              >
                <ZoomOut size={16} />
                <span className="text-xs">Out</span>
              </button>
            </div>
          </div>

          <div className="rounded-xl border border-zinc-800 bg-zinc-900/50 p-3">
            <span className="mb-2 block text-xs text-zinc-500">Roll</span>
            <div className="flex gap-2">
              <button
                className={`flex flex-1 items-center justify-center gap-2 ${btnClass(isActive('roll', 'ccw'))}`}
                onClick={() => handleDirection('roll', 'ccw')}
              >
                <RotateCcw size={16} />
                <span className="text-xs">CCW</span>
              </button>
              <button
                className={`flex flex-1 items-center justify-center gap-2 ${btnClass(isActive('roll', 'cw'))}`}
                onClick={() => handleDirection('roll', 'cw')}
              >
                <RotateCw size={16} />
                <span className="text-xs">CW</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Intensity Slider */}
      {value.type !== 'static' && (
        <div className="space-y-2 pt-2">
          <div className="flex justify-between text-xs text-zinc-500">
            <span>Intensity</span>
            <span>{value.intensity || 5}</span>
          </div>
          <input
            type="range"
            min="1"
            max="10"
            value={value.intensity || 5}
            onChange={e => onChange({ ...value, intensity: parseInt(e.target.value) })}
            className="h-1 w-full cursor-pointer appearance-none rounded-lg bg-zinc-700 accent-blue-500"
          />
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/CameraPresetSelector.tsx">
'use client';

import { useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { ChevronDown, Check, Sparkles, Ban, Plus, X, Search } from 'lucide-react';
import { Tooltip } from '@/components/ui/Tooltip';
import {
  CAMERA_PRESETS,
  CameraPreset,
  CameraCategory,
  Genre,
  getAllPresets,
  getPresetById,
  getCategoryForPreset,
  TOTAL_PRESETS,
} from '@/data/CameraPresets';
import {
  GENRE_TEMPLATES,
  getRecommendedCameraPresets,
  getAvoidedCameraPresets,
  isCameraPresetRecommended,
  isCameraPresetAvoided,
  getGenreOptions,
} from '@/data/GenreTemplates';

interface CameraPresetSelectorProps {
  selectedPreset: string | null;
  onSelect: (preset: CameraPreset) => void;
  genre?: Genre | null;
  showGenreRecommendations?: boolean;
  allowMixing?: boolean; // Enable Higgsfield Mix style combining
  selectedMixPresets?: string[]; // For mixing mode
  onMixSelect?: (presets: string[]) => void;
  className?: string;
}

export function CameraPresetSelector({
  selectedPreset,
  onSelect,
  genre = null,
  showGenreRecommendations = true,
  allowMixing = false,
  selectedMixPresets = [],
  onMixSelect,
  className,
}: CameraPresetSelectorProps) {
  const [activeCategory, setActiveCategory] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [showSearch, setShowSearch] = useState(false);
  const [mixMode, setMixMode] = useState(false);

  const genreTemplate = genre ? GENRE_TEMPLATES[genre] : null;

  // Filter presets by search query
  const filteredPresets = useMemo(() => {
    if (!searchQuery.trim()) return null;
    const query = searchQuery.toLowerCase();
    return getAllPresets().filter(
      preset =>
        preset.name.toLowerCase().includes(query) ||
        preset.description.toLowerCase().includes(query) ||
        preset.prompt.toLowerCase().includes(query)
    );
  }, [searchQuery]);

  // Get recommended presets for current genre
  const recommendedPresets = useMemo(() => {
    if (!genre) return [];
    return getRecommendedCameraPresets(genre);
  }, [genre]);

  // Handle preset selection
  const handlePresetClick = (preset: CameraPreset) => {
    if (mixMode && allowMixing && onMixSelect) {
      // Mixing mode - toggle selection
      const newSelection = selectedMixPresets.includes(preset.id)
        ? selectedMixPresets.filter(id => id !== preset.id)
        : [...selectedMixPresets, preset.id].slice(0, 3); // Max 3 presets
      onMixSelect(newSelection);
    } else {
      // Normal mode - single selection
      onSelect(preset);
    }
  };

  // Get combined prompt for mixed presets
  const getMixedPrompt = () => {
    if (selectedMixPresets.length === 0) return '';
    return selectedMixPresets
      .map(id => getPresetById(id)?.prompt)
      .filter(Boolean)
      .join(', ');
  };

  // Render preset button
  const renderPresetButton = (preset: CameraPreset) => {
    const isSelected = mixMode
      ? selectedMixPresets.includes(preset.id)
      : selectedPreset === preset.id;
    const isRecommended = genre && isCameraPresetRecommended(preset.id, genre);
    const isAvoided = genre && isCameraPresetAvoided(preset.id, genre);

    return (
      <button
        key={preset.id}
        onClick={() => !isAvoided && handlePresetClick(preset)}
        disabled={isAvoided ?? false}
        title={preset.description}
        className={clsx(
          'relative rounded-lg border px-3 py-2 text-left text-xs font-medium transition-all',
          isSelected
            ? 'border-blue-500 bg-blue-500 text-white shadow-lg shadow-blue-500/25'
            : isAvoided
              ? 'cursor-not-allowed border-red-500/20 bg-red-500/5 text-gray-600 opacity-50'
              : 'border-white/10 bg-white/5 text-gray-300 hover:border-white/20 hover:bg-white/10 hover:text-white'
        )}
      >
        <span className="block truncate">{preset.name}</span>
        {/* Indicators */}
        {isRecommended && !isSelected && (
          <Tooltip content="Recommended for this genre" side="top">
            <span
              className="absolute -top-1 -right-1 h-2 w-2 rounded-full bg-green-500"
            />
          </Tooltip>
        )}
        {isAvoided && <Ban className="absolute -top-1 -right-1 h-3 w-3 text-red-400" />}
        {isSelected && mixMode && (
          <span className="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-blue-500 text-[10px] font-bold">
            {selectedMixPresets.indexOf(preset.id) + 1}
          </span>
        )}
      </button>
    );
  };

  return (
    <div className={clsx('space-y-3', className)}>
      {/* Header with search and mix toggle */}
      <div className="flex items-center justify-between gap-2">
        <div className="flex items-center gap-2">
          <h4 className="text-xs font-bold tracking-wider text-gray-400 uppercase">Camera Move</h4>
          <span className="text-[10px] text-gray-500">({TOTAL_PRESETS} presets)</span>
        </div>
        <div className="flex items-center gap-1">
          {/* Search toggle */}
          <Tooltip content="Search presets" side="top">
            <button
              onClick={() => setShowSearch(!showSearch)}
              className={clsx(
                'rounded-lg p-1.5 transition-colors',
                showSearch
                  ? 'bg-blue-500/20 text-blue-400'
                  : 'text-gray-400 hover:bg-white/10 hover:text-white'
              )}
            >
              <Search className="h-3.5 w-3.5" />
            </button>
          </Tooltip>
          {/* Mix mode toggle */}
          {allowMixing && (
            <Tooltip content="Combine multiple camera moves" side="top">
              <button
                onClick={() => {
                  setMixMode(!mixMode);
                  if (!mixMode) onMixSelect?.([]);
                }}
                className={clsx(
                  'flex items-center gap-1 rounded-lg px-2 py-1 text-[10px] font-medium transition-colors',
                  mixMode
                    ? 'border border-purple-500/30 bg-purple-500/20 text-purple-400'
                    : 'border border-transparent text-gray-400 hover:bg-white/10 hover:text-white'
                )}
              >
                <Plus className="h-3 w-3" />
                Mix
              </button>
            </Tooltip>
          )}
        </div>
      </div>

      {/* Search input */}
      <AnimatePresence>
        {showSearch && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <div className="relative">
              <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-500" />
              <input
                type="text"
                value={searchQuery}
                onChange={e => setSearchQuery(e.target.value)}
                placeholder="Search camera moves..."
                className="w-full rounded-lg border border-white/10 bg-black/50 py-2 pr-8 pl-9 text-sm text-white placeholder:text-gray-500 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute top-1/2 right-2 -translate-y-1/2 rounded p-1 hover:bg-white/10"
                >
                  <X className="h-3 w-3 text-gray-400" />
                </button>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Mix mode preview */}
      <AnimatePresence>
        {mixMode && selectedMixPresets.length > 0 && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="rounded-lg border border-purple-500/20 bg-purple-500/10 p-3"
          >
            <div className="mb-2 flex items-center justify-between">
              <span className="text-xs font-medium text-purple-400">
                Camera Mix ({selectedMixPresets.length}/3)
              </span>
              <button
                onClick={() => onMixSelect?.([])}
                className="text-xs text-gray-400 hover:text-white"
              >
                Clear
              </button>
            </div>
            <div className="mb-2 flex flex-wrap gap-1">
              {selectedMixPresets.map((id, index) => {
                const preset = getPresetById(id);
                return preset ? (
                  <span
                    key={id}
                    className="flex items-center gap-1 rounded bg-purple-500/20 px-2 py-0.5 text-[10px] text-purple-300"
                  >
                    <span className="flex h-3 w-3 items-center justify-center rounded-full bg-purple-500 text-[8px] font-bold text-white">
                      {index + 1}
                    </span>
                    {preset.name}
                    <button
                      onClick={() => onMixSelect?.(selectedMixPresets.filter(p => p !== id))}
                      className="hover:text-white"
                    >
                      <X className="h-2.5 w-2.5" />
                    </button>
                  </span>
                ) : null;
              })}
            </div>
            <p className="text-[10px] text-gray-400 italic">{getMixedPrompt()}</p>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Genre recommendations */}
      {showGenreRecommendations && genreTemplate && !searchQuery && (
        <div className="rounded-lg border border-green-500/20 bg-green-500/10 p-3">
          <div className="mb-2 flex items-center gap-2">
            <Sparkles className="h-3.5 w-3.5 text-green-400" />
            <span className="text-xs font-medium text-green-400">
              Recommended for {genreTemplate.name}
            </span>
          </div>
          <div className="flex flex-wrap gap-1.5">
            {recommendedPresets.slice(0, 6).map(presetId => {
              const preset = getPresetById(presetId);
              return preset ? (
                <button
                  key={presetId}
                  onClick={() => handlePresetClick(preset)}
                  className={clsx(
                    'rounded-full border px-2 py-1 text-[10px] transition-colors',
                    selectedPreset === presetId || selectedMixPresets.includes(presetId)
                      ? 'border-green-500 bg-green-500 text-white'
                      : 'border-green-500/30 bg-green-500/10 text-green-300 hover:bg-green-500/20'
                  )}
                >
                  {preset.name}
                </button>
              ) : null;
            })}
            {recommendedPresets.length > 6 && (
              <span className="px-2 py-1 text-[10px] text-gray-500">
                +{recommendedPresets.length - 6} more
              </span>
            )}
          </div>
        </div>
      )}

      {/* Search results */}
      {searchQuery && filteredPresets && (
        <div className="space-y-2">
          <p className="text-xs text-gray-400">
            {filteredPresets.length} results for "{searchQuery}"
          </p>
          <div className="grid max-h-48 grid-cols-3 gap-1.5 overflow-y-auto">
            {filteredPresets.map(preset => renderPresetButton(preset))}
          </div>
        </div>
      )}

      {/* Category grid */}
      {!searchQuery && (
        <>
          <div className="grid grid-cols-5 gap-1.5">
            {Object.entries(CAMERA_PRESETS).map(([key, category]) => (
              <button
                key={key}
                onClick={() => setActiveCategory(activeCategory === key ? null : key)}
                className={clsx(
                  'rounded-lg border p-2 text-center transition-all',
                  activeCategory === key
                    ? 'border-white/30 bg-white/10 text-white'
                    : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                )}
                title={category.description}
              >
                <span className="block text-base">{category.icon}</span>
                <span className="mt-0.5 block truncate text-[9px]">{category.label}</span>
              </button>
            ))}
          </div>

          {/* Expanded category presets */}
          <AnimatePresence mode="wait">
            {activeCategory && (
              <motion.div
                key={activeCategory}
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="overflow-hidden"
              >
                <div className="rounded-lg border border-white/10 bg-white/5 p-3">
                  <div className="mb-2 flex items-center justify-between">
                    <span className="flex items-center gap-2 text-xs font-medium text-white">
                      <span>{CAMERA_PRESETS[activeCategory].icon}</span>
                      {CAMERA_PRESETS[activeCategory].label}
                    </span>
                    <span className="text-[10px] text-gray-500">
                      {CAMERA_PRESETS[activeCategory].presets.length} presets
                    </span>
                  </div>
                  <p className="mb-3 text-[10px] text-gray-400">
                    {CAMERA_PRESETS[activeCategory].description}
                  </p>
                  <div className="grid grid-cols-3 gap-1.5">
                    {CAMERA_PRESETS[activeCategory].presets.map(preset =>
                      renderPresetButton(preset)
                    )}
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </>
      )}

      {/* Current selection display */}
      {selectedPreset && !mixMode && (
        <div className="flex items-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 p-2">
          <Check className="h-3.5 w-3.5 flex-shrink-0 text-blue-400" />
          <div className="min-w-0 flex-1">
            <p className="truncate text-xs font-medium text-blue-300">
              {getPresetById(selectedPreset)?.name}
            </p>
            <p className="truncate text-[10px] text-gray-400">
              {getPresetById(selectedPreset)?.prompt}
            </p>
          </div>
          <Tooltip content="Clear selection" side="top">
            <button
              onClick={() => onSelect({ id: '', name: '', prompt: '', description: '', genres: [] })}
              className="rounded p-1 text-gray-400 hover:bg-white/10 hover:text-white"
            >
              <X className="h-3 w-3" />
            </button>
          </Tooltip>
        </div>
      )}
    </div>
  );
}

// 
// Compact version for inline use
// 

interface CameraPresetDropdownProps {
  selectedPreset: string | null;
  onSelect: (preset: CameraPreset) => void;
  genre?: Genre | null;
  className?: string;
}

export function CameraPresetDropdown({
  selectedPreset,
  onSelect,
  genre = null,
  className,
}: CameraPresetDropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const selectedPresetData = selectedPreset ? getPresetById(selectedPreset) : null;
  const category = selectedPreset ? getCategoryForPreset(selectedPreset) : null;

  return (
    <div className={clsx('relative', className)}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex w-full items-center justify-between rounded-lg border border-white/10 bg-black/50 px-3 py-2 text-left text-sm transition-colors hover:bg-white/5"
      >
        <span className="flex items-center gap-2">
          {category && <span>{category.icon}</span>}
          <span className={selectedPresetData ? 'text-white' : 'text-gray-500'}>
            {selectedPresetData?.name || 'Select camera move...'}
          </span>
        </span>
        <ChevronDown
          className={clsx('h-4 w-4 text-gray-400 transition-transform', isOpen && 'rotate-180')}
        />
      </button>

      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="absolute top-full right-0 left-0 z-50 mt-1 max-h-80 overflow-y-auto rounded-lg border border-white/10 bg-[#1a1a1a] p-3 shadow-2xl"
          >
            <CameraPresetSelector
              selectedPreset={selectedPreset}
              onSelect={preset => {
                onSelect(preset);
                setIsOpen(false);
              }}
              genre={genre}
              showGenreRecommendations={true}
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/EditElementModal.tsx">
import React, { useState, useEffect } from 'react';
import { X, Save } from 'lucide-react';

interface EditElementModalProps {
  isOpen: boolean;
  onClose: () => void;
  element: any;
  onSave: (id: string, updates: any) => Promise<void>;
  sessions?: any[];
}

export function EditElementModal({
  isOpen,
  onClose,
  element,
  onSave,
  sessions = [],
}: EditElementModalProps) {
  const [name, setName] = useState('');
  const [tags, setTags] = useState<string[]>([]);
  const [sessionId, setSessionId] = useState<string>('');
  const [newTag, setNewTag] = useState('');

  useEffect(() => {
    if (element) {
      setName(element.name || '');
      setTags(element.tags || []);
      setSessionId(element.session?.id || '');
    }
  }, [element]);

  if (!isOpen || !element) return null;

  const handleSave = async () => {
    await onSave(element.id, {
      name,
      tags,
      sessionId: sessionId || null,
    });
    onClose();
  };

  const addTag = () => {
    if (newTag && !tags.includes(newTag)) {
      setTags([...tags, newTag]);
      setNewTag('');
    }
  };

  const removeTag = (tagToRemove: string) => {
    setTags(tags.filter(tag => tag !== tagToRemove));
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
      <div className="w-full max-w-lg overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a]">
        <div className="flex items-center justify-between border-b border-white/10 p-4">
          <h2 className="text-lg font-semibold text-white">Edit Element</h2>
          <button onClick={onClose} className="text-gray-400 transition-colors hover:text-white">
            <X className="h-5 w-5" />
          </button>
        </div>

        <div className="space-y-6 p-6">
          {/* Preview */}
          <div className="flex aspect-video items-center justify-center overflow-hidden rounded-lg border border-white/5 bg-black/50">
            {element.type === 'video' ? (
              <video src={element.url} controls className="max-h-full max-w-full" />
            ) : (
              <img
                src={element.url}
                alt={element.name}
                className="max-h-full max-w-full object-contain"
              />
            )}
          </div>

          {/* Name */}
          <div>
            <label className="mb-2 block text-sm font-medium text-gray-400">Name</label>
            <input
              type="text"
              value={name}
              onChange={e => setName(e.target.value)}
              className="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none"
              placeholder="Element name..."
            />
          </div>

          {/* Session */}
          <div>
            <label className="mb-2 block text-sm font-medium text-gray-400">Session</label>
            <select
              value={sessionId}
              onChange={e => setSessionId(e.target.value)}
              className="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none"
            >
              <option value="">No Session</option>
              {sessions.map((s: any) => (
                <option key={s.id} value={s.id}>
                  {s.name}
                </option>
              ))}
            </select>
          </div>

          {/* Tags */}
          <div>
            <label className="mb-2 block text-sm font-medium text-gray-400">Tags</label>
            <div className="mb-2 flex gap-2">
              <input
                type="text"
                value={newTag}
                onChange={e => setNewTag(e.target.value)}
                onKeyDown={e => e.key === 'Enter' && addTag()}
                className="flex-1 rounded-lg border border-white/10 bg-white/5 px-4 py-2 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none"
                placeholder="Add a tag..."
              />
              <button
                onClick={addTag}
                className="rounded-lg bg-white/10 px-4 py-2 text-white transition-colors hover:bg-white/20"
              >
                Add
              </button>
            </div>
            <div className="flex flex-wrap gap-2">
              {tags.map(tag => (
                <span
                  key={tag}
                  className="flex items-center gap-1 rounded bg-purple-500/20 px-2 py-1 text-sm text-purple-300"
                >
                  {tag}
                  <button onClick={() => removeTag(tag)} className="hover:text-white">
                    <X className="h-3 w-3" />
                  </button>
                </span>
              ))}
            </div>
          </div>
        </div>

        <div className="flex justify-end gap-3 border-t border-white/10 p-4">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-400 transition-colors hover:text-white"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            className="flex items-center gap-2 rounded-lg bg-purple-600 px-6 py-2 font-medium text-white transition-colors hover:bg-purple-700"
          >
            <Save className="h-4 w-4" />
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/FoundationImagePanel.tsx">
'use client';

import { useState, useRef } from 'react';
import { Upload, Sparkles, ImageIcon, X, ChevronDown, Wand2, Copy, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { useDropzone } from 'react-dropzone';

interface FoundationImagePanelProps {
  projectId: string;
  foundationImage: string | File | null;
  onFoundationImageChange: (image: string | File | null) => void;
  onGenerateFromPrompt: (prompt: string) => void;
  styleConfig?: {
    aesthetic?: string;
    lighting?: string;
    colorPalette?: string;
    cameraDirection?: string;
  };
  onStyleConfigChange?: (config: any) => void;
}

// Timeline Prompting structure from Mira AI video
const TIMELINE_COMPONENTS = {
  aesthetic: [
    'Pixar animation style',
    'Cinematic film look',
    'Anime style',
    'Realistic photography',
    'Film noir',
    'Vintage 1970s',
    'Cyberpunk',
    'Studio Ghibli inspired',
    'Sci-fi futuristic',
    'Fantasy epic',
    'Documentary style',
    'Music video aesthetic',
  ],
  lighting: [
    'Dramatic warm and cold contrast',
    'Golden hour',
    'Neon lights',
    'Natural daylight',
    'Moody low-key',
    'High-key bright',
    'Rim lighting',
    'Volumetric fog',
    'Sunset silhouette',
    'Studio lighting',
    'Candlelight',
    'Moonlight',
  ],
  colorPalette: [
    'Warm oranges and teals',
    'Muted earth tones',
    'Vibrant saturated',
    'Desaturated cinematic',
    'Pastel soft',
    'High contrast B&W',
    'Neon pink and blue',
    'Sepia vintage',
    'Cool blue undertones',
    'Autumnal reds and browns',
  ],
  cameraDirection: [
    'Slow dolly forward',
    'Static establishing shot',
    'Handheld following',
    'Crane shot upward',
    'Tracking side shot',
    'Push in dramatic',
    'Pull back reveal',
    'Pan left to right',
    'Orbit around subject',
    'Steadicam smooth',
  ],
};

export function FoundationImagePanel({
  projectId,
  foundationImage,
  onFoundationImageChange,
  onGenerateFromPrompt,
  styleConfig = {},
  onStyleConfigChange,
}: FoundationImagePanelProps) {
  const [isExpanded, setIsExpanded] = useState(true);
  const [generationPrompt, setGenerationPrompt] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [activeDropdown, setActiveDropdown] = useState<string | null>(null);
  const [copiedPrompt, setCopiedPrompt] = useState(false);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: files => {
      if (files.length > 0) {
        onFoundationImageChange(files[0]);
      }
    },
    accept: { 'image/*': [] },
    maxFiles: 1,
  });

  // Build Timeline Prompt from components
  const buildTimelinePrompt = () => {
    const parts = [];
    if (styleConfig.aesthetic) parts.push(styleConfig.aesthetic);
    if (styleConfig.lighting) parts.push(styleConfig.lighting);
    if (styleConfig.colorPalette) parts.push(styleConfig.colorPalette);
    if (styleConfig.cameraDirection) parts.push(styleConfig.cameraDirection);
    return parts.join(', ');
  };

  const handleCopyPrompt = () => {
    const prompt = buildTimelinePrompt();
    if (prompt) {
      navigator.clipboard.writeText(prompt);
      setCopiedPrompt(true);
      setTimeout(() => setCopiedPrompt(false), 2000);
    }
  };

  const handleGenerate = async () => {
    if (!generationPrompt.trim()) return;
    setIsGenerating(true);
    try {
      // Combine user prompt with Timeline Prompt structure
      const timelineAddition = buildTimelinePrompt();
      const fullPrompt = timelineAddition
        ? `${generationPrompt}. ${timelineAddition}`
        : generationPrompt;
      await onGenerateFromPrompt(fullPrompt);
    } finally {
      setIsGenerating(false);
    }
  };

  const updateStyleConfig = (key: string, value: string) => {
    onStyleConfigChange?.({
      ...styleConfig,
      [key]: value,
    });
    setActiveDropdown(null);
  };

  const previewUrl = foundationImage
    ? typeof foundationImage === 'string'
      ? foundationImage
      : URL.createObjectURL(foundationImage as any)
    : null;

  return (
    <div className="overflow-hidden rounded-xl border border-purple-500/20 bg-gradient-to-b from-purple-900/20 to-transparent">
      {/* Header */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="flex w-full items-center justify-between px-4 py-3 transition-colors hover:bg-white/5"
      >
        <div className="flex items-center gap-3">
          <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-purple-500/20">
            <ImageIcon className="h-4 w-4 text-purple-400" />
          </div>
          <div className="text-left">
            <h3 className="text-sm font-semibold text-white">Foundation Image</h3>
            <p className="text-[10px] text-gray-500">Master aesthetic reference for all scenes</p>
          </div>
        </div>
        <ChevronDown
          className={clsx('h-4 w-4 text-gray-400 transition-transform', isExpanded && 'rotate-180')}
        />
      </button>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            className="overflow-hidden"
          >
            <div className="space-y-4 px-4 pb-4">
              {/* Foundation Image Upload/Preview */}
              <div className="flex gap-4">
                {/* Image Area */}
                <div
                  {...getRootProps()}
                  className={clsx(
                    'relative aspect-video w-40 cursor-pointer overflow-hidden rounded-lg border-2 border-dashed transition-colors',
                    isDragActive
                      ? 'border-purple-500 bg-purple-500/10'
                      : 'border-white/20 hover:border-purple-500/50',
                    previewUrl && 'border-solid border-purple-500/30'
                  )}
                >
                  <input {...getInputProps()} />
                  {previewUrl ? (
                    <>
                      <img
                        src={previewUrl}
                        alt="Foundation"
                        className="h-full w-full object-cover"
                      />
                      <div className="absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 transition-opacity hover:opacity-100">
                        <Upload className="h-5 w-5 text-white" />
                      </div>
                      <button
                        onClick={e => {
                          e.stopPropagation();
                          onFoundationImageChange(null);
                        }}
                        className="absolute top-1 right-1 rounded bg-black/60 p-1 text-white transition-colors hover:bg-red-500"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </>
                  ) : (
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                      <Upload className="mb-1 h-6 w-6" />
                      <span className="text-[10px]">Drop or click</span>
                    </div>
                  )}
                </div>

                {/* Quick Generate */}
                <div className="flex-1 space-y-2">
                  <textarea
                    value={generationPrompt}
                    onChange={e => setGenerationPrompt(e.target.value)}
                    placeholder="Describe your foundation aesthetic... (e.g., 'Space knight in weathered armor, cinematic sci-fi')"
                    className="h-16 w-full resize-none rounded-lg border border-white/10 bg-black/30 p-2 text-xs text-white placeholder-gray-600 focus:border-purple-500/50 focus:outline-none"
                  />
                  <button
                    onClick={handleGenerate}
                    disabled={isGenerating || !generationPrompt.trim()}
                    className="flex w-full items-center justify-center gap-2 rounded-lg border border-purple-500/20 bg-purple-600/20 px-3 py-1.5 text-xs font-medium text-purple-400 transition-colors hover:bg-purple-600/30 disabled:opacity-50"
                  >
                    <Sparkles className="h-3 w-3" />
                    {isGenerating ? 'Generating...' : 'Generate Foundation'}
                  </button>
                </div>
              </div>

              {/* Timeline Prompting Structure */}
              <div className="border-t border-white/5 pt-4">
                <div className="mb-3 flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Wand2 className="h-3 w-3 text-purple-400" />
                    <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                      Timeline Prompt Structure
                    </span>
                  </div>
                  <button
                    onClick={handleCopyPrompt}
                    className="flex items-center gap-1 text-[10px] text-gray-500 transition-colors hover:text-purple-400"
                  >
                    {copiedPrompt ? <Check className="h-3 w-3" /> : <Copy className="h-3 w-3" />}
                    {copiedPrompt ? 'Copied!' : 'Copy'}
                  </button>
                </div>

                <div className="grid grid-cols-2 gap-2">
                  {Object.entries(TIMELINE_COMPONENTS).map(([key, options]) => (
                    <div key={key} className="relative">
                      <button
                        onClick={() => setActiveDropdown(activeDropdown === key ? null : key)}
                        className={clsx(
                          'flex w-full items-center justify-between rounded border bg-white/5 px-2 py-1.5 text-xs transition-colors hover:bg-white/10',
                          (styleConfig as any)[key]
                            ? 'border-purple-500/30 text-purple-300'
                            : 'border-white/10 text-gray-400'
                        )}
                      >
                        <span className="truncate">
                          {(styleConfig as any)[key] || key.replace(/([A-Z])/g, ' $1').trim()}
                        </span>
                        <ChevronDown className="ml-1 h-3 w-3 flex-shrink-0" />
                      </button>

                      <AnimatePresence>
                        {activeDropdown === key && (
                          <motion.div
                            initial={{ opacity: 0, y: -5 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -5 }}
                            className="absolute top-full right-0 left-0 z-50 mt-1 max-h-40 overflow-y-auto rounded-lg border border-white/20 bg-[#1a1a1a] shadow-xl"
                          >
                            <button
                              onClick={() => updateStyleConfig(key, '')}
                              className="w-full px-2 py-1.5 text-left text-xs text-gray-500 transition-colors hover:bg-white/5"
                            >
                              Clear
                            </button>
                            {options.map(option => (
                              <button
                                key={option}
                                onClick={() => updateStyleConfig(key, option)}
                                className={clsx(
                                  'w-full px-2 py-1.5 text-left text-xs transition-colors',
                                  (styleConfig as any)[key] === option
                                    ? 'bg-purple-500/20 text-purple-300'
                                    : 'text-gray-300 hover:bg-white/5'
                                )}
                              >
                                {option}
                              </button>
                            ))}
                          </motion.div>
                        )}
                      </AnimatePresence>
                    </div>
                  ))}
                </div>

                {/* Preview of built prompt */}
                {buildTimelinePrompt() && (
                  <div className="mt-3 rounded border border-purple-500/10 bg-black/30 p-2">
                    <p className="text-[10px] leading-relaxed text-purple-300/70">
                      {buildTimelinePrompt()}
                    </p>
                  </div>
                )}
              </div>

              {/* Usage Tip */}
              <div className="rounded-lg border border-purple-500/10 bg-purple-500/5 p-3">
                <p className="text-[10px] leading-relaxed text-purple-300/80">
                  <strong>Tip:</strong> Your foundation image sets the visual DNA for your entire
                  project. All scene images will reference this aesthetic. Use the Timeline Prompt
                  structure (Aesthetic + Lighting + Color + Camera) for consistent results.
                </p>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/SceneGeneratorModal.tsx">
'use client';

import { useState } from 'react';
import { X, Sparkles, Loader2 } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';

interface SceneGeneratorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onGenerate: (config: SceneGenerationConfig) => void;
  sceneName: string;
}

export interface SceneGenerationConfig {
  prompt: string;
  shotTypes: string[];
  cameraAngles: string[];
  location: string;
  lighting: string;
  resolution: '1080p' | '1440p' | '4k';
  aspectRatio: '16:9' | '9:16' | '1:1' | '2.35:1';
  variations: number;
  mode: 'text_to_video' | 'image_to_video' | 'frames_to_video' | 'extend_video';
  startFrame?: File | null;
  endFrame?: File | null;
  inputVideo?: File | null;
  cameraMovement?: { type: string; direction?: string; intensity?: number };
}

const GENERATION_MODES = [
  { id: 'text_to_video', label: 'Text to Video', icon: '' },
  { id: 'image_to_video', label: 'Image to Video', icon: '' },
  { id: 'frames_to_video', label: 'Frames to Video', icon: '' },
  { id: 'extend_video', label: 'Extend Video', icon: '' },
];

const SHOT_TYPES = [
  'Close-up',
  'Medium Shot',
  'Wide Shot',
  'Extreme Wide Shot',
  'Macro',
  'Over the Shoulder',
];
const CAMERA_ANGLES = [
  'Eye Level',
  'Low Angle',
  'High Angle',
  "Bird's Eye",
  'Dutch Angle',
  "Worm's Eye",
];
const RESOLUTIONS = ['1080p', '1440p', '4k'];
const ASPECT_RATIOS = ['16:9', '9:16', '1:1', '2.35:1'];

export function SceneGeneratorModal({
  isOpen,
  onClose,
  onGenerate,
  sceneName,
}: SceneGeneratorModalProps) {
  const [config, setConfig] = useState<SceneGenerationConfig>({
    prompt: '',
    shotTypes: [],
    cameraAngles: [],
    location: '',
    lighting: '',
    resolution: '1080p',
    aspectRatio: '16:9',
    variations: 1,
    mode: 'text_to_video',
    startFrame: null,
    endFrame: null,
    inputVideo: null,
  });

  const [isGenerating, setIsGenerating] = useState(false);

  const handleGenerate = () => {
    setIsGenerating(true);
    // Simulate generation delay for now or just pass config
    onGenerate(config);
    setIsGenerating(false);
    onClose();
  };

  const handleFileChange = (field: 'startFrame' | 'endFrame' | 'inputVideo', file: File | null) => {
    setConfig(prev => ({ ...prev, [field]: file }));
  };

  const toggleSelection = (field: 'shotTypes' | 'cameraAngles', value: string) => {
    setConfig(prev => {
      const current = prev[field];
      const updated = current.includes(value)
        ? current.filter(item => item !== value)
        : [...current, value];
      return { ...prev, [field]: updated };
    });
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div
          className="fixed inset-0 z-[100] flex items-center justify-center bg-black/90 p-4 backdrop-blur-md"
          onClick={onClose}
        >
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            className="relative flex max-h-[90vh] w-full max-w-2xl flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
            onClick={e => e.stopPropagation()}
          >
            {/* Header */}
            <div className="flex items-center justify-between border-b border-white/10 bg-white/5 p-6">
              <div>
                <h2 className="text-xl font-bold text-white">Generate Scene</h2>
                <p className="text-sm text-gray-400">Configure generation for "{sceneName}"</p>
              </div>
              <button
                onClick={onClose}
                className="rounded-full bg-white/5 p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            {/* Content */}
            <div className="flex-1 space-y-6 overflow-y-auto p-6">
              {/* Mode Selector */}
              <div className="flex rounded-lg border border-white/10 bg-black/30 p-1">
                {GENERATION_MODES.map(mode => (
                  <button
                    key={mode.id}
                    onClick={() => setConfig({ ...config, mode: mode.id as any })}
                    className={clsx(
                      'flex flex-1 items-center justify-center gap-2 rounded-md py-2 text-sm font-medium transition-all',
                      config.mode === mode.id
                        ? 'bg-blue-600 text-white shadow-lg'
                        : 'text-gray-400 hover:bg-white/5 hover:text-white'
                    )}
                  >
                    <span>{mode.icon}</span>
                    {mode.label}
                  </button>
                ))}
              </div>

              {/* Mode Specific Inputs */}
              {config.mode === 'image_to_video' && (
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">
                    Start Image
                  </label>
                  <input
                    type="file"
                    accept="image/*"
                    onChange={e => handleFileChange('startFrame', e.target.files?.[0] || null)}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-sm text-white file:mr-4 file:rounded-full file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-sm file:font-semibold file:text-white hover:file:bg-blue-500"
                  />
                </div>
              )}

              {config.mode === 'frames_to_video' && (
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="mb-2 block text-sm font-medium text-gray-400">
                      Start Frame
                    </label>
                    <input
                      type="file"
                      accept="image/*"
                      onChange={e => handleFileChange('startFrame', e.target.files?.[0] || null)}
                      className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-sm text-white file:mr-4 file:rounded-full file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-sm file:font-semibold file:text-white hover:file:bg-blue-500"
                    />
                  </div>
                  <div>
                    <label className="mb-2 block text-sm font-medium text-gray-400">
                      End Frame
                    </label>
                    <input
                      type="file"
                      accept="image/*"
                      onChange={e => handleFileChange('endFrame', e.target.files?.[0] || null)}
                      className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-sm text-white file:mr-4 file:rounded-full file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-sm file:font-semibold file:text-white hover:file:bg-blue-500"
                    />
                  </div>
                </div>
              )}

              {config.mode === 'extend_video' && (
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">
                    Input Video
                  </label>
                  <input
                    type="file"
                    accept="video/*"
                    onChange={e => handleFileChange('inputVideo', e.target.files?.[0] || null)}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-sm text-white file:mr-4 file:rounded-full file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-sm file:font-semibold file:text-white hover:file:bg-blue-500"
                  />
                </div>
              )}
              {/* Prompt */}
              <div>
                <label className="mb-2 block text-sm font-medium text-gray-400">Scene Prompt</label>
                <textarea
                  value={config.prompt}
                  onChange={e => setConfig({ ...config, prompt: e.target.value })}
                  className="h-32 w-full resize-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  placeholder="Describe the scene in detail..."
                />
              </div>

              {/* Shot Types & Camera Angles */}
              <div className="grid grid-cols-2 gap-6">
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">Shot Types</label>
                  <div className="flex flex-wrap gap-2">
                    {SHOT_TYPES.map(type => (
                      <button
                        key={type}
                        onClick={() => toggleSelection('shotTypes', type)}
                        className={clsx(
                          'rounded-lg border px-3 py-1.5 text-xs font-medium transition-colors',
                          config.shotTypes.includes(type)
                            ? 'border-blue-500 bg-blue-600 text-white'
                            : 'border-white/10 bg-black/30 text-gray-400 hover:bg-white/5'
                        )}
                      >
                        {type}
                      </button>
                    ))}
                  </div>
                </div>
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">
                    Camera Angles
                  </label>
                  <div className="flex flex-wrap gap-2">
                    {CAMERA_ANGLES.map(angle => (
                      <button
                        key={angle}
                        onClick={() => toggleSelection('cameraAngles', angle)}
                        className={clsx(
                          'rounded-lg border px-3 py-1.5 text-xs font-medium transition-colors',
                          config.cameraAngles.includes(angle)
                            ? 'border-blue-500 bg-blue-600 text-white'
                            : 'border-white/10 bg-black/30 text-gray-400 hover:bg-white/5'
                        )}
                      >
                        {angle}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {/* Location & Lighting */}
              <div className="grid grid-cols-2 gap-6">
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">Location</label>
                  <input
                    type="text"
                    value={config.location}
                    onChange={e => setConfig({ ...config, location: e.target.value })}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    placeholder="e.g. Cyberpunk City Street"
                  />
                </div>
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">Lighting</label>
                  <input
                    type="text"
                    value={config.lighting}
                    onChange={e => setConfig({ ...config, lighting: e.target.value })}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    placeholder="e.g. Neon, Golden Hour"
                  />
                </div>
              </div>

              {/* Technical Settings */}
              <div className="grid grid-cols-3 gap-6">
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">Resolution</label>
                  <select
                    value={config.resolution}
                    onChange={e => setConfig({ ...config, resolution: e.target.value as any })}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  >
                    {RESOLUTIONS.map(res => (
                      <option key={res} value={res}>
                        {res}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">
                    Aspect Ratio
                  </label>
                  <select
                    value={config.aspectRatio}
                    onChange={e => setConfig({ ...config, aspectRatio: e.target.value as any })}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  >
                    {ASPECT_RATIOS.map(ratio => (
                      <option key={ratio} value={ratio}>
                        {ratio}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">Variations</label>
                  <input
                    type="number"
                    min="1"
                    max="4"
                    value={config.variations}
                    onChange={e => setConfig({ ...config, variations: parseInt(e.target.value) })}
                    className="w-full rounded-lg border border-white/10 bg-black/50 p-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  />
                </div>
              </div>
            </div>

            {/* Footer */}
            <div className="flex justify-end gap-3 border-t border-white/10 bg-white/5 p-6">
              <button
                onClick={onClose}
                className="rounded-lg bg-white/10 px-4 py-2 text-white transition-colors hover:bg-white/20"
              >
                Cancel
              </button>
              <button
                onClick={handleGenerate}
                disabled={isGenerating || !config.prompt.trim()}
                className="flex items-center gap-2 rounded-lg bg-blue-600 px-6 py-2 font-medium text-white shadow-lg shadow-blue-600/20 hover:bg-blue-500 disabled:cursor-not-allowed disabled:opacity-50"
              >
                {isGenerating ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Sparkles className="h-4 w-4" />
                )}
                Generate Scene
              </button>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="frontend/src/components/storyboard/ShotActionsPanel.tsx">
'use client';

import { useState } from 'react';
import {
  FastForward,
  ImageIcon,
  Palette,
  Cloud,
  Sun,
  Moon,
  Snowflake,
  Droplets,
  Wind,
  Camera,
  RotateCcw,
  ArrowRight,
  ArrowLeft,
  Wand2,
  Copy,
  Check,
  X,
  Film,
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { CameraPresetSelector } from './CameraPresetSelector';
import { CameraPreset, getPresetById } from '@/data/CameraPresets';
import { Genre } from '@/data/GenreTemplates';

interface ShotActionsPanelProps {
  shot: any;
  onGrabLastFrame: (shotId: string) => void;
  onGrabFirstFrame: (shotId: string) => void;
  onV2VEdit: (shotId: string, editType: string, prompt: string) => void;
  onPredictNextShot: (shotId: string, prompt: string) => void;
  onPredictPreviousShot: (shotId: string, prompt: string) => void;
  isProcessing?: boolean;
  genre?: Genre | null; // Current project/scene genre for camera recommendations
  onCameraPresetSelect?: (preset: CameraPreset) => void;
}

const WEATHER_PRESETS = [
  { id: 'sunny', label: 'Sunny', icon: Sun, prompt: 'bright sunny day, clear blue sky' },
  { id: 'night', label: 'Night', icon: Moon, prompt: 'nighttime, dark sky with stars, moonlight' },
  { id: 'rain', label: 'Rainy', icon: Droplets, prompt: 'heavy rain, wet surfaces, rain drops' },
  { id: 'snow', label: 'Snowy', icon: Snowflake, prompt: 'snowfall, snow covered ground, winter' },
  { id: 'fog', label: 'Foggy', icon: Cloud, prompt: 'thick fog, misty atmosphere, low visibility' },
  { id: 'storm', label: 'Stormy', icon: Wind, prompt: 'thunderstorm, dark clouds, lightning' },
];

export function ShotActionsPanel({
  shot,
  onGrabLastFrame,
  onGrabFirstFrame,
  onV2VEdit,
  onPredictNextShot,
  onPredictPreviousShot,
  isProcessing = false,
  genre = null,
  onCameraPresetSelect,
}: ShotActionsPanelProps) {
  const [activeTab, setActiveTab] = useState<'extend' | 'edit' | 'camera' | 'predict'>('extend');
  const [customPrompt, setCustomPrompt] = useState('');
  const [selectedWeather, setSelectedWeather] = useState<string | null>(null);
  const [selectedCameraPreset, setSelectedCameraPreset] = useState<string | null>(null);
  const [selectedMixPresets, setSelectedMixPresets] = useState<string[]>([]);
  const [backgroundPrompt, setBackgroundPrompt] = useState('');

  const handleWeatherChange = (weather: (typeof WEATHER_PRESETS)[0]) => {
    setSelectedWeather(weather.id);
    onV2VEdit(shot.id, 'weather', `Change the weather to ${weather.prompt}`);
  };

  const handleCameraPresetSelect = (preset: CameraPreset) => {
    if (!preset.id) {
      // Clear selection
      setSelectedCameraPreset(null);
      return;
    }
    setSelectedCameraPreset(preset.id);
    onV2VEdit(shot.id, 'camera', `Change the camera to ${preset.prompt}`);
    onCameraPresetSelect?.(preset);
  };

  const handleMixedCameraSelect = (presetIds: string[]) => {
    setSelectedMixPresets(presetIds);
    if (presetIds.length > 0) {
      const combinedPrompt = presetIds
        .map(id => getPresetById(id)?.prompt)
        .filter(Boolean)
        .join(', ');
      onV2VEdit(shot.id, 'camera', `Camera movement: ${combinedPrompt}`);
    }
  };

  const handleBackgroundChange = () => {
    if (!backgroundPrompt.trim()) return;
    onV2VEdit(shot.id, 'background', `Change the background to ${backgroundPrompt}`);
    setBackgroundPrompt('');
  };

  return (
    <div className="overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a]">
      {/* Tabs */}
      <div className="flex border-b border-white/10">
        {[
          { id: 'extend', label: 'Extend', icon: FastForward },
          { id: 'camera', label: 'Camera', icon: Film },
          { id: 'edit', label: 'V2V Edit', icon: Palette },
          { id: 'predict', label: 'Next/Prev', icon: Camera },
        ].map(tab => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id as any)}
            className={clsx(
              'flex flex-1 items-center justify-center gap-2 px-3 py-2.5 text-xs font-medium transition-colors',
              activeTab === tab.id
                ? 'border-b-2 border-blue-500 bg-blue-600/20 text-blue-400'
                : 'text-gray-400 hover:bg-white/5 hover:text-white'
            )}
          >
            <tab.icon className="h-3.5 w-3.5" />
            {tab.label}
          </button>
        ))}
      </div>

      <div className="p-4">
        <AnimatePresence mode="wait">
          {/* Extend Tab - Grab Last Frame */}
          {activeTab === 'extend' && (
            <motion.div
              key="extend"
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="space-y-4"
            >
              <div className="space-y-2 text-center">
                <p className="text-xs text-gray-400">
                  Create seamless extensions by using the last frame as the next starting point
                </p>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={() => onGrabFirstFrame(shot.id)}
                  disabled={isProcessing}
                  className="flex flex-col items-center gap-2 rounded-lg border border-white/10 bg-white/5 p-4 transition-colors hover:bg-white/10 disabled:opacity-50"
                >
                  <div className="flex h-10 w-10 items-center justify-center rounded-full bg-orange-500/20">
                    <ArrowLeft className="h-5 w-5 text-orange-400" />
                  </div>
                  <span className="text-xs font-medium text-white">Grab First Frame</span>
                  <span className="text-[10px] text-gray-500">Use as end frame</span>
                </button>

                <button
                  onClick={() => onGrabLastFrame(shot.id)}
                  disabled={isProcessing}
                  className="flex flex-col items-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 p-4 transition-colors hover:bg-blue-500/20 disabled:opacity-50"
                >
                  <div className="flex h-10 w-10 items-center justify-center rounded-full bg-blue-500/20">
                    <ArrowRight className="h-5 w-5 text-blue-400" />
                  </div>
                  <span className="text-xs font-medium text-white">Grab Last Frame</span>
                  <span className="text-[10px] text-gray-500">Use as next start</span>
                </button>
              </div>

              <div className="rounded-lg border border-blue-500/10 bg-blue-500/5 p-3">
                <p className="text-[10px] leading-relaxed text-blue-300/80">
                  <strong>Pro Tip:</strong> "Grab Last Frame" creates seamless transitions. Use it
                  repeatedly to build long, consistent animations without cuts.
                </p>
              </div>
            </motion.div>
          )}

          {/* Camera Tab - 50+ Presets */}
          {activeTab === 'camera' && (
            <motion.div
              key="camera"
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="space-y-4"
            >
              <CameraPresetSelector
                selectedPreset={selectedCameraPreset}
                onSelect={handleCameraPresetSelect}
                genre={genre}
                showGenreRecommendations={!!genre}
                allowMixing={true}
                selectedMixPresets={selectedMixPresets}
                onMixSelect={handleMixedCameraSelect}
              />

              <div className="rounded-lg border border-blue-500/10 bg-blue-500/5 p-3">
                <p className="text-[10px] leading-relaxed text-blue-300/80">
                  <strong>Pro Tip:</strong> Use "Mix" mode to combine up to 3 camera movements for
                  complex shots (e.g., Dolly In + Arc Left + Crane Up).
                  {genre && (
                    <span className="mt-1 block">
                      Green dots indicate moves recommended for your {genre.replace('_', ' ')}{' '}
                      project.
                    </span>
                  )}
                </p>
              </div>
            </motion.div>
          )}

          {/* V2V Edit Tab */}
          {activeTab === 'edit' && (
            <motion.div
              key="edit"
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="space-y-4"
            >
              {/* Weather Changes */}
              <div>
                <div className="mb-2 flex items-center gap-2">
                  <Cloud className="h-3 w-3 text-gray-400" />
                  <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                    Weather / Time of Day
                  </span>
                </div>
                <div className="grid grid-cols-3 gap-2">
                  {WEATHER_PRESETS.map(weather => (
                    <button
                      key={weather.id}
                      onClick={() => handleWeatherChange(weather)}
                      disabled={isProcessing}
                      className={clsx(
                        'flex flex-col items-center gap-1 rounded-lg border p-2 transition-colors disabled:opacity-50',
                        selectedWeather === weather.id
                          ? 'border-blue-500/50 bg-blue-500/20 text-blue-300'
                          : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                      )}
                    >
                      <weather.icon className="h-4 w-4" />
                      <span className="text-[10px]">{weather.label}</span>
                    </button>
                  ))}
                </div>
              </div>

              {/* Background Change */}
              <div>
                <div className="mb-2 flex items-center gap-2">
                  <ImageIcon className="h-3 w-3 text-gray-400" />
                  <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                    Change Background
                  </span>
                </div>
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={backgroundPrompt}
                    onChange={e => setBackgroundPrompt(e.target.value)}
                    placeholder="e.g., frozen tundra, neon city, jungle..."
                    className="flex-1 rounded-lg border border-white/10 bg-black/30 px-3 py-2 text-xs text-white placeholder-gray-600 focus:border-blue-500/50 focus:outline-none"
                  />
                  <button
                    onClick={handleBackgroundChange}
                    disabled={isProcessing || !backgroundPrompt.trim()}
                    className="rounded-lg bg-green-600/20 px-3 py-2 text-xs font-medium text-green-400 transition-colors hover:bg-green-600/30 disabled:opacity-50"
                  >
                    Apply
                  </button>
                </div>
              </div>

              {/* Custom V2V Prompt */}
              <div>
                <div className="mb-2 flex items-center gap-2">
                  <Wand2 className="h-3 w-3 text-gray-400" />
                  <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                    Custom Edit
                  </span>
                </div>
                <textarea
                  value={customPrompt}
                  onChange={e => setCustomPrompt(e.target.value)}
                  placeholder="Describe any edit... (e.g., 'change the car to a red Porsche', 'add falling leaves')"
                  className="h-16 w-full resize-none rounded-lg border border-white/10 bg-black/30 p-2 text-xs text-white placeholder-gray-600 focus:border-blue-500/50 focus:outline-none"
                />
                <button
                  onClick={() => {
                    if (customPrompt.trim()) {
                      onV2VEdit(shot.id, 'custom', customPrompt);
                      setCustomPrompt('');
                    }
                  }}
                  disabled={isProcessing || !customPrompt.trim()}
                  className="mt-2 w-full rounded-lg bg-purple-600/20 px-3 py-2 text-xs font-medium text-purple-400 transition-colors hover:bg-purple-600/30 disabled:opacity-50"
                >
                  Apply V2V Edit
                </button>
              </div>
            </motion.div>
          )}

          {/* Predict Next/Previous Tab */}
          {activeTab === 'predict' && (
            <motion.div
              key="predict"
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="space-y-4"
            >
              <div className="space-y-2 text-center">
                <p className="text-xs text-gray-400">
                  Let AI predict what happens next or what came before this shot
                </p>
              </div>

              <textarea
                value={customPrompt}
                onChange={e => setCustomPrompt(e.target.value)}
                placeholder="Describe the next/previous scene... (e.g., 'the character turns around', 'close-up of their face')"
                className="h-20 w-full resize-none rounded-lg border border-white/10 bg-black/30 p-3 text-xs text-white placeholder-gray-600 focus:border-blue-500/50 focus:outline-none"
              />

              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={() => onPredictPreviousShot(shot.id, customPrompt)}
                  disabled={isProcessing}
                  className="flex items-center justify-center gap-2 rounded-lg border border-orange-500/20 bg-orange-500/10 p-3 text-xs font-medium text-orange-400 transition-colors hover:bg-orange-500/20 disabled:opacity-50"
                >
                  <RotateCcw className="h-4 w-4" />
                  Previous Shot
                </button>

                <button
                  onClick={() => onPredictNextShot(shot.id, customPrompt)}
                  disabled={isProcessing}
                  className="flex items-center justify-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 p-3 text-xs font-medium text-blue-400 transition-colors hover:bg-blue-500/20 disabled:opacity-50"
                >
                  <ArrowRight className="h-4 w-4" />
                  Next Shot
                </button>
              </div>

              <div className="rounded-lg border border-orange-500/10 bg-orange-500/5 p-3">
                <p className="text-[10px] leading-relaxed text-orange-300/80">
                  <strong>Note:</strong> Next/Previous shot prediction works best with clear
                  prompts. Reference elements with @Image1, @Image2 syntax for Kling O1.
                </p>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/TimelineView.tsx">
import React, { useState } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  horizontalListSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { Plus, GripVertical, Wand2, Play, MoreVertical } from 'lucide-react';
import { fetchAPI } from '@/lib/api';
import { Tooltip } from '@/components/ui/Tooltip';

interface TimelineViewProps {
  scenes: any[];
  projectId: string;
  onUpdate: () => void;
}

export function TimelineView({ scenes, projectId, onUpdate }: TimelineViewProps) {
  // Flatten shots for the timeline, but keep track of their scene
  const allShots = scenes.flatMap(scene =>
    (scene.shots || []).map((shot: any) => ({
      ...shot,
      sceneId: scene.id,
      sceneName: scene.name,
    }))
  );

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;
    if (!over || active.id === over.id) return;

    // In a real implementation, we would calculate the new order and update the backend.
    // For this MVP, we'll just log it as reordering across scenes is complex.
    console.log('Reordered:', active.id, 'over', over.id);

    // TODO: Implement backend reordering logic
  };

  const handleBridge = async (index: number) => {
    const prevShot = allShots[index];
    const nextShot = allShots[index + 1];

    if (!prevShot || !nextShot) return;

    const prompt = window.prompt('Describe the transition between these two shots:');
    if (!prompt) return;

    try {
      // Use Kling o1 for bridging
      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode: 'video_generation',
          model: 'kling-o1-ref', // Use Kling o1
          inputPrompt: prompt,
          sourceImages: [prevShot.generation.outputs[0].url], // Use prev shot as reference
          // We could also pass nextShot as a second reference if the API supports it
          aspectRatio: '16:9',
        }),
      });

      alert('Generating bridge shot! It will appear shortly.');
      onUpdate();
    } catch (err) {
      console.error('Failed to bridge shots', err);
      alert('Failed to generate bridge shot');
    }
  };

  return (
    <div className="w-full overflow-x-auto pb-8">
      <div className="min-w-max px-8">
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
          <SortableContext items={allShots.map(s => s.id)} strategy={horizontalListSortingStrategy}>
            <div className="flex items-center gap-4">
              {allShots.map((shot, index) => (
                <React.Fragment key={shot.id}>
                  <SortableShot shot={shot} />

                  {/* Bridge Button (between shots) */}
                  {index < allShots.length - 1 && (
                    <Tooltip content="Generate Bridge (Transition)" side="top">
                      <button
                        onClick={() => handleBridge(index)}
                        className="group relative flex h-8 w-8 items-center justify-center rounded-full bg-white/5 transition-all hover:bg-purple-500/20"
                      >
                        <div className="absolute inset-0 scale-0 rounded-full bg-purple-500/20 transition-transform group-hover:scale-100" />
                        <Wand2 className="relative z-10 h-4 w-4 text-gray-500 group-hover:text-purple-400" />
                      </button>
                    </Tooltip>
                  )}
                </React.Fragment>
              ))}

              {/* Add New Shot Button at the end */}
              <button className="flex h-36 w-64 flex-col items-center justify-center rounded-xl border-2 border-dashed border-white/10 text-gray-500 transition-all hover:border-purple-500/50 hover:bg-purple-500/5 hover:text-purple-400">
                <Plus className="mb-2 h-8 w-8" />
                <span>Add Shot</span>
              </button>
            </div>
          </SortableContext>
        </DndContext>
      </div>
    </div>
  );
}

function SortableShot({ shot }: { shot: any }) {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
    id: shot.id,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div ref={setNodeRef} style={style} className="group relative w-64 flex-shrink-0">
      {/* Scene Label */}
      <div className="absolute -top-8 left-0 max-w-full truncate font-mono text-xs text-gray-500">
        {shot.sceneName}
      </div>

      <div className="relative aspect-video overflow-hidden rounded-xl border border-white/10 bg-black transition-colors group-hover:border-purple-500/50">
        {shot.generation?.outputs?.[0]?.url ? (
          shot.generation.outputs[0].type === 'video' ||
          shot.generation.outputs[0].url.endsWith('.mp4') ? (
            <video
              src={shot.generation.outputs[0].url}
              className="h-full w-full object-cover"
              muted
              loop
              onMouseOver={e => e.currentTarget.play()}
              onMouseOut={e => e.currentTarget.pause()}
            />
          ) : (
            <img
              src={shot.generation.outputs[0].url}
              alt={shot.generation.inputPrompt}
              className="h-full w-full object-cover"
            />
          )
        ) : (
          <div className="flex h-full w-full items-center justify-center bg-white/5">
            <span className="text-xs text-gray-500">Processing...</span>
          </div>
        )}

        {/* Drag Handle */}
        <div
          {...attributes}
          {...listeners}
          className="absolute top-2 left-2 cursor-grab rounded-lg bg-black/50 p-1.5 opacity-0 transition-opacity group-hover:opacity-100 active:cursor-grabbing"
        >
          <GripVertical className="h-4 w-4 text-white" />
        </div>

        {/* Controls */}
        <div className="absolute right-0 bottom-0 left-0 flex items-end justify-between bg-gradient-to-t from-black/80 to-transparent p-3 opacity-0 transition-opacity group-hover:opacity-100">
          <span className="mr-2 line-clamp-1 flex-1 text-xs text-white/80">
            {shot.generation?.inputPrompt}
          </span>
          <button className="rounded p-1 hover:bg-white/20">
            <MoreVertical className="h-4 w-4 text-white" />
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/AnimateModal.tsx">
import { useState, useEffect } from 'react';
import { X, Sparkles, Loader2, Video } from 'lucide-react';
import { MagicPromptButton } from './MagicPromptButton';
import { clsx } from 'clsx';

interface AnimateModalProps {
  isOpen: boolean;
  onClose: () => void;
  imageUrl: string;
  initialAspectRatio?: string;
  initialPrompt?: string;
  onAnimate: (prompt: string, aspectRatio: string, duration: number) => void;
  isGenerating: boolean;
}

export function AnimateModal({
  isOpen,
  onClose,
  imageUrl,
  initialAspectRatio,
  initialPrompt,
  onAnimate,
  isGenerating,
}: AnimateModalProps) {
  const [prompt, setPrompt] = useState(initialPrompt || '');
  const [aspectRatio, setAspectRatio] = useState(initialAspectRatio || '16:9');
  const [duration, setDuration] = useState(5);

  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setPrompt(initialPrompt || '');
      setAspectRatio(initialAspectRatio || '16:9');
      setDuration(5);
    }
  }, [isOpen, initialAspectRatio, initialPrompt]);

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
      <div className="animate-in fade-in zoom-in-95 w-full max-w-lg overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl duration-200">
        {/* Header */}
        <div className="flex items-center justify-between border-b border-white/10 bg-white/5 p-4">
          <h3 className="flex items-center gap-2 text-lg font-bold text-white">
            <Video className="h-5 w-5 text-purple-400" />
            Animate Image
          </h3>
          <button onClick={onClose} className="text-gray-400 transition-colors hover:text-white">
            <X className="h-5 w-5" />
          </button>
        </div>

        <div className="space-y-6 p-6">
          {/* Image Preview */}
          <div className="relative aspect-video overflow-hidden rounded-lg border border-white/10 bg-black/50">
            <img src={imageUrl} alt="Source" className="h-full w-full object-contain" />
            <div className="absolute right-2 bottom-2 rounded border border-white/10 bg-black/60 px-2 py-1 text-xs text-white backdrop-blur-md">
              {aspectRatio}
            </div>
          </div>

          {/* Prompt Input */}
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <label className="text-sm font-medium text-gray-300">Animation Prompt</label>
              <MagicPromptButton currentPrompt={prompt} onPromptEnhanced={setPrompt} />
            </div>
            <textarea
              value={prompt}
              onChange={e => setPrompt(e.target.value)}
              placeholder="Describe the motion (e.g., 'Slow pan right, wind blowing through hair')..."
              className="h-24 w-full resize-none rounded-xl border border-white/10 bg-black/50 p-3 text-sm text-white placeholder-gray-500 focus:border-purple-500/50 focus:ring-1 focus:ring-purple-500/50 focus:outline-none"
            />
          </div>

          {/* Aspect Ratio & Duration */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-300">Aspect Ratio</label>
              <div className="flex gap-2">
                <button
                  onClick={() => setAspectRatio('16:9')}
                  className={clsx(
                    'flex-1 rounded-lg border px-2 py-2 text-xs font-medium transition-all',
                    aspectRatio === '16:9'
                      ? 'border-purple-500 bg-purple-600 text-white shadow-lg shadow-purple-600/20'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                  )}
                >
                  16:9
                </button>
                <button
                  onClick={() => setAspectRatio('9:16')}
                  className={clsx(
                    'flex-1 rounded-lg border px-2 py-2 text-xs font-medium transition-all',
                    aspectRatio === '9:16'
                      ? 'border-purple-500 bg-purple-600 text-white shadow-lg shadow-purple-600/20'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                  )}
                >
                  9:16
                </button>
              </div>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-300">Duration</label>
              <div className="flex gap-2">
                <button
                  onClick={() => setDuration(5)}
                  className={clsx(
                    'flex-1 rounded-lg border px-2 py-2 text-xs font-medium transition-all',
                    duration === 5
                      ? 'border-purple-500 bg-purple-600 text-white shadow-lg shadow-purple-600/20'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                  )}
                >
                  5 sec
                </button>
                <button
                  onClick={() => setDuration(10)}
                  className={clsx(
                    'flex-1 rounded-lg border px-2 py-2 text-xs font-medium transition-all',
                    duration === 10
                      ? 'border-purple-500 bg-purple-600 text-white shadow-lg shadow-purple-600/20'
                      : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                  )}
                >
                  10 sec
                </button>
              </div>
            </div>
          </div>

          {/* Actions */}
          <div className="flex gap-3 pt-2">
            <button
              onClick={onClose}
              className="flex-1 rounded-xl border border-white/10 bg-white/5 py-2.5 font-medium text-gray-300 transition-colors hover:bg-white/10"
            >
              Cancel
            </button>
            <button
              onClick={() => onAnimate(prompt, aspectRatio, duration)}
              disabled={isGenerating || !prompt.trim()}
              className="flex flex-1 items-center justify-center gap-2 rounded-xl bg-purple-600 py-2.5 font-medium text-white shadow-lg shadow-purple-600/20 transition-colors hover:bg-purple-500 disabled:cursor-not-allowed disabled:opacity-50"
            >
              {isGenerating ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Animating...
                </>
              ) : (
                <>
                  <Video className="h-4 w-4" />
                  Generate Video
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/AudioInput.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Mic, Upload, X, Play, Square, Loader2, Music } from 'lucide-react';
import { clsx } from 'clsx';

interface AudioInputProps {
  file?: File | null;
  onAudioChange: (file: File | null) => void;
  className?: string;
}

export function AudioInput({ file, onAudioChange, className }: AudioInputProps) {
  const [audioFile, setAudioFile] = useState<File | null>(file || null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const audioPlayerRef = useRef<HTMLAudioElement | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    return () => {
      if (audioUrl) URL.revokeObjectURL(audioUrl);
      if (timerRef.current) clearInterval(timerRef.current);

      // Auto-stop and save if unmounting while recording
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
        mediaRecorderRef.current.stop();
      }
      // Cleanup manual WAV recorder
      if (processorRef.current) {
        processorRef.current.disconnect();
        processorRef.current = null;
      }
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        audioContextRef.current.close();
        audioContextRef.current = null;
      }
    };
  }, [audioUrl]);

  // Sync from parent prop
  useEffect(() => {
    if (file !== undefined && file !== audioFile) {
      setAudioFile(file);
      // Create URL for preview if file exists
      if (file) {
        const url = URL.createObjectURL(file);
        setAudioUrl(url);
      } else {
        setAudioUrl(null);
      }
    }
  }, [file]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setAudioFile(file);
      const url = URL.createObjectURL(file);
      setAudioUrl(url);
      onAudioChange(file);
    }
  };

  const audioContextRef = useRef<AudioContext | null>(null);
  const processorRef = useRef<ScriptProcessorNode | null>(null);
  const inputsRef = useRef<Float32Array[]>([]);

  const getSupportedMimeType = () => {
    const types = [
      { mime: 'audio/mpeg', ext: 'mp3' }, // Requested "native" for Chrome/Firefox (rarely supported, but checked first)
      { mime: 'audio/ogg', ext: 'ogg' }, // Firefox preferred
      { mime: 'audio/mp4', ext: 'm4a' }, // Safari preferred
      { mime: 'audio/aac', ext: 'aac' },
      { mime: 'audio/wav', ext: 'wav' },
    ];
    for (const t of types) {
      if (MediaRecorder.isTypeSupported(t.mime)) return t;
    }
    return null;
  };

  const writeWavHeader = (samples: Float32Array, sampleRate: number) => {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);

    const writeString = (view: DataView, offset: number, string: string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + samples.length * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, 'data');
    view.setUint32(40, samples.length * 2, true);

    const floatTo16BitPCM = (output: DataView, offset: number, input: Float32Array) => {
      for (let i = 0; i < input.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
    };

    floatTo16BitPCM(view, 44, samples);
    return view;
  };

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // Try supported MediaRecorder formats first
      const supported = getSupportedMimeType();

      if (supported) {
        // Use MediaRecorder for MP4/AAC/OGG
        const mediaRecorder = new MediaRecorder(stream, { mimeType: supported.mime });
        mediaRecorderRef.current = mediaRecorder;
        audioChunksRef.current = [];

        mediaRecorder.ondataavailable = event => {
          if (event.data.size > 0) {
            audioChunksRef.current.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          const audioBlob = new Blob(audioChunksRef.current, { type: supported.mime });
          const file = new File([audioBlob], `recording.${supported.ext}`, {
            type: supported.mime,
          });
          setAudioFile(file);
          const url = URL.createObjectURL(file);
          setAudioUrl(url);
          onAudioChange(file);
          stream.getTracks().forEach(track => track.stop());
        };

        mediaRecorder.start();
        setIsRecording(true);
      } else {
        // Fallback to WAV using AudioContext (usually Chrome/Firefox if OGG/MP4 fail)
        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        audioContextRef.current = audioContext;
        const source = audioContext.createMediaStreamSource(stream);
        const processor = audioContext.createScriptProcessor(4096, 1, 1);
        processorRef.current = processor;
        inputsRef.current = [];

        processor.onaudioprocess = e => {
          // Clone the data
          const channel = e.inputBuffer.getChannelData(0);
          inputsRef.current.push(new Float32Array(channel));
        };

        source.connect(processor);
        processor.connect(audioContext.destination);
        setIsRecording(true);
      }

      setRecordingTime(0);
      timerRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    } catch (err) {
      console.error('Error accessing microphone:', err);
      alert('Could not access microphone. Please check permissions.');
    }
  };

  const stopRecording = () => {
    if (isRecording) {
      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
        mediaRecorderRef.current.stop();
      } else if (audioContextRef.current && processorRef.current) {
        // Stop WAV recording
        if (processorRef.current) processorRef.current.disconnect();
        if (audioContextRef.current) audioContextRef.current.close();

        // Flatten buffers
        const flattenLength = inputsRef.current.reduce((acc, buf) => acc + buf.length, 0);
        const result = new Float32Array(flattenLength);
        let offset = 0;
        for (const buf of inputsRef.current) {
          result.set(buf, offset);
          offset += buf.length;
        }

        // Encode WAV
        const sampleRate = audioContextRef.current?.sampleRate || 44100;
        const view = writeWavHeader(result, sampleRate);
        const blob = new Blob([view], { type: 'audio/wav' });
        const file = new File([blob], 'recording.wav', { type: 'audio/wav' });

        setAudioFile(file);
        setAudioUrl(URL.createObjectURL(file));
        onAudioChange(file);

        // Reset refs
        processorRef.current = null;
        audioContextRef.current = null;
        inputsRef.current = [];
      }

      setIsRecording(false);
      if (timerRef.current) clearInterval(timerRef.current);
    }
  };

  const clearAudio = () => {
    setAudioFile(null);
    if (audioUrl) URL.revokeObjectURL(audioUrl);
    setAudioUrl(null);
    onAudioChange(null);
    setIsPlaying(false);
  };

  const togglePlayback = () => {
    if (!audioPlayerRef.current || !audioUrl) return;

    if (isPlaying) {
      audioPlayerRef.current.pause();
      setIsPlaying(false);
    } else {
      audioPlayerRef.current.play();
      setIsPlaying(true);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className={clsx('rounded-xl border border-white/10 bg-[#1a1a1a] p-4', className)}>
      <div className="mb-3 flex items-center justify-between">
        <h3 className="flex items-center gap-2 text-sm font-medium text-white">
          <Music className="h-4 w-4 text-blue-400" />
          Audio Source
          <span className="ml-2 text-xs font-normal text-gray-500">Required for Avatar models</span>
        </h3>
        {audioFile && (
          <button onClick={clearAudio} className="text-gray-500 transition-colors hover:text-white">
            <X className="h-4 w-4" />
          </button>
        )}
      </div>

      {!audioFile && !isRecording ? (
        <div className="grid grid-cols-2 gap-3">
          <button
            onClick={() => fileInputRef.current?.click()}
            className="group flex flex-col items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 p-4 transition-colors hover:bg-white/5"
          >
            <Upload className="h-5 w-5 text-gray-400 transition-colors group-hover:text-blue-400" />
            <span className="text-xs text-gray-400 group-hover:text-gray-200">Upload Audio</span>
          </button>
          <button
            onClick={startRecording}
            className="group flex flex-col items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 p-4 transition-colors hover:bg-white/5"
          >
            <Mic className="h-5 w-5 text-gray-400 transition-colors group-hover:text-red-400" />
            <span className="text-xs text-gray-400 group-hover:text-gray-200">Record Mic</span>
          </button>
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            accept="audio/*"
            className="hidden"
          />
        </div>
      ) : isRecording ? (
        <div className="flex items-center justify-between rounded-lg border border-red-500/20 bg-red-500/10 p-4">
          <div className="flex items-center gap-3">
            <div className="h-3 w-3 animate-pulse rounded-full bg-red-500" />
            <span className="text-sm font-medium text-red-400">
              Recording... {formatTime(recordingTime)}
            </span>
          </div>
          <button
            onClick={stopRecording}
            className="rounded-lg bg-red-500 p-2 text-white transition-colors hover:bg-red-600"
          >
            <Square className="h-4 w-4 fill-current" />
          </button>
        </div>
      ) : (
        <div className="flex items-center gap-3 rounded-lg border border-white/10 bg-white/5 p-3">
          <button
            onClick={togglePlayback}
            className="rounded-full bg-blue-500 p-2 text-white transition-colors hover:bg-blue-600"
          >
            {isPlaying ? (
              <Square className="h-3 w-3 fill-current" />
            ) : (
              <Play className="h-3 w-3 fill-current" />
            )}
          </button>

          <div className="min-w-0 flex-1">
            <p className="truncate text-sm text-white">{audioFile?.name || 'Recorded Audio'}</p>
            <p className="text-xs text-gray-500">
              {audioFile?.size ? (audioFile.size / 1024 / 1024).toFixed(2) : '0'} MB
            </p>
          </div>

          <audio
            ref={audioPlayerRef}
            src={audioUrl || undefined}
            onEnded={() => setIsPlaying(false)}
            className="hidden"
          />
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/GenerationForm.tsx">
import { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { SlidersHorizontal, Users, Wand2, X, Sparkles, Loader2 } from 'lucide-react';
import { ALL_MODELS } from '@/lib/ModelRegistry';
import { clsx } from 'clsx';
import { EngineSelectorV2 } from '@/components/generations/EngineSelectorV2';
import { PromptBuilder } from '@/components/prompts/PromptBuilder';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';
import { usePromptWeighting } from '@/hooks/usePromptWeighting';
import { Element } from '@/lib/store';
import { StyleConfig } from '@/components/storyboard/StyleSelectorModal';
import { PipelineStage } from '@/hooks/useGeneration';

interface GenerationFormProps {
  prompt: string;
  setPrompt: (p: string) => void;
  isGenerating: boolean;
  onGenerate: () => void;

  // Config
  engineConfig: { provider: string; model: string };
  setEngineConfig: (c: { provider: string; model: string }) => void;
  mode: 'image' | 'video';
  setMode: (m: 'image' | 'video') => void;
  aspectRatio: string;
  duration: string;
  setDuration: (d: string) => void;
  variations: number;
  setVariations: (n: number) => void;

  // Style / Elements
  elements: Element[];
  selectedElementIds: string[];
  toggleElement: (el: Element) => void;
  onOpenStyleModal: () => void;
  isElementPickerOpen: boolean;
  setIsElementPickerOpen: (v: boolean) => void;
  onOpenAdvancedSettings: () => void;

  // Audio
  audioFile: File | null;
  onOpenAudioModal: () => void;

  // Pipeline
  pipelineStages: PipelineStage[];
  setPipelineStages: (v: React.SetStateAction<PipelineStage[]>) => void;

  // Helpers
  styleConfig: StyleConfig | null;
  projectId: string; // needed for reference picker scoping
  onOpenEngineLibrary: () => void;
}

export function GenerationForm({
  prompt,
  setPrompt,
  isGenerating,
  onGenerate,
  engineConfig,
  setEngineConfig,
  mode,
  setMode,
  aspectRatio,
  duration,
  setDuration,
  variations,
  setVariations,
  elements,
  selectedElementIds,
  toggleElement,
  onOpenStyleModal,
  isElementPickerOpen,
  setIsElementPickerOpen,
  onOpenAdvancedSettings,
  audioFile,
  onOpenAudioModal,
  pipelineStages,
  setPipelineStages,
  styleConfig,
  projectId,
  onOpenEngineLibrary,
}: GenerationFormProps) {
  const [isFocused, setIsFocused] = useState(false);
  const [isPromptBuilderOpen, setIsPromptBuilderOpen] = useState(false);
  const [mounted, setMounted] = useState(false);

  // Mount check for portal
  useEffect(() => {
    setMounted(true);
  }, []);

  // Auto-complete (Simplified for extraction, can be fully restored if crucial)
  const [showSuggestions, setShowSuggestions] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const { handleKeyDown: handleWeightingKeyDown } = usePromptWeighting({
    value: prompt,
    onChange: setPrompt,
  });

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    handleWeightingKeyDown(e);
    if (e.defaultPrevented) return;

    if (e.key === 'Enter' && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      onGenerate();
    }
  };

  // Shortcut: Global Cmd+E to toggle Element Picker
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'e') {
        e.preventDefault();
        setIsElementPickerOpen(!isElementPickerOpen);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isElementPickerOpen, setIsElementPickerOpen]);

  // Duration logic
  const selectedModelInfo = ALL_MODELS.find(m => m.id === engineConfig.model);
  // Use supported durations if available, otherwise default to ['5s', '10s'] for video
  const availableDurations = selectedModelInfo?.supportedDurations || ['5s', '10s'];

  // Reset duration if current selection is not supported by new model
  useEffect(() => {
    if (mode === 'video' && !availableDurations.includes(duration)) {
      // Default to the first supported duration if current is invalid
      setDuration(availableDurations[0]);
    }
  }, [engineConfig.model, mode, availableDurations, duration, setDuration]);

  const handlePromptChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const val = e.target.value;
    const lastChar = val.slice(-1);

    setPrompt(val);

    // Auto-open picker on '@' trigger
    if (lastChar === '@') {
      setIsElementPickerOpen(true);
    }
  };

  return (
    <div className="pointer-events-none absolute right-0 bottom-0 left-0 z-50 flex justify-center p-6">
      <div className="pointer-events-auto w-full max-w-7xl">
        <div className="flex flex-col gap-2 rounded-2xl border border-white/10 bg-[#1a1a1a]/90 p-2 shadow-2xl ring-1 shadow-black/50 ring-white/5 backdrop-blur-xl">
          {/* Elements Drawer */}
          {isElementPickerOpen && (
            <div className="animate-in slide-in-from-bottom-2 border-b border-white/5 px-2 pt-2 pb-1 duration-200">
              {/* ... (Keep existing Logic, simplified here for brevity) ... */}
              <div className="mb-2 flex items-center justify-between">
                <span className="text-xs font-medium tracking-wider text-gray-400 uppercase">
                  {(() => {
                    const match = prompt.match(/@(\w*)$/);
                    const query = match ? match[1] : '';
                    return query ? `Filtering: "${query}"` : 'Reference Elements';
                  })()}
                </span>
              </div>
              {/* Simplified Element List */}
              <div className="scrollbar-none flex gap-2 overflow-x-auto pb-2">
                {elements
                  .filter(el => el.projectId === projectId)
                  .filter(el => {
                    // Simple suffix filtering: check if prompt ends with @Query and Query matches element
                    const match = prompt.match(/@(\w*)$/);
                    const query = match ? match[1].toLowerCase() : '';
                    if (!query) return true;
                    return el.name.toLowerCase().includes(query);
                  })
                  .map(el => (
                    <button
                      key={el.id}
                      onClick={() => toggleElement(el)}
                      className={clsx(
                        'relative h-12 w-12 flex-shrink-0 overflow-hidden rounded-lg border-2 transition-all',
                        selectedElementIds.includes(el.id)
                          ? 'border-blue-500'
                          : 'border-transparent opacity-60 hover:opacity-100'
                      )}
                    >
                      <Tooltip content={el.name} side="top">
                        <img src={el.url} className="h-full w-full object-cover" />
                      </Tooltip>
                    </button>
                  ))}
                {elements.filter(el => el.projectId === projectId).length === 0 && (
                  <span className="py-2 text-xs text-gray-500">No elements found in project.</span>
                )}
              </div>
            </div>
          )}

          <div className="flex items-end gap-2">
            <div className="relative min-w-0 flex-1 rounded-xl border border-white/5 bg-black/40 transition-all focus-within:border-blue-500/50 focus-within:ring-1 focus-within:ring-blue-500/50">
              <textarea
                ref={textareaRef}
                value={prompt}
                onChange={handlePromptChange}
                onKeyDown={handleKeyDown}
                onFocus={() => setIsFocused(true)}
                onBlur={() => setIsFocused(false)}
                placeholder="Describe your shot... (Use @ to reference elements)"
                className={clsx(
                  'w-full resize-none rounded-xl border-none bg-transparent px-4 py-3 text-white placeholder-gray-500 transition-all duration-200 ease-in-out focus:ring-0',
                  isFocused ? 'h-32' : 'h-10'
                )}
                rows={1}
              />
              {/* Selected Elements Chips */}
              {selectedElementIds.length > 0 && (
                <div className="scrollbar-none flex gap-2 overflow-x-auto px-4 pb-2">
                  {elements
                    .filter(e => selectedElementIds.includes(e.id))
                    .map(el => (
                      <div
                        key={el.id}
                        className="flex items-center gap-1.5 rounded-full border border-blue-500/30 bg-blue-500/20 px-2 py-1 text-[10px] text-blue-300"
                      >
                        <span>@{el.name}</span>
                        <button onClick={() => toggleElement(el)} className="hover:text-white">
                          X
                        </button>
                      </div>
                    ))}
                </div>
              )}
            </div>

            <div className="relative flex h-10 shrink-0 items-center gap-1.5">
              {/* 1. Smart Prompt (Wand) */}
              <Tooltip content="Smart Prompt Builder" side="top">
                <button
                  onClick={() => setIsPromptBuilderOpen(true)}
                  className="flex h-10 w-10 items-center justify-center rounded-xl border border-purple-500/20 bg-purple-500/10 text-purple-400 transition-all hover:scale-105 hover:bg-purple-500/20"
                >
                  <Wand2 className="h-5 w-5" />
                </button>
              </Tooltip>

              {/* 2. Style & Aspect Ratio */}
              <button
                onClick={onOpenStyleModal}
                className="flex h-10 items-center gap-2 rounded-xl border border-white/5 bg-black/20 px-3 text-gray-400 transition-all hover:bg-white/5 hover:text-white"
              >
                <SlidersHorizontal className="h-4 w-4" />
                <span className="hidden text-sm font-medium sm:inline">Style</span>
                <div className="mx-1 h-4 w-px bg-white/10" />
                <span className="rounded bg-white/10 px-1.5 py-0.5 font-mono text-xs text-gray-300">
                  {aspectRatio}
                </span>
              </button>

              {/* 3. Reference Elements (Users) -> Advanced Modal */}
              <Tooltip content="Element References (Advanced)" side="top">
                <button
                  onClick={onOpenAdvancedSettings}
                  className={clsx(
                    'relative flex h-10 w-10 items-center justify-center rounded-xl border transition-all',
                    isElementPickerOpen
                      ? 'border-blue-500/50 bg-blue-500/20 text-blue-300'
                      : 'border-white/5 bg-black/20 text-gray-400 hover:bg-white/5 hover:text-white'
                  )}
                >
                  <Users className="h-5 w-5" />
                  {selectedElementIds.length > 0 && (
                    <span className="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-blue-500 text-[10px] font-bold text-white">
                      {selectedElementIds.length}
                    </span>
                  )}
                </button>
              </Tooltip>

              {/* Model Selector Pill - Duration/Qty now in Model Library sidebar */}
              <div className="w-40">
                <EngineSelectorV2
                  selectedProvider={engineConfig.provider}
                  selectedModel={engineConfig.model}
                  onSelect={(p, m) => {
                    setEngineConfig({ provider: p, model: m });
                    // Auto-switch mode based on model type
                    const modelInfo = ALL_MODELS.find(x => x.id === m);
                    if (modelInfo) {
                      setMode(modelInfo.type);
                      // Reset duration if current is not supported
                      const supported = modelInfo.supportedDurations || ['5s', '10s'];
                      if (!supported.includes(duration)) {
                        setDuration(supported[0]);
                      }
                    }
                  }}
                  mode={mode}
                  variant="compact"
                  audioFile={audioFile}
                  onAudioChange={file => {
                    // Wrapper to match expected signature if needed, or directly pass setAudioFile from parent
                    // GenerationForm receives onOpenAudioModal?
                    // Wait, GenerationForm uses onOpenAudioModal for its OWN button.
                    // But EngineLibraryModal needs onAudioChange to SET the file.
                    // GenerationForm props has `audioFile`. Does it have `setAudioFile`?
                    // No, it has `onOpenAudioModal`.
                    // Let's check GenerationForm props again.
                  }}
                />
              </div>

              {/* 7. Generate Button */}
              <button
                onClick={onGenerate}
                disabled={isGenerating || !prompt?.trim()}
                className="flex h-10 items-center gap-2 rounded-xl bg-blue-600 px-4 font-medium text-white shadow-lg shadow-blue-500/20 transition-all hover:scale-105 hover:bg-blue-500 active:scale-95 disabled:opacity-50 disabled:grayscale"
              >
                {isGenerating ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Sparkles className="h-4 w-4 fill-white/20" />
                )}
                Generate
              </button>
            </div>
          </div>

          {/* Prompt Builder Modal - Rendered via Portal */}
          {mounted &&
            isPromptBuilderOpen &&
            createPortal(
              <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
                <div className="relative max-h-[90vh] w-full max-w-2xl overflow-y-auto rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl">
                  <button
                    onClick={() => setIsPromptBuilderOpen(false)}
                    className="absolute top-4 right-4 z-10 text-gray-400 hover:text-white"
                  >
                    <X className="h-5 w-5" />
                  </button>
                  <PromptBuilder
                    initialPrompt={prompt}
                    modelId={engineConfig.model}
                    generationType={mode}
                    elements={elements
                      .filter(e => selectedElementIds.includes(e.id))
                      .map(e => ({
                        id: e.id,
                        name: e.name,
                        description: e.name,
                        consistencyWeight: 1.0,
                        type: (['character', 'prop', 'location', 'style'].includes(e.type)
                          ? e.type
                          : 'style') as 'character' | 'prop' | 'location' | 'style',
                        imageUrl: e.url || e.thumbnail,
                      }))}
                    initialImages={elements
                      .filter(e => selectedElementIds.includes(e.id) && (e.url || e.thumbnail))
                      .map(e => e.url || e.thumbnail)
                      .filter((url): url is string => !!url)}
                    initialLoRAs={
                      styleConfig?.loras?.map(l => ({
                        id: l.id,
                        name: l.name,
                        triggerWords: l.triggerWords || (l.triggerWord ? [l.triggerWord] : []),
                        type: 'style' as const,
                        baseModel: l.baseModel || 'Unknown',
                        recommendedStrength: l.strength,
                        useCount: 0,
                      })) || []
                    }
                    onPromptChange={newPrompt => setPrompt(newPrompt)}
                    onClose={() => setIsPromptBuilderOpen(false)}
                  />
                </div>
              </div>,
              document.body
            )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/CreateStyleModal.tsx">
'use client';

import { useState, useEffect } from 'react';
import { X, Upload, Plus, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { useDropzone } from 'react-dropzone';
import { clsx } from 'clsx';

interface CreateStyleModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (style: CustomStyle) => void;
}

export interface CustomStyle {
  id: string;
  name: string;
  image: string; // URL or base64
  tags: string[];
}

const STYLE_TAGS = {
  Lighting: ['Cinematic', 'Natural', 'Studio', 'Neon', 'Golden Hour', 'Dark', 'Volumetric'],
  Camera: ['Wide Angle', 'Close Up', 'Drone', 'Handheld', 'Macro', 'Telephoto', 'Fisheye'],
  'Art Style': [
    'Realistic',
    '3D Render',
    'Anime',
    'Oil Painting',
    'Sketch',
    'Watercolor',
    'Pixel Art',
  ],
  Mood: ['Happy', 'Sad', 'Tense', 'Peaceful', 'Energetic', 'Mysterious', 'Romantic'],
};

export const ADVANCED_OPTIONS = {
  cameras: [
    'Arri Alexa 65',
    'RED Monstro 8K',
    'Sony Venice 2',
    'IMAX 70mm',
    'Panavision Millennium DXL2',
    '16mm Film Camera',
    'Super 8 Camera',
  ],
  lenses: [
    'Anamorphic Prime',
    'Vintage Cooke Speed Panchro',
    'Zeiss Master Prime',
    'Canon K35',
    'Petzval Art Lens',
    'Macro 100mm',
    'Tilt-Shift',
  ],
  films: [
    'Kodak Vision3 500T',
    'Kodak Portra 400',
    'Fujifilm Eterna 500T',
    'Ilford HP5 Plus (B&W)',
    'Kodachrome 64 (Emulation)',
    'LomoChrome Purple',
  ],
  colors: [
    'Teal & Orange',
    'Bleach Bypass',
    'Technicolor 2-Strip',
    'Cross Processed',
    'Faded Vintage',
    'High Contrast B&W',
    'Cyberpunk Neon',
  ],
  lighting: [
    'Cinematic',
    'Natural',
    'Studio',
    'Neon',
    'Golden Hour',
    'Dark',
    'Volumetric',
    'Rembrandt',
    'Split Lighting',
    'Butterfly Lighting',
  ],
  cameraMotions: [
    // Basic movements
    'Static',
    'Handheld',
    'Steadicam',
    'Gimbal',
    // Zoom family
    'Zoom In',
    'Zoom Out',
    'Crash Zoom',
    'Dolly Zoom (Vertigo)',
    // Dolly family
    'Dolly In',
    'Dolly Out',
    'Dolly Left',
    'Dolly Right',
    'Super Dolly',
    // Crane family
    'Crane Up',
    'Crane Down',
    'Crane Over',
    'Jib Up',
    'Jib Down',
    // Pan & Tilt
    'Pan Left',
    'Pan Right',
    'Tilt Up',
    'Tilt Down',
    'Whip Pan',
    // Orbital
    '360 Orbit',
    'Arc Left',
    'Arc Right',
    'Lazy Susan',
    '3D Rotation',
    // Specialty
    'Bullet Time',
    'Snorricam',
    'Dutch Angle',
    'Fisheye',
    'FPV Drone',
    'Through Object',
    'Rack Focus',
    // Character
    'Eyes In',
    'Hero Shot',
    'Over Shoulder',
    'Glam Shot',
    // Timelapse
    'Hyperlapse',
    'Timelapse',
  ],
  moods: [
    'Happy',
    'Sad',
    'Tense',
    'Peaceful',
    'Energetic',
    'Mysterious',
    'Romantic',
    'Melancholic',
    'Euphoric',
    'Ominous',
  ],
};

export function CreateStyleModal({ isOpen, onClose, onSave }: CreateStyleModalProps) {
  const [activeTab, setActiveTab] = useState<'basic' | 'advanced'>('basic');
  const [name, setName] = useState('');
  const [referenceImage, setReferenceImage] = useState<File | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);

  // Advanced State
  const [camera, setCamera] = useState('');
  const [lens, setLens] = useState('');
  const [film, setFilm] = useState('');
  const [color, setColor] = useState('');
  const [lighting, setLighting] = useState('');
  const [cameraMotion, setCameraMotion] = useState('');
  const [mood, setMood] = useState('');

  const onDrop = (acceptedFiles: File[]) => {
    if (acceptedFiles.length > 0) {
      setReferenceImage(acceptedFiles[0]);
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    maxFiles: 1,
  });

  const toggleTag = (tag: string) => {
    setSelectedTags(prev => (prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]));
  };

  const handleSave = () => {
    if (!name || !referenceImage) return;

    // Create a fake URL for the image for now (in real app, upload to server)
    const imageUrl = URL.createObjectURL(referenceImage);

    // Format advanced settings into descriptive tags
    const advancedTags = [];
    if (camera) advancedTags.push(`shot on ${camera}`);
    if (lens) advancedTags.push(`${lens} lens`);
    if (film) advancedTags.push(`${film} film stock`);
    if (color) advancedTags.push(`${color} color grading`);
    if (lighting) advancedTags.push(`${lighting} lighting`);
    if (cameraMotion) advancedTags.push(`${cameraMotion} camera movement`);
    if (mood) advancedTags.push(`${mood} mood`);

    const allTags = [...selectedTags, ...advancedTags];

    onSave({
      id: `custom_${Date.now()}`,
      name,
      image: imageUrl,
      tags: allTags,
    });
    onClose();
    resetForm();
  };

  const resetForm = () => {
    setName('');
    setReferenceImage(null);
    setSelectedTags([]);
    setCamera('');
    setLens('');
    setFilm('');
    setColor('');
    setLighting('');
    setCameraMotion('');
    setMood('');
    setActiveTab('basic');
  };

  // Preview URL
  const previewUrl = referenceImage ? URL.createObjectURL(referenceImage) : null;
  useEffect(() => {
    return () => {
      if (previewUrl) URL.revokeObjectURL(previewUrl);
    };
  }, [referenceImage]);

  return (
    <AnimatePresence>
      {isOpen && (
        <div
          className="fixed inset-0 z-[110] flex items-center justify-center bg-black/60 p-4 backdrop-blur-md"
          onClick={onClose}
        >
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            className="relative flex max-h-[90vh] w-full max-w-2xl flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
            onClick={e => e.stopPropagation()}
          >
            {/* Header */}
            <div className="flex items-center justify-between border-b border-white/10 bg-white/5 p-6">
              <div>
                <h2 className="text-xl font-bold text-white">Create Custom Style</h2>
                <p className="mt-1 text-sm text-gray-400">Define your unique visual style.</p>
              </div>
              <button
                onClick={onClose}
                className="rounded-full p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            {/* Tabs */}
            <div className="flex border-b border-white/10">
              <button
                onClick={() => setActiveTab('basic')}
                className={clsx(
                  'relative flex-1 py-3 text-sm font-medium transition-colors',
                  activeTab === 'basic' ? 'text-white' : 'text-gray-400 hover:text-white'
                )}
              >
                Basic
                {activeTab === 'basic' && (
                  <motion.div
                    layoutId="activeTab"
                    className="absolute right-0 bottom-0 left-0 h-0.5 bg-blue-500"
                  />
                )}
              </button>
              <button
                onClick={() => setActiveTab('advanced')}
                className={clsx(
                  'relative flex-1 py-3 text-sm font-medium transition-colors',
                  activeTab === 'advanced' ? 'text-white' : 'text-gray-400 hover:text-white'
                )}
              >
                Advanced (Pro)
                {activeTab === 'advanced' && (
                  <motion.div
                    layoutId="activeTab"
                    className="absolute right-0 bottom-0 left-0 h-0.5 bg-blue-500"
                  />
                )}
              </button>
            </div>

            {/* Content */}
            <div className="flex-1 space-y-8 overflow-y-auto p-6">
              <div className="grid grid-cols-1 gap-8 md:grid-cols-2">
                {/* Left Column: Inputs (Always visible) */}
                <div className="space-y-6">
                  {/* Name Input */}
                  <div>
                    <label className="mb-2 block text-sm font-medium text-gray-400">
                      Style Name
                    </label>
                    <input
                      type="text"
                      value={name}
                      onChange={e => setName(e.target.value)}
                      placeholder="e.g., Cyberpunk Noir"
                      className="w-full rounded-lg border border-white/10 bg-black/50 p-3 text-white placeholder:text-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    />
                  </div>

                  {/* Image Upload */}
                  <div>
                    <label className="mb-2 block text-sm font-medium text-gray-400">
                      Reference Image
                    </label>
                    <div
                      {...getRootProps()}
                      className={clsx(
                        'group relative flex aspect-video cursor-pointer flex-col items-center justify-center overflow-hidden rounded-xl border-2 border-dashed transition-all',
                        isDragActive
                          ? 'border-blue-500 bg-blue-500/10'
                          : 'border-white/10 bg-black/30 hover:border-white/30 hover:bg-white/5'
                      )}
                    >
                      <input {...getInputProps()} />
                      {previewUrl ? (
                        <>
                          <img
                            src={previewUrl}
                            className="absolute inset-0 h-full w-full object-cover"
                          />
                          <div className="absolute inset-0 flex items-center justify-center bg-black/60 opacity-0 transition-opacity group-hover:opacity-100">
                            <p className="flex items-center gap-2 text-sm font-medium text-white">
                              <Upload className="h-4 w-4" /> Replace Image
                            </p>
                          </div>
                        </>
                      ) : (
                        <div className="p-4 text-center">
                          <div className="mx-auto mb-3 flex h-12 w-12 items-center justify-center rounded-full bg-white/5 transition-transform group-hover:scale-110">
                            <Upload className="h-6 w-6 text-gray-400 group-hover:text-white" />
                          </div>
                          <p className="text-sm font-medium text-gray-300">Click or drag image</p>
                          <p className="mt-1 text-xs text-gray-500">Supports JPG, PNG</p>
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                {/* Right Column: Tabs Content */}
                <div>
                  {activeTab === 'basic' ? (
                    <motion.div
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: -20 }}
                    >
                      <label className="mb-4 block text-sm font-medium text-gray-400">
                        Style Tags
                      </label>
                      <div className="space-y-6">
                        {Object.entries(STYLE_TAGS).map(([category, tags]) => (
                          <div key={category}>
                            <h4 className="mb-3 text-xs font-bold tracking-wider text-gray-500 uppercase">
                              {category}
                            </h4>
                            <div className="flex flex-wrap gap-2">
                              {tags.map(tag => {
                                const isSelected = selectedTags.includes(tag);
                                return (
                                  <button
                                    key={tag}
                                    onClick={() => toggleTag(tag)}
                                    className={clsx(
                                      'flex items-center gap-1.5 rounded-full border px-3 py-1.5 text-xs font-medium transition-all',
                                      isSelected
                                        ? 'border-blue-500 bg-blue-500 text-white shadow-lg shadow-blue-500/25'
                                        : 'border-white/10 bg-white/5 text-gray-400 hover:border-white/20 hover:bg-white/10 hover:text-white'
                                    )}
                                  >
                                    {isSelected && <Check className="h-3 w-3" />}
                                    {tag}
                                  </button>
                                );
                              })}
                            </div>
                          </div>
                        ))}
                      </div>
                    </motion.div>
                  ) : (
                    <motion.div
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: -20 }}
                      className="space-y-6"
                    >
                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Camera Model
                        </label>
                        <select
                          value={camera}
                          onChange={e => setCamera(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Camera...</option>
                          {ADVANCED_OPTIONS.cameras.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Lens Type
                        </label>
                        <select
                          value={lens}
                          onChange={e => setLens(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Lens...</option>
                          {ADVANCED_OPTIONS.lenses.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Film Stock
                        </label>
                        <select
                          value={film}
                          onChange={e => setFilm(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Film Stock...</option>
                          {ADVANCED_OPTIONS.films.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Color Grade
                        </label>
                        <select
                          value={color}
                          onChange={e => setColor(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Color Grade...</option>
                          {ADVANCED_OPTIONS.colors.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Lighting
                        </label>
                        <select
                          value={lighting}
                          onChange={e => setLighting(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Lighting...</option>
                          {ADVANCED_OPTIONS.lighting.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">
                          Camera Motion
                        </label>
                        <select
                          value={cameraMotion}
                          onChange={e => setCameraMotion(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Camera Motion...</option>
                          {ADVANCED_OPTIONS.cameraMotions.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>

                      <div>
                        <label className="mb-2 block text-sm font-medium text-gray-400">Mood</label>
                        <select
                          value={mood}
                          onChange={e => setMood(e.target.value)}
                          className="w-full appearance-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                        >
                          <option value="">Select Mood...</option>
                          {ADVANCED_OPTIONS.moods.map(opt => (
                            <option key={opt} value={opt}>
                              {opt}
                            </option>
                          ))}
                        </select>
                      </div>
                    </motion.div>
                  )}
                </div>
              </div>
            </div>

            {/* Footer */}
            <div className="flex justify-end gap-3 border-t border-white/10 bg-[#1a1a1a] p-6">
              <button
                onClick={onClose}
                className="px-5 py-2.5 text-sm font-medium text-gray-400 transition-colors hover:text-white"
              >
                Cancel
              </button>
              <button
                onClick={handleSave}
                disabled={!name || !referenceImage}
                className="flex items-center gap-2 rounded-lg bg-blue-600 px-6 py-2.5 text-sm font-medium text-white shadow-lg shadow-blue-600/20 transition-all hover:bg-blue-500 disabled:cursor-not-allowed disabled:opacity-50"
              >
                <Plus className="h-4 w-4" />
                Create Style
              </button>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="frontend/src/components/storyboard/ShotStyleEditorModal.tsx">
'use client';

import { useState, useEffect } from 'react';
import { X, Sparkles, ChevronRight, Save } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { CinematicTagsModal } from './CinematicTagsModal';
import { ALL_CATEGORIES, CinematicTag } from '@/data/CinematicTags';

interface ShotStyleEditorModalProps {
  isOpen: boolean;
  onClose: () => void;
  shot: any;
  onSave: (shotId: string, newPrompt: string) => void;
}

export function ShotStyleEditorModal({ isOpen, onClose, shot, onSave }: ShotStyleEditorModalProps) {
  const [prompt, setPrompt] = useState('');
  const [isTagsModalOpen, setIsTagsModalOpen] = useState(false);
  const [initialTagCategory, setInitialTagCategory] = useState<string | undefined>(undefined);

  useEffect(() => {
    if (shot && shot.generation) {
      setPrompt(shot.generation.inputPrompt || '');
    }
  }, [shot]);

  const handleAddTag = (tag: CinematicTag, categoryId: string) => {
    const prefix = prompt ? `${prompt}, ` : '';
    // Use the tag's prompt directly - it already includes the proper formatting
    setPrompt(prefix + tag.prompt);
    setIsTagsModalOpen(false);
  };

  const openTagsModal = (categoryId?: string) => {
    setInitialTagCategory(categoryId);
    setIsTagsModalOpen(true);
  };

  const handleSave = () => {
    if (shot) {
      onSave(shot.id, prompt);
      onClose();
    }
  };

  if (!shot) return null;

  return (
    <>
      <AnimatePresence>
        {isOpen && (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm"
            onClick={onClose}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.95 }}
              className="relative flex w-full max-w-lg flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
              onClick={e => e.stopPropagation()}
            >
              {/* Header */}
              <div className="flex items-center justify-between border-b border-white/10 p-4">
                <h2 className="flex items-center gap-2 text-lg font-bold text-white">
                  <Sparkles className="h-4 w-4 text-purple-400" />
                  Edit Shot Style
                </h2>
                <button
                  onClick={onClose}
                  className="rounded-full p-1 text-gray-400 hover:bg-white/10 hover:text-white"
                >
                  <X className="h-5 w-5" />
                </button>
              </div>

              {/* Content */}
              <div className="space-y-6 p-6">
                {/* Preview Thumbnail (if available) */}
                {shot.generation?.outputs?.[0] && (
                  <div className="mb-4 h-32 w-full overflow-hidden rounded-lg border border-white/10 bg-black/50">
                    <img
                      src={shot.generation.outputs[0].url}
                      className="h-full w-full object-cover opacity-50"
                    />
                  </div>
                )}

                {/* Prompt Input */}
                <div>
                  <label className="mb-2 block text-sm font-medium text-gray-400">
                    Shot Prompt
                  </label>
                  <textarea
                    value={prompt}
                    onChange={e => setPrompt(e.target.value)}
                    className="h-32 w-full resize-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-purple-500 focus:outline-none"
                    placeholder="Describe the shot..."
                  />
                </div>

                {/* Quick Add Tags */}
                <div>
                  <p className="mb-2 text-xs font-bold tracking-wider text-gray-500 uppercase">
                    Quick Add Cinematic Tags
                  </p>
                  <div className="grid grid-cols-2 gap-2">
                    {ALL_CATEGORIES.map(cat => (
                      <button
                        key={cat.id}
                        onClick={() => openTagsModal(cat.id)}
                        className="flex w-full items-center justify-between rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-sm text-gray-300 transition-colors hover:bg-white/10 hover:text-white"
                      >
                        <span className="flex items-center gap-2">
                          <span>{cat.icon}</span> {cat.label}
                        </span>
                        <ChevronRight className="h-4 w-4 opacity-50" />
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {/* Footer */}
              <div className="flex justify-end gap-2 border-t border-white/10 bg-[#1a1a1a] p-4">
                <button
                  onClick={onClose}
                  className="px-4 py-2 text-sm font-medium text-gray-400 transition-colors hover:text-white"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSave}
                  className="flex items-center gap-2 rounded-lg bg-purple-600 px-6 py-2 text-sm font-medium text-white transition-colors hover:bg-purple-500"
                >
                  <Save className="h-4 w-4" />
                  Save Changes
                </button>
              </div>
            </motion.div>
          </div>
        )}
      </AnimatePresence>

      {/* Cinematic Tags Modal */}
      <CinematicTagsModal
        isOpen={isTagsModalOpen}
        onClose={() => setIsTagsModalOpen(false)}
        onSelectTag={handleAddTag}
        initialCategory={initialTagCategory}
      />
    </>
  );
}
</file>

<file path="frontend/src/components/storyboard/ElementReferencePicker.tsx">
'use client';

import { useState, useEffect } from 'react';
import { X, Plus, Users, Search, Check, Info } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { fetchAPI, resolveFileUrl } from '@/lib/api';

interface ElementReferencePickerProps {
  projectId: string;
  isOpen: boolean;
  onClose: () => void;
  selectedElements: string[];
  onSelectionChange: (elements: string[]) => void;
  maxElements?: number;
  // Global fallback (optional if we fully switch to per-element)
  creativity?: number;
  onCreativityChange?: (value: number) => void;
  // Per-element strength
  elementStrengths: Record<string, number>;
  onStrengthChange: (id: string, value: number) => void;
}

export function ElementReferencePicker({
  projectId,
  isOpen,
  onClose,
  selectedElements,
  onSelectionChange,
  maxElements = 4,
  creativity = 0.6,
  onCreativityChange,
  elementStrengths,
  onStrengthChange,
}: ElementReferencePickerProps) {
  const [elements, setElements] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<'all' | 'character' | 'style' | 'prop'>('all');
  const [activeElementId, setActiveElementId] = useState<string | null>(null);

  // Set first selected element as active on open if none active
  useEffect(() => {
    if (isOpen && selectedElements.length > 0 && !activeElementId) {
      setActiveElementId(selectedElements[0]);
    }
  }, [isOpen, selectedElements]);

  useEffect(() => {
    if (isOpen) {
      loadElements();
    }
  }, [isOpen, projectId]);

  const loadElements = async () => {
    setLoading(true);
    try {
      const data = await fetchAPI(`/projects/${projectId}/elements`);
      setElements(data);
    } catch (err) {
      console.error('Failed to load elements', err);
    } finally {
      setLoading(false);
    }
  };

  const toggleElement = (elementId: string) => {
    if (selectedElements.includes(elementId)) {
      // Deselecting
      const newSelection = selectedElements.filter(e => e !== elementId);
      onSelectionChange(newSelection);
      if (activeElementId === elementId) {
        setActiveElementId(newSelection.length > 0 ? newSelection[0] : null);
      }
    } else if (selectedElements.length < maxElements) {
      // Selecting
      onSelectionChange([...selectedElements, elementId]);
      setActiveElementId(elementId); // Auto-activate newly selected
      // Initialize strength if not present
      if (!elementStrengths[elementId]) {
        onStrengthChange(elementId, 0.6);
      }
    }
  };

  const handleElementClick = (id: string) => {
    if (selectedElements.includes(id)) {
      setActiveElementId(id);
    } else {
      toggleElement(id);
    }
  };

  const filteredElements = elements.filter(el => {
    const matchesSearch =
      el.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      el.tags?.some((t: string) => t.toLowerCase().includes(searchQuery.toLowerCase()));
    const matchesType = filterType === 'all' || el.type === filterType;
    return matchesSearch && matchesType;
  });

  // Build the @Image reference string for prompting
  const buildReferencePrompt = () => {
    return selectedElements.map((_, idx) => `@Image${idx + 1}`).join(', ');
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-[100] flex items-center justify-center bg-black/70 p-4 backdrop-blur-sm"
      onClick={onClose}
    >
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="relative w-full max-w-2xl overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
        onClick={e => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between border-b border-white/10 p-4">
          <div className="flex items-center gap-3">
            <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-purple-500/20">
              <Users className="h-4 w-4 text-purple-400" />
            </div>
            <div>
              <h2 className="text-lg font-bold text-white">Element References</h2>
              <p className="text-xs text-gray-500">
                Select up to {maxElements} elements for character/style consistency
              </p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="rounded-full p-1 text-gray-400 hover:bg-white/10 hover:text-white"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Search & Filters */}
        <div className="space-y-3 border-b border-white/10 p-4">
          <div className="relative">
            <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-500" />
            <input
              type="text"
              value={searchQuery}
              onChange={e => setSearchQuery(e.target.value)}
              placeholder="Search elements..."
              className="w-full rounded-lg border border-white/10 bg-black/30 py-2 pr-4 pl-10 text-sm text-white placeholder-gray-600 focus:border-purple-500/50 focus:outline-none"
            />
          </div>
          <div className="flex gap-2">
            {['all', 'character', 'style', 'prop'].map(type => (
              <button
                key={type}
                onClick={() => setFilterType(type as any)}
                className={clsx(
                  'rounded-lg px-3 py-1.5 text-xs font-medium transition-colors',
                  filterType === type
                    ? 'bg-purple-600 text-white'
                    : 'bg-white/5 text-gray-400 hover:bg-white/10'
                )}
              >
                {type.charAt(0).toUpperCase() + type.slice(1)}
              </button>
            ))}
          </div>
        </div>

        {/* Selected Elements Preview */}
        {selectedElements.length > 0 && (
          <div className="border-b border-purple-500/20 bg-purple-500/5 p-4">
            <div className="mb-2 flex items-center justify-between">
              <div className="flex items-center gap-4">
                <span className="text-xs font-medium text-purple-300">
                  Selected ({selectedElements.length}/{maxElements})
                </span>
                <div className="flex flex-col gap-1">
                  <div className="flex items-center gap-2">
                    <span className="text-[10px] font-medium tracking-wider text-purple-300 uppercase">
                      Creative
                    </span>
                    <input
                      type="range"
                      min="0.1"
                      max="1.0"
                      step="0.01"
                      value={
                        activeElementId ? elementStrengths[activeElementId] || 0.6 : creativity
                      }
                      onChange={e => {
                        const val = parseFloat(e.target.value);
                        if (activeElementId) {
                          onStrengthChange(activeElementId, val);
                        } else if (onCreativityChange) {
                          onCreativityChange(val);
                        }
                      }}
                      disabled={!activeElementId && !onCreativityChange}
                      className={clsx(
                        'h-1.5 w-32 cursor-pointer appearance-none rounded-lg transition-all',
                        activeElementId
                          ? 'bg-gray-700 accent-purple-500 hover:accent-purple-400'
                          : 'bg-gray-800 accent-gray-600'
                      )}
                    />
                    <span className="text-[10px] font-medium tracking-wider text-purple-300 uppercase">
                      Strict
                    </span>
                  </div>
                  <div className="flex justify-between px-1">
                    <span className="text-[8px] text-gray-500">Picasso</span>
                    <span className="text-[8px] text-gray-500">Da Vinci</span>
                  </div>
                </div>
                <span className="w-8 text-right font-mono text-xs font-bold text-purple-400">
                  {(
                    (activeElementId ? elementStrengths[activeElementId] || 0.6 : creativity) * 100
                  ).toFixed(0)}
                  %
                </span>
              </div>
              <span className="font-mono text-xs text-gray-500">
                Prompt ref: {buildReferencePrompt()}
              </span>
            </div>
            <div className="flex gap-2 overflow-x-auto pb-2">
              {selectedElements.map((id, idx) => {
                const el = elements.find(e => e.id === id);
                const url = resolveFileUrl(el?.fileUrl);
                return (
                  <div
                    key={id}
                    className={clsx(
                      'relative flex-shrink-0 cursor-pointer transition-all',
                      activeElementId === id ? 'z-10 scale-105' : 'opacity-80 hover:opacity-100'
                    )}
                    onClick={() => setActiveElementId(id)}
                  >
                    {url ? (
                      <img
                        src={url}
                        alt={`Element ${idx + 1}`}
                        className={clsx(
                          'h-16 w-16 rounded-lg border-2 object-cover',
                          activeElementId === id
                            ? 'border-blue-500 shadow-[0_0_10px_rgba(59,130,246,0.5)]'
                            : 'border-purple-500'
                        )}
                        onError={e => {
                          console.error('Image load failed for URL:', url);
                          console.error('Original fileUrl:', el?.fileUrl);
                          e.currentTarget.style.border = '2px solid red';
                        }}
                      />
                    ) : (
                      <div
                        className={clsx(
                          'flex h-16 w-16 items-center justify-center rounded-lg border-2 bg-gray-800',
                          activeElementId === id
                            ? 'border-blue-500 shadow-[0_0_10px_rgba(59,130,246,0.5)]'
                            : 'border-purple-500'
                        )}
                      >
                        <span className="text-[10px] text-gray-500">No image</span>
                      </div>
                    )}
                    <div className="absolute -top-1 -left-1 z-10 flex h-5 w-5 items-center justify-center rounded-full border border-white/20 bg-purple-500 text-[10px] font-bold text-white shadow-sm">
                      {idx + 1}
                    </div>
                    <div className="absolute right-0 bottom-0 left-0 flex items-center justify-between bg-black/60 px-1 py-0.5 text-center backdrop-blur-[2px]">
                      <span className="font-mono text-[8px] font-medium text-white">
                        @Image{idx + 1}
                      </span>
                      <span className="ml-1 text-[8px] font-bold text-blue-300">
                        {((elementStrengths[id] || 0.6) * 100).toFixed(0)}%
                      </span>
                    </div>
                    <button
                      onClick={e => {
                        e.stopPropagation();
                        toggleElement(id);
                      }}
                      className="absolute -top-1 -right-1 z-10 flex h-5 w-5 items-center justify-center rounded-full border border-white/20 bg-red-500 text-white shadow-sm hover:bg-red-400"
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Elements Grid */}
        <div className="max-h-80 overflow-y-auto p-4">
          {loading ? (
            <div className="py-8 text-center text-gray-500">Loading elements...</div>
          ) : filteredElements.length === 0 ? (
            <div className="py-8 text-center text-gray-500">
              No elements found. Create elements on the Elements page.
            </div>
          ) : (
            <div className="grid grid-cols-4 gap-3">
              {filteredElements.map(element => {
                const isSelected = selectedElements.includes(element.id);
                const selectionIndex = selectedElements.indexOf(element.id);
                const canSelect = selectedElements.length < maxElements || isSelected;
                const url = resolveFileUrl(element.fileUrl);

                return (
                  <button
                    key={element.id}
                    onClick={() => handleElementClick(element.id)}
                    disabled={!canSelect}
                    className={clsx(
                      'relative aspect-square overflow-hidden rounded-lg border-2 transition-all',
                      isSelected
                        ? activeElementId === element.id
                          ? 'border-blue-500 ring-2 ring-blue-500/30'
                          : 'border-purple-500 ring-2 ring-purple-500/30'
                        : canSelect
                          ? 'border-white/10 hover:border-white/30'
                          : 'cursor-not-allowed border-white/5 opacity-50'
                    )}
                  >
                    {url ? (
                      <img src={url} alt={element.name} className="h-full w-full object-cover" />
                    ) : (
                      <div className="flex h-full w-full items-center justify-center bg-gray-800">
                        <span className="text-xs text-gray-500">No image</span>
                      </div>
                    )}

                    {/* Selection Indicator */}
                    {isSelected && (
                      <div className="absolute inset-0 flex items-center justify-center bg-purple-500/20 backdrop-blur-[1px]">
                        <div className="flex flex-col items-center gap-1">
                          <div className="flex h-8 w-8 items-center justify-center rounded-full border border-white/20 bg-purple-500 font-bold text-white shadow-lg">
                            {selectionIndex + 1}
                          </div>
                          <span className="rounded border border-white/10 bg-black/60 px-1.5 py-0.5 font-mono text-[9px] font-medium text-white">
                            @Image{selectionIndex + 1}
                          </span>
                        </div>
                      </div>
                    )}

                    {/* Element Name */}
                    <div className="absolute right-0 bottom-0 left-0 bg-black/60 p-1 backdrop-blur-sm">
                      <p className="truncate text-center text-[10px] text-white">{element.name}</p>
                    </div>

                    {/* Type Badge */}
                    <div className="absolute top-1 left-1">
                      <span
                        className={clsx(
                          'rounded px-1.5 py-0.5 text-[8px] font-medium',
                          element.type === 'character' && 'bg-blue-500/80 text-white',
                          element.type === 'style' && 'bg-purple-500/80 text-white',
                          element.type === 'prop' && 'bg-green-500/80 text-white',
                          !element.type && 'bg-gray-500/80 text-white'
                        )}
                      >
                        {element.type || 'other'}
                      </span>
                    </div>
                  </button>
                );
              })}
            </div>
          )}
        </div>

        {/* Info & Actions */}
        <div className="border-t border-white/10 bg-[#1a1a1a] p-4">
          <div className="mb-4 flex items-start gap-2 rounded-lg border border-blue-500/20 bg-blue-500/5 p-3">
            <Info className="mt-0.5 h-4 w-4 flex-shrink-0 text-blue-400" />
            <div className="text-xs leading-relaxed text-blue-300/80">
              <strong>Kling O1 Elements:</strong> Reference selected elements in your prompt using{' '}
              <code className="rounded bg-black/30 px-1">@Image1</code>,{' '}
              <code className="rounded bg-black/30 px-1">@Image2</code>, etc. for character/style
              consistency.
            </div>
          </div>
          <div className="flex justify-end gap-2">
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm font-medium text-gray-400 transition-colors hover:text-white"
            >
              Cancel
            </button>
            <button
              onClick={onClose}
              className="rounded-lg bg-purple-600 px-6 py-2 text-sm font-medium text-white transition-colors hover:bg-purple-500"
            >
              Apply ({selectedElements.length})
            </button>
          </div>
        </div>
      </motion.div>
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/GenreSelector.tsx">
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { ChevronDown, Check, Sparkles, Palette, Film } from 'lucide-react';
import {
  Genre,
  GenreTemplate,
  GENRE_TEMPLATES,
  getGenreOptions,
  getGenreTemplate,
} from '@/data/GenreTemplates';

interface GenreSelectorProps {
  selectedGenre: Genre | null;
  onSelect: (genre: Genre | null) => void;
  showStylePreview?: boolean;
  className?: string;
  /** When true, shows adult/NSFW genres like "Adult / OnlyFans" */
  includeMature?: boolean;
}

export function GenreSelector({
  selectedGenre,
  onSelect,
  showStylePreview = true,
  className,
  includeMature = false,
}: GenreSelectorProps) {
  const [isOpen, setIsOpen] = useState(false);

  const selectedTemplate = selectedGenre ? GENRE_TEMPLATES[selectedGenre] : null;
  const genreOptions = getGenreOptions(includeMature);

  return (
    <div className={clsx('space-y-2', className)}>
      {/* Dropdown trigger */}
      <div className="relative">
        <button
          onClick={() => setIsOpen(!isOpen)}
          className="flex w-full items-center justify-between rounded-xl border border-white/10 bg-black/50 px-4 py-3 text-left transition-colors hover:bg-white/5"
        >
          <div className="flex items-center gap-3">
            {selectedTemplate ? (
              <>
                <span className="text-xl">{selectedTemplate.icon}</span>
                <div>
                  <span className="block text-sm font-medium text-white">
                    {selectedTemplate.name}
                  </span>
                  <span className="text-[10px] text-gray-500">
                    {selectedTemplate.description.slice(0, 50)}...
                  </span>
                </div>
              </>
            ) : (
              <>
                <Film className="h-5 w-5 text-gray-500" />
                <span className="text-sm text-gray-400">
                  Select a genre for smart recommendations...
                </span>
              </>
            )}
          </div>
          <ChevronDown
            className={clsx('h-5 w-5 text-gray-400 transition-transform', isOpen && 'rotate-180')}
          />
        </button>

        {/* Dropdown menu */}
        <AnimatePresence>
          {isOpen && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              className="absolute top-full right-0 left-0 z-50 mt-2 overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
            >
              {/* Clear option */}
              <button
                onClick={() => {
                  onSelect(null);
                  setIsOpen(false);
                }}
                className={clsx(
                  'flex w-full items-center gap-3 border-b border-white/10 px-4 py-3 text-left transition-colors',
                  !selectedGenre ? 'bg-blue-500/10 text-blue-300' : 'text-gray-400 hover:bg-white/5'
                )}
              >
                <span className="w-6 text-center text-gray-500"></span>
                <span className="text-sm">No genre (show all camera moves)</span>
                {!selectedGenre && <Check className="ml-auto h-4 w-4 text-blue-400" />}
              </button>

              {/* Genre options grid */}
              <div className="grid max-h-80 grid-cols-2 gap-1 overflow-y-auto p-2">
                {genreOptions.map(({ value, label, icon }) => {
                  const template = GENRE_TEMPLATES[value];
                  const isSelected = selectedGenre === value;

                  return (
                    <button
                      key={value}
                      onClick={() => {
                        onSelect(value);
                        setIsOpen(false);
                      }}
                      className={clsx(
                        'rounded-lg p-3 text-left transition-all',
                        isSelected
                          ? 'border border-blue-500/50 bg-blue-500/20'
                          : 'border border-transparent bg-white/5 hover:border-white/20 hover:bg-white/10'
                      )}
                    >
                      <div className="mb-1 flex items-center gap-2">
                        <span className="text-lg">{icon}</span>
                        <span
                          className={clsx(
                            'text-sm font-medium',
                            isSelected ? 'text-blue-300' : 'text-white'
                          )}
                        >
                          {label}
                        </span>
                        {isSelected && <Check className="ml-auto h-3.5 w-3.5 text-blue-400" />}
                      </div>
                      <p className="line-clamp-2 text-[10px] text-gray-500">
                        {template.description}
                      </p>
                    </button>
                  );
                })}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Style preview panel */}
      {showStylePreview && selectedTemplate && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: 'auto' }}
          className="space-y-4 rounded-xl border border-white/10 bg-gradient-to-br from-white/5 to-white/0 p-4"
        >
          {/* Default style */}
          <div>
            <div className="mb-2 flex items-center gap-2">
              <Palette className="h-3.5 w-3.5 text-purple-400" />
              <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                Default Visual Style
              </span>
            </div>
            <p className="text-xs text-gray-300 italic">"{selectedTemplate.defaultStyle}"</p>
          </div>

          {/* Color palette */}
          <div>
            <span className="mb-2 block text-[10px] font-bold tracking-wider text-gray-400 uppercase">
              Color Palette
            </span>
            <div className="flex flex-wrap gap-1.5">
              {selectedTemplate.colorPalette.map((color: string, i: number) => (
                <span key={i} className="rounded bg-black/30 px-2 py-0.5 text-[10px] text-gray-300">
                  {color}
                </span>
              ))}
            </div>
          </div>

          {/* Recommended cameras */}
          <div>
            <div className="mb-2 flex items-center gap-2">
              <Sparkles className="h-3.5 w-3.5 text-green-400" />
              <span className="text-[10px] font-bold tracking-wider text-gray-400 uppercase">
                Recommended Camera Moves
              </span>
            </div>
            <div className="flex flex-wrap gap-1">
              {selectedTemplate.cameraPreferences.slice(0, 6).map((preset: string, i: number) => (
                <span
                  key={i}
                  className="rounded-full border border-green-500/30 bg-green-500/10 px-2 py-0.5 text-[10px] text-green-300"
                >
                  {preset.replace(/_/g, ' ')}
                </span>
              ))}
              {selectedTemplate.cameraPreferences.length > 6 && (
                <span className="text-[10px] text-gray-500">
                  +{selectedTemplate.cameraPreferences.length - 6} more
                </span>
              )}
            </div>
          </div>

          {/* Style notes */}
          <div>
            <span className="mb-2 block text-[10px] font-bold tracking-wider text-gray-400 uppercase">
              Style Tips
            </span>
            <ul className="space-y-1">
              {selectedTemplate.styleNotes.slice(0, 3).map((note: string, i: number) => (
                <li key={i} className="flex items-start gap-2 text-[10px] text-gray-400">
                  <span className="mt-0.5 text-blue-400"></span>
                  {note}
                </li>
              ))}
            </ul>
          </div>
        </motion.div>
      )}
    </div>
  );
}

// 
// Compact inline version
// 

interface GenreBadgeProps {
  genre: Genre;
  onClick?: () => void;
  showRemove?: boolean;
  onRemove?: () => void;
}

export function GenreBadge({ genre, onClick, showRemove, onRemove }: GenreBadgeProps) {
  const template = GENRE_TEMPLATES[genre];

  return (
    <span
      onClick={onClick}
      className={clsx(
        'inline-flex items-center gap-1.5 rounded-full border border-blue-500/30 bg-blue-500/10 px-2 py-1 text-xs text-blue-300',
        onClick && 'cursor-pointer hover:bg-blue-500/20'
      )}
    >
      <span>{template.icon}</span>
      <span>{template.name}</span>
      {showRemove && onRemove && (
        <button
          onClick={e => {
            e.stopPropagation();
            onRemove();
          }}
          className="ml-1 hover:text-white"
        >
          
        </button>
      )}
    </span>
  );
}

// 
// Quick genre pills for compact selection
// 

interface GenrePillsProps {
  selectedGenre: Genre | null;
  onSelect: (genre: Genre | null) => void;
  maxVisible?: number;
  /** When true, shows adult/NSFW genres like "Adult / OnlyFans" */
  includeMature?: boolean;
}

export function GenrePills({
  selectedGenre,
  onSelect,
  maxVisible = 6,
  includeMature = false,
}: GenrePillsProps) {
  const [showAll, setShowAll] = useState(false);
  const genreOptions = getGenreOptions(includeMature);
  const visibleOptions = showAll ? genreOptions : genreOptions.slice(0, maxVisible);

  return (
    <div className="flex flex-wrap gap-1.5">
      {visibleOptions.map(({ value, label, icon }) => (
        <button
          key={value}
          onClick={() => onSelect(selectedGenre === value ? null : value)}
          className={clsx(
            'flex items-center gap-1 rounded-full px-2.5 py-1 text-xs font-medium transition-all',
            selectedGenre === value
              ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/25'
              : 'bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
          )}
        >
          <span>{icon}</span>
          <span>{label}</span>
        </button>
      ))}
      {genreOptions.length > maxVisible && (
        <button
          onClick={() => setShowAll(!showAll)}
          className="rounded-full px-2.5 py-1 text-xs text-gray-500 hover:bg-white/10 hover:text-white"
        >
          {showAll ? 'Show less' : `+${genreOptions.length - maxVisible} more`}
        </button>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/storyboard/StoryboardShot.tsx">
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import {
  Upload,
  Trash2,
  GripVertical,
  Loader2,
  Check,
  AlertCircle,
  Sparkles,
  Video,
  ChevronDown,
  Image as ImageIcon,
  RefreshCcw,
  X,
  ZoomIn,
  ZoomOut,
  Download,
  Clock,
} from 'lucide-react';
import { clsx } from 'clsx';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';
import { usePromptWeighting } from '@/hooks/usePromptWeighting';
import { usePromptAutocomplete } from '@/hooks/usePromptAutocomplete';
import { AutocompletePopup } from '@/components/prompts/AutocompletePopup';
import { BACKEND_URL } from '@/lib/api';
import { MODEL_PRICING, formatCost } from '@/lib/ModelPricing';

// Helper to resolve relative URLs from backend to full URLs
function resolveUrl(url: string | null | undefined): string | undefined {
  if (!url) return undefined;
  if (url.startsWith('http://') || url.startsWith('https://')) return url;
  return `${BACKEND_URL}${url.startsWith('/') ? '' : '/'}${url}`;
}

interface ElementData {
  id: string;
  name: string;
  type?: string;
  url?: string;
  fileUrl?: string;
  thumbnail?: string;
  projectId?: string;
}

// Popular image models for frame generation
const IMAGE_MODELS = [
  { id: 'fal-ai/flux/dev', name: 'FLUX Dev', desc: 'High quality, LoRA support' },
  { id: 'fal-ai/flux/schnell', name: 'FLUX Schnell', desc: 'Fast iteration' },
  { id: 'fal-ai/flux-pro', name: 'FLUX Pro', desc: 'Best prompt adherence' },
  { id: 'fal-ai/flux-pro/v1.1-ultra', name: 'FLUX Ultra', desc: '4MP high-res' },
  { id: 'fal-ai/ideogram/v2', name: 'Ideogram v2', desc: 'Great typography' },
  { id: 'fal-ai/recraft-v3', name: 'Recraft v3', desc: 'Design & illustration' },
  { id: 'google/imagen-4', name: 'Imagen 4', desc: 'Google photorealism' },
  { id: 'fal-ai/stable-diffusion-v35-large', name: 'SD 3.5 Large', desc: 'Open source' },
];

// Video resolution options by model family
const VIDEO_RESOLUTION_MAP: Record<string, { id: string; label: string }[]> = {
  'kling': [
    { id: '480p', label: '480p' },
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'wan': [
    { id: '480p', label: '480p' },
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'luma': [
    { id: '540p', label: '540p' },
    { id: '720p', label: '720p' },
  ],
  'minimax': [
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'vidu': [
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'ltx': [
    { id: '480p', label: '480p' },
    { id: '720p', label: '720p' },
  ],
  'hunyuan': [
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'pixverse': [
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
  'default': [
    { id: '480p', label: '480p' },
    { id: '720p', label: '720p' },
    { id: '1080p', label: '1080p' },
  ],
};

// Helper to get available resolutions based on video model
function getVideoResolutions(videoModel: string | null | undefined) {
  const model = videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video';
  const modelLower = model.toLowerCase();
  for (const [key, resolutions] of Object.entries(VIDEO_RESOLUTION_MAP)) {
    if (key !== 'default' && modelLower.includes(key)) {
      return resolutions;
    }
  }
  return VIDEO_RESOLUTION_MAP.default;
}

// Resolution multipliers for pricing (base price is for 720p)
const RESOLUTION_MULTIPLIERS: Record<string, number> = {
  '480p': 0.7,
  '540p': 0.8,
  '720p': 1.0,
  '1080p': 1.5,
};

// Resolution to megapixels mapping (standard dimensions, rounded up)
// Based on: MP = (width  height) / 1,000,000, then ceil()
const RESOLUTION_MEGAPIXELS: Record<string, number> = {
  '480p': 1,   // 854480 = 0.41 MP  rounds to 1 MP
  '540p': 1,   // 960540 = 0.52 MP  rounds to 1 MP
  '720p': 1,   // 1280720 = 0.92 MP  rounds to 1 MP
  '1080p': 3,  // 19201080 = 2.07 MP  rounds to 3 MP
  '4k': 9,     // 38402160 = 8.29 MP  rounds to 9 MP
};

// Image resolution options (for frame generation)
const IMAGE_RESOLUTIONS = [
  { id: '720p', label: '720p', desc: '~1 MP' },
  { id: '1080p', label: '1080p', desc: '~3 MP' },
  { id: '4k', label: '4K', desc: '~9 MP' },
];

// Raw numeric image cost calculation (for totals)
export function calculateImageCost(
  imageModel: string | null | undefined,
  resolution: string | null | undefined
): number {
  const model = imageModel || 'fal-ai/flux/dev';
  const res = resolution || '720p';
  const pricing = MODEL_PRICING[model];

  if (!pricing) {
    return 0.03; // Default estimate
  }

  // If model has free pricing
  if (pricing.free) {
    return 0;
  }

  // Get megapixels for the resolution
  const megapixels = RESOLUTION_MEGAPIXELS[res] || 1;

  // Calculate cost based on pricing type
  if (pricing.perMegapixel) {
    return pricing.perMegapixel * megapixels;
  } else if (pricing.perImage) {
    // Flux Dev is $0.025 per MP according to user
    if (model.includes('flux') && model.includes('dev')) {
      return pricing.perImage * megapixels;
    }
    return pricing.perImage;
  }

  return 0.03;
}

// Helper to estimate image generation cost based on megapixels
function estimateImageCost(
  imageModel: string | null | undefined,
  resolution: string | null | undefined
): string {
  const cost = calculateImageCost(imageModel, resolution);
  if (cost === 0) return 'Free';
  return formatCost(cost);
}

// Helper to estimate video generation cost
function estimateVideoCost(
  videoModel: string | null | undefined,
  resolution: string | null | undefined,
  durationSeconds: number
): string {
  return formatCost(calculateVideoCost(videoModel, resolution, durationSeconds));
}

// Raw numeric video cost calculation (for totals)
export function calculateVideoCost(
  videoModel: string | null | undefined,
  resolution: string | null | undefined,
  durationSeconds: number
): number {
  const model = videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video';
  const res = resolution || '720p';
  const pricing = MODEL_PRICING[model];

  if (!pricing || !pricing.perSecond) {
    return 0.50; // Default estimate
  }

  const basePrice = pricing.basePrice || 0;
  const perSecond = pricing.perSecond;
  const multiplier = RESOLUTION_MULTIPLIERS[res] || 1.0;

  return basePrice + (perSecond * durationSeconds * multiplier);
}

// Calculate total shot cost including all iterations
export function calculateTotalShotCost(shot: ShotData): {
  imageCost: number;
  videoCost: number;
  total: number;
  imageIterations: number;
  videoIterations: number;
} {
  const firstFrameIters = shot.firstFrameIterations || 0;
  const lastFrameIters = shot.lastFrameIterations || 0;
  const videoIters = shot.videoIterations || 0;

  const costPerFrame = calculateImageCost(shot.imageModel, shot.imageResolution);
  const costPerVideo = calculateVideoCost(shot.videoModel, shot.videoResolution, shot.duration || 5);

  const imageCost = (firstFrameIters + lastFrameIters) * costPerFrame;
  const videoCost = videoIters * costPerVideo;

  return {
    imageCost,
    videoCost,
    total: imageCost + videoCost,
    imageIterations: firstFrameIters + lastFrameIters,
    videoIterations: videoIters,
  };
}

// Video models that support first/last frame references (image-to-video)
const VIDEO_MODELS = [
  { id: 'fal-ai/kling-video/v2.1/master/image-to-video', name: 'Kling 2.1 Master', desc: 'Premium motion fluidity' },
  { id: 'fal-ai/kling-video/v2.6/pro/image-to-video', name: 'Kling 2.6 Pro', desc: 'Latest Kling with pro features' },
  { id: 'fal-ai/wan/v2.6/image-to-video', name: 'Wan 2.6 I2V', desc: 'Alibaba latest, great motion' },
  { id: 'fal-ai/wan-pro/image-to-video', name: 'Wan Pro I2V', desc: 'Professional quality' },
  { id: 'fal-ai/luma-dream-machine/ray-2/image-to-video', name: 'Luma Ray 2', desc: 'Cinematic quality' },
  { id: 'fal-ai/minimax-video/image-to-video', name: 'MiniMax Hailuo', desc: 'High quality, fast' },
  { id: 'fal-ai/vidu/image-to-video', name: 'Vidu I2V', desc: 'Up to 7 reference images' },
  { id: 'fal-ai/ltx-video/image-to-video', name: 'LTX Video', desc: 'Fast conversion' },
  { id: 'fal-ai/hunyuan-video-image-to-video', name: 'Hunyuan I2V', desc: 'Open-source, diverse motion' },
  { id: 'fal-ai/pixverse/v4.5/image-to-video', name: 'Pixverse V4.5', desc: 'High quality motion' },
];

export interface ShotData {
  id: string;
  orderIndex: number;
  prompt: string;
  duration: number;
  firstFrameUrl?: string | null;
  lastFrameUrl?: string | null;
  firstFramePrompt?: string | null;
  lastFramePrompt?: string | null;
  outputUrl?: string | null;
  status: 'pending' | 'generating' | 'complete' | 'failed';
  failureReason?: string | null;
  imageModel?: string | null; // Model to use for frame generation
  imageResolution?: string | null; // Image output resolution (720p, 1080p, 4k)
  videoModel?: string | null; // Model to use for video generation (I2V)
  videoResolution?: string | null; // Video output resolution (480p, 720p, 1080p)
  // Iteration tracking for cost calculation
  firstFrameIterations?: number; // Number of times first frame was generated
  lastFrameIterations?: number;  // Number of times last frame was generated
  videoIterations?: number;      // Number of times video was generated
}

interface StoryboardShotProps {
  shot: ShotData;
  sceneTitle?: string;
  sceneDescription?: string;
  elements?: ElementData[];  // For @reference autocomplete
  projectId?: string;        // For filtering elements
  onUpdate: (id: string, updates: Partial<ShotData>) => void;
  onDelete: (id: string) => void;
  onGenerate: (id: string) => void;
  onUploadFrame: (id: string, frameType: 'first' | 'last', file: File) => void;
  onGenerateFrame?: (id: string, frameType: 'first' | 'last') => void;
  onEnhancePrompt?: (id: string) => void;
  onEnhanceFramePrompt?: (id: string, frameType: 'first' | 'last') => void;
  onEnhanceVideoPrompt?: (id: string) => void; // Smart Prompt Builder for video prompt (uses video model)
  isGenerating?: boolean;
  isGeneratingFirstFrame?: boolean;
  isGeneratingLastFrame?: boolean;
  dragHandleProps?: any;
}

export default function StoryboardShot({
  shot,
  sceneTitle,
  sceneDescription,
  elements = [],
  projectId,
  onUpdate,
  onDelete,
  onGenerate,
  onUploadFrame,
  onGenerateFrame,
  onEnhancePrompt,
  onEnhanceFramePrompt,
  onEnhanceVideoPrompt,
  isGenerating = false,
  isGeneratingFirstFrame = false,
  isGeneratingLastFrame = false,
  dragHandleProps,
}: StoryboardShotProps) {
  const [isHoveringPreview, setIsHoveringPreview] = useState(false);
  const firstFrameInputRef = useRef<HTMLInputElement>(null);
  const lastFrameInputRef = useRef<HTMLInputElement>(null);

  // Lightbox state for expanded viewing
  const [lightboxOpen, setLightboxOpen] = useState<'first' | 'last' | 'video' | null>(null);
  const [lightboxZoom, setLightboxZoom] = useState(1);

  // Close lightbox on Escape key
  useEffect(() => {
    if (!lightboxOpen) return;
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setLightboxOpen(null);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [lightboxOpen]);

  // Expanded prompt state - tracks which prompt is expanded inline
  const [expandedPrompt, setExpandedPrompt] = useState<'first' | 'last' | 'shot' | null>(null);
  const shotTriggerRef = useRef<HTMLDivElement>(null);
  const [shotPopoutPosition, setShotPopoutPosition] = useState<{ top: number; left: number } | null>(null);

  // Local editing state - buffers changes to prevent parent re-renders while typing
  const [editingFirstPrompt, setEditingFirstPrompt] = useState('');
  const [editingLastPrompt, setEditingLastPrompt] = useState('');
  const [editingShotPrompt, setEditingShotPrompt] = useState('');

  // Prompt weighting hooks for Ctrl/Cmd + Arrow Up/Down keyboard shortcuts
  const firstPromptWeighting = usePromptWeighting({
    value: editingFirstPrompt,
    onChange: setEditingFirstPrompt,
  });
  const lastPromptWeighting = usePromptWeighting({
    value: editingLastPrompt,
    onChange: setEditingLastPrompt,
  });
  const shotPromptWeighting = usePromptWeighting({
    value: editingShotPrompt,
    onChange: setEditingShotPrompt,
  });

  // Autocomplete hooks for @reference, #prop, $variable
  const firstAutocomplete = usePromptAutocomplete({
    value: editingFirstPrompt,
    onChange: setEditingFirstPrompt,
    elements,
    projectId,
  });
  const lastAutocomplete = usePromptAutocomplete({
    value: editingLastPrompt,
    onChange: setEditingLastPrompt,
    elements,
    projectId,
  });
  const shotAutocomplete = usePromptAutocomplete({
    value: editingShotPrompt,
    onChange: setEditingShotPrompt,
    elements,
    projectId,
  });

  // Initialize local state when opening a prompt
  useEffect(() => {
    if (expandedPrompt === 'first') {
      setEditingFirstPrompt(shot.firstFramePrompt || '');
    } else if (expandedPrompt === 'last') {
      setEditingLastPrompt(shot.lastFramePrompt || '');
    } else if (expandedPrompt === 'shot') {
      setEditingShotPrompt(shot.prompt || '');
    }
  }, [expandedPrompt, shot.firstFramePrompt, shot.lastFramePrompt, shot.prompt]);

  // Handle blur to collapse and save
  const handlePromptBlur = (type: 'first' | 'last' | 'shot') => {
    // Save the edited value to parent
    if (type === 'first') {
      onUpdate(shot.id, { firstFramePrompt: editingFirstPrompt });
    } else if (type === 'last') {
      onUpdate(shot.id, { lastFramePrompt: editingLastPrompt });
    } else if (type === 'shot') {
      onUpdate(shot.id, { prompt: editingShotPrompt });
    }

    // Small delay to allow clicking other elements
    setTimeout(() => {
      if (expandedPrompt === type) {
        setExpandedPrompt(null);
        if (type === 'shot') {
          setShotPopoutPosition(null);
        }
      }
    }, 200);
  };

  // Open shot prompt with portal positioning
  const handleOpenShotPrompt = () => {
    if (shot.status === 'generating') return;
    if (shotTriggerRef.current) {
      const rect = shotTriggerRef.current.getBoundingClientRect();
      setShotPopoutPosition({ top: rect.top, left: rect.left });
    }
    setExpandedPrompt('shot');
  };

  const handleFrameUpload =
    (frameType: 'first' | 'last') => (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
        onUploadFrame(shot.id, frameType, file);
      }
    };

  return (
    <TooltipProvider>
    <div className="flex gap-4">
      {/* Left Panel - Scene Info */}
      <div className="flex w-[420px] flex-shrink-0 flex-col rounded-xl border border-white/10 bg-[#1a1a1a] p-4">
        {/* Scene Title & Description */}
        <div className="mb-6 flex items-start gap-2">
          <div
            {...dragHandleProps}
            className="mt-1 cursor-grab text-gray-500 hover:text-white active:cursor-grabbing"
          >
            <GripVertical className="h-4 w-4" />
          </div>
          <div className="flex-1">
            <h3 className="font-semibold text-white">
              {sceneTitle || `Shot ${shot.orderIndex + 1}`}
            </h3>
            {sceneDescription && (
              <p className="mt-2 text-xs leading-relaxed text-gray-400">{sceneDescription}</p>
            )}
          </div>
          <Tooltip content="Delete shot" side="top">
            <button
              onClick={() => onDelete(shot.id)}
              className="rounded p-1.5 text-gray-500 transition-colors hover:bg-red-500/10 hover:text-red-400"
            >
              <Trash2 className="h-4 w-4" />
            </button>
          </Tooltip>
        </div>

        {/* First Frame Prompt */}
        <div className="relative mb-3">
          <div className="mb-1 flex items-center justify-between">
            <span className="text-[10px] font-medium uppercase tracking-wide text-green-400">
              First Frame Prompt
            </span>
            {onEnhanceFramePrompt && shot.firstFramePrompt && (
              <Tooltip content="Enhance with Smart Prompt Builder" side="top">
                <button
                  onClick={() => onEnhanceFramePrompt(shot.id, 'first')}
                  className="rounded p-1 text-purple-400 transition-colors hover:bg-purple-500/10"
                >
                  <Sparkles className="h-3 w-3" />
                </button>
              </Tooltip>
            )}
          </div>
          {/* Collapsed display */}
          <div
            onClick={() => setExpandedPrompt('first')}
            className="min-h-[60px] w-full cursor-pointer rounded-lg border border-white/10 bg-black/40 px-2 py-1.5 text-xs text-white transition-colors hover:border-green-500/30"
          >
            {shot.firstFramePrompt ? (
              <span className="line-clamp-3">{shot.firstFramePrompt}</span>
            ) : (
              <span className="text-gray-600">Click to edit...</span>
            )}
          </div>
          {/* Pop-out bubble */}
          {expandedPrompt === 'first' && (
            <div className="absolute top-0 left-0 z-50 w-[600px] animate-in fade-in zoom-in-95 duration-150">
              <div className="relative rounded-xl border border-green-500/50 bg-[#1a1a1a] p-3 shadow-2xl shadow-black/50">
                <div className="mb-2 flex items-center justify-between">
                  <span className="text-[10px] font-medium uppercase tracking-wide text-green-400">
                    First Frame Prompt
                  </span>
                </div>
                {/* Autocomplete popup above textarea */}
                <AutocompletePopup
                  isOpen={firstAutocomplete.autocomplete.isOpen}
                  items={firstAutocomplete.filteredItems}
                  query={firstAutocomplete.autocomplete.query}
                  triggerType={firstAutocomplete.autocomplete.triggerType}
                  onSelect={firstAutocomplete.selectItem}
                  onClose={firstAutocomplete.close}
                  className="bottom-full left-0 right-0 mb-2"
                />
                <textarea
                  autoFocus
                  value={editingFirstPrompt}
                  onChange={firstAutocomplete.handleChange}
                  onKeyDown={(e) => {
                    // Autocomplete gets priority when open
                    if (firstAutocomplete.autocomplete.isOpen) {
                      firstAutocomplete.handleKeyDown(e);
                      if (e.defaultPrevented) return;
                    }
                    // Then prompt weighting
                    firstPromptWeighting.handleKeyDown(e);
                  }}
                  onBlur={() => handlePromptBlur('first')}
                  placeholder="Describe the first frame... (use @element #prop $variable)"
                  rows={Math.max(5, editingFirstPrompt.split('\n').length + Math.ceil(editingFirstPrompt.length / 80))}
                  className="w-full resize-none rounded-lg border border-green-500/30 bg-black/60 px-3 py-2 text-sm text-white placeholder-gray-600 focus:border-green-500/50 focus:outline-none"
                />
              </div>
            </div>
          )}
        </div>

        {/* Last Frame Prompt */}
        <div className="relative mb-3">
          <div className="mb-1 flex items-center justify-between">
            <span className="text-[10px] font-medium uppercase tracking-wide text-purple-400">
              Last Frame Prompt
            </span>
            {onEnhanceFramePrompt && shot.lastFramePrompt && (
              <Tooltip content="Enhance with Smart Prompt Builder" side="top">
                <button
                  onClick={() => onEnhanceFramePrompt(shot.id, 'last')}
                  className="rounded p-1 text-purple-400 transition-colors hover:bg-purple-500/10"
                >
                  <Sparkles className="h-3 w-3" />
                </button>
              </Tooltip>
            )}
          </div>
          {/* Collapsed display */}
          <div
            onClick={() => setExpandedPrompt('last')}
            className="min-h-[60px] w-full cursor-pointer rounded-lg border border-white/10 bg-black/40 px-2 py-1.5 text-xs text-white transition-colors hover:border-purple-500/30"
          >
            {shot.lastFramePrompt ? (
              <span className="line-clamp-3">{shot.lastFramePrompt}</span>
            ) : (
              <span className="text-gray-600">Click to edit...</span>
            )}
          </div>
          {/* Pop-out bubble */}
          {expandedPrompt === 'last' && (
            <div className="absolute top-0 left-0 z-50 w-[600px] animate-in fade-in zoom-in-95 duration-150">
              <div className="relative rounded-xl border border-purple-500/50 bg-[#1a1a1a] p-3 shadow-2xl shadow-black/50">
                <div className="mb-2 flex items-center justify-between">
                  <span className="text-[10px] font-medium uppercase tracking-wide text-purple-400">
                    Last Frame Prompt
                  </span>
                </div>
                {/* Autocomplete popup above textarea */}
                <AutocompletePopup
                  isOpen={lastAutocomplete.autocomplete.isOpen}
                  items={lastAutocomplete.filteredItems}
                  query={lastAutocomplete.autocomplete.query}
                  triggerType={lastAutocomplete.autocomplete.triggerType}
                  onSelect={lastAutocomplete.selectItem}
                  onClose={lastAutocomplete.close}
                  className="bottom-full left-0 right-0 mb-2"
                />
                <textarea
                  autoFocus
                  value={editingLastPrompt}
                  onChange={lastAutocomplete.handleChange}
                  onKeyDown={(e) => {
                    // Autocomplete gets priority when open
                    if (lastAutocomplete.autocomplete.isOpen) {
                      lastAutocomplete.handleKeyDown(e);
                      if (e.defaultPrevented) return;
                    }
                    // Then prompt weighting
                    lastPromptWeighting.handleKeyDown(e);
                  }}
                  onBlur={() => handlePromptBlur('last')}
                  placeholder="Describe the last frame... (use @element #prop $variable)"
                  rows={Math.max(5, editingLastPrompt.split('\n').length + Math.ceil(editingLastPrompt.length / 80))}
                  className="w-full resize-none rounded-lg border border-purple-500/30 bg-black/60 px-3 py-2 text-sm text-white placeholder-gray-600 focus:border-purple-500/50 focus:outline-none"
                />
              </div>
            </div>
          )}
        </div>

        {/* Image Model Selector - for frame generation */}
        <div className="mb-3">
          <div className="mb-1 flex items-center gap-1.5">
            <ImageIcon className="h-3 w-3 text-amber-400" />
            <span className="text-[10px] font-medium uppercase tracking-wide text-amber-400">
              Frame Model
            </span>
          </div>
          <div className="relative">
            <select
              value={shot.imageModel || 'fal-ai/flux/dev'}
              onChange={e => onUpdate(shot.id, { imageModel: e.target.value })}
              className="w-full appearance-none rounded-lg border border-white/10 bg-black/40 px-2.5 py-1.5 pr-8 text-xs text-white transition-colors hover:border-amber-500/30 focus:border-amber-500/50 focus:outline-none"
            >
              {IMAGE_MODELS.map(model => (
                <option key={model.id} value={model.id} className="bg-[#1a1a1a]">
                  {model.name}
                </option>
              ))}
            </select>
            <ChevronDown className="pointer-events-none absolute right-2 top-1/2 h-3.5 w-3.5 -translate-y-1/2 text-gray-500" />
          </div>
          {/* Description with Image Resolution and pricing */}
          <div className="mt-1 flex items-center justify-between gap-2">
            <p className="text-[10px] text-gray-500">
              {IMAGE_MODELS.find(m => m.id === (shot.imageModel || 'fal-ai/flux/dev'))?.desc || ''}
            </p>
            {/* Image Resolution dropdown with pricing */}
            <div className="flex shrink-0 items-center gap-1.5">
              {/* Per-image cost (amber) */}
              <span className="text-[10px] text-amber-400/70">
                {estimateImageCost(shot.imageModel, shot.imageResolution)}
              </span>
              {/* Total spent (cyan) - only shows when iterations exist */}
              {((shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)) > 0 && (
                <span className="text-[10px] text-cyan-400">
                   {formatCost(
                    ((shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)) *
                    calculateImageCost(shot.imageModel, shot.imageResolution)
                  )}
                  <span className="ml-0.5 text-gray-500">
                    ({(shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)})
                  </span>
                </span>
              )}
              <div className="relative">
                <select
                  value={shot.imageResolution || '1080p'}
                  onChange={e => onUpdate(shot.id, { imageResolution: e.target.value })}
                  className="appearance-none rounded border border-white/10 bg-black/40 px-2 py-0.5 pr-6 text-[10px] text-white transition-colors hover:border-amber-500/30 focus:border-amber-500/50 focus:outline-none"
                >
                  {IMAGE_RESOLUTIONS.map(res => (
                    <option key={res.id} value={res.id} className="bg-[#1a1a1a]">
                      {res.label}
                    </option>
                  ))}
                </select>
                <ChevronDown className="pointer-events-none absolute right-1 top-1/2 h-3 w-3 -translate-y-1/2 text-gray-500" />
              </div>
            </div>
          </div>
        </div>

        {/* Spacer */}
        <div className="flex-1" />

        {/* Beginning & Ending Frame Uploads */}
        <div className="mt-4 grid grid-cols-2 gap-3">
          {/* Beginning Image */}
          <div className="relative">
            {/* Label with iteration count and Regen icon */}
            <div className="mb-1 flex items-center justify-between">
              <div className="flex items-center gap-1.5">
                <span className="text-[10px] font-medium uppercase tracking-wide text-green-400">
                  First Frame
                </span>
                {(shot.firstFrameIterations || 0) > 0 && (
                  <span className="rounded bg-green-500/20 px-1 py-0.5 text-[9px] font-medium text-green-400">
                    {shot.firstFrameIterations}
                  </span>
                )}
              </div>
              {shot.firstFrameUrl && onGenerateFrame && shot.firstFramePrompt && (
                <Tooltip content="Iterate from prompt" side="top">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onGenerateFrame(shot.id, 'first');
                    }}
                    className="rounded p-0.5 text-green-400 transition-colors hover:bg-green-500/20"
                  >
                    <RefreshCcw className="h-3 w-3" />
                  </button>
                </Tooltip>
              )}
            </div>
            <input
              ref={firstFrameInputRef}
              type="file"
              accept="image/*"
              onChange={handleFrameUpload('first')}
              className="hidden"
            />
            <div
              onClick={() => {
                if (isGeneratingFirstFrame) return;
                if (shot.firstFrameUrl) {
                  setLightboxOpen('first');
                  setLightboxZoom(1);
                } else {
                  firstFrameInputRef.current?.click();
                }
              }}
              className={clsx(
                'aspect-video overflow-hidden rounded-lg border-2 border-dashed transition-all',
                isGeneratingFirstFrame
                  ? 'cursor-wait border-green-500/50 bg-green-500/10'
                  : shot.firstFrameUrl
                    ? 'cursor-zoom-in border-green-500/50 bg-black/30'
                    : 'cursor-pointer border-white/20 bg-black/20 hover:border-white/40 hover:bg-black/30'
              )}
            >
              {isGeneratingFirstFrame ? (
                <div className="flex h-full w-full flex-col items-center justify-center gap-1">
                  <Loader2 className="h-4 w-4 animate-spin text-green-400" />
                  <span className="text-[10px] text-green-400">Generating...</span>
                </div>
              ) : shot.firstFrameUrl ? (
                <img
                  src={resolveUrl(shot.firstFrameUrl)}
                  alt="Beginning frame"
                  className="h-full w-full object-cover"
                />
              ) : (
                <div className="flex h-full w-full flex-col items-center justify-center gap-1">
                  <Upload className="h-4 w-4 text-gray-500" />
                </div>
              )}
            </div>
            {/* Full-width Generate button */}
            {onGenerateFrame && shot.firstFramePrompt && !shot.firstFrameUrl && (
              <Tooltip content="Generate first frame from prompt" side="bottom">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onGenerateFrame(shot.id, 'first');
                  }}
                  disabled={isGeneratingFirstFrame}
                  className="mt-1.5 flex w-full items-center justify-center gap-1 rounded bg-green-500/20 py-1 text-[10px] font-medium text-green-400 transition-colors hover:bg-green-500/30"
                >
                  <Sparkles className="h-3 w-3" />
                  Generate
                </button>
              </Tooltip>
            )}
          </div>

          {/* Ending Image */}
          <div className="relative">
            {/* Label with iteration count and Regen icon */}
            <div className="mb-1 flex items-center justify-between">
              <div className="flex items-center gap-1.5">
                <span className="text-[10px] font-medium uppercase tracking-wide text-purple-400">
                  Last Frame
                </span>
                {(shot.lastFrameIterations || 0) > 0 && (
                  <span className="rounded bg-purple-500/20 px-1 py-0.5 text-[9px] font-medium text-purple-400">
                    {shot.lastFrameIterations}
                  </span>
                )}
              </div>
              {shot.lastFrameUrl && onGenerateFrame && shot.lastFramePrompt && (
                <Tooltip content="Iterate from prompt" side="top">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onGenerateFrame(shot.id, 'last');
                    }}
                    className="rounded p-0.5 text-purple-400 transition-colors hover:bg-purple-500/20"
                  >
                    <RefreshCcw className="h-3 w-3" />
                  </button>
                </Tooltip>
              )}
            </div>
            <input
              ref={lastFrameInputRef}
              type="file"
              accept="image/*"
              onChange={handleFrameUpload('last')}
              className="hidden"
            />
            <div
              onClick={() => {
                if (isGeneratingLastFrame) return;
                if (shot.lastFrameUrl) {
                  setLightboxOpen('last');
                  setLightboxZoom(1);
                } else {
                  lastFrameInputRef.current?.click();
                }
              }}
              className={clsx(
                'aspect-video overflow-hidden rounded-lg border-2 border-dashed transition-all',
                isGeneratingLastFrame
                  ? 'cursor-wait border-purple-500/50 bg-purple-500/10'
                  : shot.lastFrameUrl
                    ? 'cursor-zoom-in border-purple-500/50 bg-black/30'
                    : 'cursor-pointer border-white/20 bg-black/20 hover:border-white/40 hover:bg-black/30'
              )}
            >
              {isGeneratingLastFrame ? (
                <div className="flex h-full w-full flex-col items-center justify-center gap-1">
                  <Loader2 className="h-4 w-4 animate-spin text-purple-400" />
                  <span className="text-[10px] text-purple-400">Generating...</span>
                </div>
              ) : shot.lastFrameUrl ? (
                <img
                  src={resolveUrl(shot.lastFrameUrl)}
                  alt="Ending frame"
                  className="h-full w-full object-cover"
                />
              ) : (
                <div className="flex h-full w-full flex-col items-center justify-center gap-1">
                  <Upload className="h-4 w-4 text-gray-500" />
                </div>
              )}
            </div>
            {/* Full-width Generate button */}
            {onGenerateFrame && shot.lastFramePrompt && !shot.lastFrameUrl && (
              <Tooltip content="Generate last frame from prompt" side="bottom">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onGenerateFrame(shot.id, 'last');
                  }}
                  disabled={isGeneratingLastFrame}
                  className="mt-1.5 flex w-full items-center justify-center gap-1 rounded bg-purple-500/20 py-1 text-[10px] font-medium text-purple-400 transition-colors hover:bg-purple-500/30"
                >
                  <Sparkles className="h-3 w-3" />
                  Generate
                </button>
              </Tooltip>
            )}
          </div>
        </div>
      </div>

      {/* Right Panel - Shot Card */}
      <div className="min-w-[700px] flex-1 overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a]">
        {/* Video Preview Area */}
        <div
          className="relative bg-gradient-to-br from-gray-800/50 to-black/50"
          onMouseEnter={() => setIsHoveringPreview(true)}
          onMouseLeave={() => setIsHoveringPreview(false)}
        >
          {/* Shot Number Badge */}
          <div className="absolute top-3 left-3 z-10 flex items-center gap-2 rounded bg-black/60 px-2 py-1 backdrop-blur-sm">
            <GripVertical className="h-3 w-3 text-gray-400" />
            <span className="text-sm font-medium text-white">{shot.orderIndex + 1}</span>
          </div>

          {/* Status Badge with Regen icon */}
          <div className="absolute top-3 right-3 z-10 flex items-center gap-2">
            {/* Iterate icon - only shows when complete */}
            {shot.status === 'complete' && shot.outputUrl && (
              <Tooltip content="Iterate video" side="top">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onGenerate(shot.id);
                  }}
                  className="flex items-center justify-center rounded-full bg-black/60 p-1.5 text-cyan-400 backdrop-blur-sm transition-colors hover:bg-cyan-500/20"
                >
                  <RefreshCcw className="h-3 w-3" />
                </button>
              </Tooltip>
            )}
            {shot.status === 'generating' && (
              <div className="flex items-center gap-1.5 rounded-full bg-amber-500/20 px-2 py-1 text-xs text-amber-400 backdrop-blur-sm">
                <Loader2 className="h-3 w-3 animate-spin" />
                Generating
              </div>
            )}
            {shot.status === 'complete' && (
              <div className="flex items-center gap-1.5 rounded-full bg-green-500/20 px-2 py-1 text-xs text-green-400 backdrop-blur-sm">
                <Check className="h-3 w-3" />
                Complete
                {(shot.videoIterations || 0) > 0 && (
                  <span className="ml-1 rounded bg-green-500/30 px-1 text-[9px]">
                    {shot.videoIterations}
                  </span>
                )}
              </div>
            )}
            {shot.status === 'failed' && (
              <div
                className="flex items-center gap-1.5 rounded-full bg-red-500/20 px-2 py-1 text-xs text-red-400 backdrop-blur-sm"
                title={shot.failureReason || ''}
              >
                <AlertCircle className="h-3 w-3" />
                Failed
              </div>
            )}
          </div>

          {/* Preview Content */}
          <div
            className={clsx(
              'aspect-video',
              shot.outputUrl && 'cursor-zoom-in'
            )}
            onClick={() => {
              if (shot.outputUrl) {
                setLightboxOpen('video');
                setLightboxZoom(1);
              }
            }}
          >
            {shot.outputUrl ? (
              <video
                src={resolveUrl(shot.outputUrl)}
                className="h-full w-full object-cover"
                controls={isHoveringPreview}
                muted
                loop
                playsInline
                onClick={(e) => e.stopPropagation()} // Allow video controls without triggering lightbox
                onMouseEnter={e => (e.target as HTMLVideoElement).play()}
                onMouseLeave={e => {
                  (e.target as HTMLVideoElement).pause();
                  (e.target as HTMLVideoElement).currentTime = 0;
                }}
              />
            ) : shot.firstFrameUrl ? (
              <img
                src={resolveUrl(shot.firstFrameUrl)}
                alt="Preview"
                className="h-full w-full object-cover opacity-60"
              />
            ) : (
              <div className="flex h-full w-full items-center justify-center">
                <Video className="h-16 w-16 text-gray-700" />
              </div>
            )}
          </div>
        </div>

        {/* Controls Bar */}
        <div className="flex items-end gap-3 border-t border-white/5 bg-black/40 px-4 py-3">
          {/* Duration */}
          <div>
            <div className="mb-1 flex items-center gap-1.5">
              <Clock className="h-3 w-3 text-blue-400" />
              <span className="text-[10px] font-medium uppercase tracking-wide text-blue-400">
                Duration
              </span>
            </div>
            <select
              value={shot.duration}
              onChange={e => onUpdate(shot.id, { duration: parseInt(e.target.value) || 5 })}
              className="w-[72px] appearance-none rounded-lg border border-white/10 bg-black/40 px-3 py-1.5 text-xs text-white transition-colors hover:border-blue-500/30 focus:border-blue-500/50 focus:outline-none"
            >
              {[3, 5, 7, 10, 15, 20, 30].map(d => (
                <option key={d} value={d} className="bg-[#1a1a1a]">
                  {d}s
                </option>
              ))}
            </select>
          </div>

          {/* Video Model + Resolution */}
          <div>
            {/* Header with label */}
            <div className="mb-1 flex items-center gap-1.5">
              <Video className="h-3 w-3 text-cyan-400" />
              <span className="text-[10px] font-medium uppercase tracking-wide text-cyan-400">
                Video Model
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Tooltip
                content={VIDEO_MODELS.find(m => m.id === (shot.videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video'))?.desc || ''}
                side="top"
              >
                <div className="relative">
                  <select
                    value={shot.videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video'}
                    onChange={e => onUpdate(shot.id, { videoModel: e.target.value })}
                    className="w-[160px] appearance-none rounded-lg border border-white/10 bg-black/40 px-2.5 py-1.5 pr-8 text-xs text-white transition-colors hover:border-cyan-500/30 focus:border-cyan-500/50 focus:outline-none"
                  >
                    {VIDEO_MODELS.map(model => (
                      <option key={model.id} value={model.id} className="bg-[#1a1a1a]">
                        {model.name}
                      </option>
                    ))}
                  </select>
                  <ChevronDown className="pointer-events-none absolute right-2 top-1/2 h-3.5 w-3.5 -translate-y-1/2 text-gray-500" />
                </div>
              </Tooltip>
              <div className="relative">
                <select
                  value={shot.videoResolution || '720p'}
                  onChange={e => onUpdate(shot.id, { videoResolution: e.target.value })}
                  className="appearance-none rounded-lg border border-white/10 bg-black/40 px-2.5 py-1.5 pr-7 text-xs text-white transition-colors hover:border-cyan-500/30 focus:border-cyan-500/50 focus:outline-none"
                >
                  {getVideoResolutions(shot.videoModel).map(res => (
                    <option key={res.id} value={res.id} className="bg-[#1a1a1a]">
                      {res.label}
                    </option>
                  ))}
                </select>
                <ChevronDown className="pointer-events-none absolute right-2 top-1/2 h-3.5 w-3.5 -translate-y-1/2 text-gray-500" />
              </div>
            </div>
          </div>

          {/* Spacer to push pricing + Generate button to right */}
          <div className="flex-1" />

          {/* Pricing */}
          <div className="flex items-end gap-1.5">
            {/* Per-video cost (emerald) */}
            <span className="pb-1.5 text-[10px] text-emerald-400/70">
              {estimateVideoCost(shot.videoModel, shot.videoResolution, shot.duration || 5)}
            </span>
            {/* Total spent (cyan) - only shows when iterations exist */}
            {(shot.videoIterations || 0) > 0 && (
              <span className="pb-1.5 text-[10px] text-cyan-400">
                 {formatCost(
                  (shot.videoIterations || 0) *
                  calculateVideoCost(shot.videoModel, shot.videoResolution, shot.duration || 5)
                )}
                <span className="ml-0.5 text-gray-500">
                  ({shot.videoIterations})
                </span>
              </span>
            )}
          </div>
        </div>

        {/* Per-Shot Cost Summary (only shows if iterations exist) */}
        {((shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0) + (shot.videoIterations || 0)) > 0 && (
          <div className="border-t border-white/5 bg-black/20 px-4 py-2">
            <div className="flex items-center justify-between text-[10px]">
              <span className="text-gray-500 uppercase">Shot Spend</span>
              <div className="flex items-center gap-3">
                {((shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)) > 0 && (
                  <span className="text-amber-400/80">
                    {(shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)} frames: {formatCost(
                      ((shot.firstFrameIterations || 0) + (shot.lastFrameIterations || 0)) *
                      calculateImageCost(shot.imageModel, shot.imageResolution)
                    )}
                  </span>
                )}
                {(shot.videoIterations || 0) > 0 && (
                  <span className="text-emerald-400/80">
                    {shot.videoIterations} video{(shot.videoIterations || 0) > 1 ? 's' : ''}: {formatCost(
                      (shot.videoIterations || 0) *
                      calculateVideoCost(shot.videoModel, shot.videoResolution, shot.duration || 5)
                    )}
                  </span>
                )}
                <span className="font-medium text-white">
                  = {formatCost(calculateTotalShotCost(shot).total)}
                </span>
              </div>
            </div>
          </div>
        )}

        {/* Prompt Area */}
        <div className="relative border-t border-white/5 px-4 py-3">
          {/* Header with label and Smart Prompt Builder button */}
          <div className="mb-1.5 flex items-center justify-between">
            <span className="text-[10px] font-medium uppercase tracking-wide text-cyan-400">
              Video Prompt
            </span>
            {onEnhanceVideoPrompt && shot.prompt && (
              <Tooltip content="Enhance with Smart Prompt Builder" side="top">
                <button
                  onClick={() => onEnhanceVideoPrompt(shot.id)}
                  className="rounded p-1 text-purple-400 transition-colors hover:bg-purple-500/10"
                >
                  <Sparkles className="h-3 w-3" />
                </button>
              </Tooltip>
            )}
          </div>
          {/* Collapsed display */}
          <div
            ref={shotTriggerRef}
            onClick={handleOpenShotPrompt}
            className={clsx(
              'min-h-[80px] w-full rounded-lg border px-3 py-2 text-sm transition-colors',
              shot.status === 'generating'
                ? 'cursor-not-allowed border-white/5 bg-black/10 text-gray-500'
                : 'cursor-pointer border-white/10 bg-black/20 text-white hover:border-cyan-500/30'
            )}
          >
            {shot.prompt ? (
              <span className="line-clamp-4">{shot.prompt}</span>
            ) : (
              <span className="text-gray-600">Click to describe the action in this shot...</span>
            )}
          </div>

          {/* Full-width Generate Video button */}
          {shot.prompt && shot.firstFrameUrl && !shot.outputUrl && !isGenerating && (
            <Tooltip content="Generate video from first frame and prompt" side="bottom">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onGenerate(shot.id);
                }}
                className="mt-2 flex w-full items-center justify-center gap-1.5 rounded-lg bg-cyan-500/20 py-2 text-xs font-medium text-cyan-400 transition-colors hover:bg-cyan-500/30"
              >
                <Sparkles className="h-3.5 w-3.5" />
                Generate Video
              </button>
            </Tooltip>
          )}
        </div>

        {/* Pop-out bubble via Portal - escapes overflow constraints */}
        {expandedPrompt === 'shot' && shotPopoutPosition && typeof document !== 'undefined' && createPortal(
          <div
            className="fixed z-[9999] w-[700px] animate-in fade-in zoom-in-95 duration-150"
            style={{ top: shotPopoutPosition.top, left: shotPopoutPosition.left }}
          >
            <div className="relative rounded-xl border border-cyan-500/50 bg-[#1a1a1a] p-3 shadow-2xl shadow-black/50">
              <div className="mb-2 flex items-center justify-between">
                <span className="text-xs font-medium uppercase tracking-wide text-cyan-400">
                  Shot Prompt
                </span>
                {/* Duration Dropdown */}
                <div className="flex items-center gap-2">
                  <label className="text-[10px] font-semibold tracking-wider text-gray-500 uppercase">
                    Duration
                  </label>
                  <select
                    value={shot.duration}
                    onChange={e => onUpdate(shot.id, { duration: parseInt(e.target.value) || 5 })}
                    onMouseDown={e => e.stopPropagation()}
                    className="appearance-none rounded-lg border border-white/10 bg-white/5 px-2 py-1 text-xs text-white focus:ring-2 focus:ring-cyan-500/50 focus:outline-none"
                  >
                    {[3, 5, 7, 10, 15, 20, 30].map(d => (
                      <option key={d} value={d} className="bg-[#1a1a1a]">
                        {d}s
                      </option>
                    ))}
                  </select>
                </div>
              </div>
              {/* Autocomplete popup above textarea */}
              <AutocompletePopup
                isOpen={shotAutocomplete.autocomplete.isOpen}
                items={shotAutocomplete.filteredItems}
                query={shotAutocomplete.autocomplete.query}
                triggerType={shotAutocomplete.autocomplete.triggerType}
                onSelect={shotAutocomplete.selectItem}
                onClose={shotAutocomplete.close}
                className="bottom-full left-0 right-0 mb-2"
              />
              <textarea
                autoFocus
                value={editingShotPrompt}
                onChange={shotAutocomplete.handleChange}
                onKeyDown={(e) => {
                  // Autocomplete gets priority when open
                  if (shotAutocomplete.autocomplete.isOpen) {
                    shotAutocomplete.handleKeyDown(e);
                    if (e.defaultPrevented) return;
                  }
                  // Then prompt weighting
                  shotPromptWeighting.handleKeyDown(e);
                }}
                onBlur={() => handlePromptBlur('shot')}
                placeholder="Describe the action in this shot... (use @element #prop $variable)"
                rows={Math.max(6, editingShotPrompt.split('\n').length + Math.ceil(editingShotPrompt.length / 90))}
                className="w-full resize-none rounded-lg border border-cyan-500/30 bg-black/60 px-3 py-2 text-sm text-white placeholder-gray-600 focus:border-cyan-500/50 focus:outline-none"
              />
            </div>
          </div>,
          document.body
        )}

        {/* Error Message */}
        {shot.failureReason && (
          <div className="border-t border-red-500/20 bg-red-500/10 px-4 py-2">
            <p className="text-xs text-red-400">{shot.failureReason}</p>
          </div>
        )}
      </div>
    </div>

    {/* Lightbox Modal */}
    {lightboxOpen && typeof document !== 'undefined' && createPortal(
      <div
        className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/90 backdrop-blur-sm"
        onClick={() => setLightboxOpen(null)}
      >
        {/* Header */}
        <div className="absolute top-4 left-4 right-4 z-10 flex items-center justify-between">
          {/* Title */}
          <div className="flex items-center gap-3">
            <span className={clsx(
              'rounded-full px-3 py-1 text-sm font-medium',
              lightboxOpen === 'first' && 'bg-green-500/20 text-green-400',
              lightboxOpen === 'last' && 'bg-purple-500/20 text-purple-400',
              lightboxOpen === 'video' && 'bg-cyan-500/20 text-cyan-400'
            )}>
              {lightboxOpen === 'first' && 'First Frame'}
              {lightboxOpen === 'last' && 'Last Frame'}
              {lightboxOpen === 'video' && 'Video'}
            </span>
            <span className="text-sm text-gray-400">Shot {shot.orderIndex + 1}</span>
          </div>

          {/* Controls */}
          <div className="flex items-center gap-2">
            {/* Zoom controls (images only) */}
            {lightboxOpen !== 'video' && (
              <>
                <Tooltip content="Zoom out" side="bottom">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setLightboxZoom(z => Math.max(0.5, z - 0.25));
                    }}
                    className="rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
                  >
                    <ZoomOut className="h-4 w-4" />
                  </button>
                </Tooltip>
                <span className="min-w-[3rem] text-center text-sm text-white">
                  {Math.round(lightboxZoom * 100)}%
                </span>
                <Tooltip content="Zoom in" side="bottom">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setLightboxZoom(z => Math.min(3, z + 0.25));
                    }}
                    className="rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
                  >
                    <ZoomIn className="h-4 w-4" />
                  </button>
                </Tooltip>
              </>
            )}

            {/* Download */}
            <Tooltip content="Download" side="bottom">
              <a
                href={resolveUrl(
                  lightboxOpen === 'first' ? shot.firstFrameUrl :
                  lightboxOpen === 'last' ? shot.lastFrameUrl :
                  shot.outputUrl
                )}
                download
                onClick={(e) => e.stopPropagation()}
                className="rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
              >
                <Download className="h-4 w-4" />
              </a>
            </Tooltip>

            {/* Replace/Upload */}
            <Tooltip content="Replace" side="bottom">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  if (lightboxOpen === 'first') {
                    firstFrameInputRef.current?.click();
                  } else if (lightboxOpen === 'last') {
                    lastFrameInputRef.current?.click();
                  }
                  setLightboxOpen(null);
                }}
                className={clsx(
                  'rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20',
                  lightboxOpen === 'video' && 'hidden'
                )}
              >
                <Upload className="h-4 w-4" />
              </button>
            </Tooltip>

            {/* Close */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                setLightboxOpen(null);
              }}
              className="rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>

        {/* Content */}
        <div
          className="flex max-h-[85vh] max-w-[90vw] items-center justify-center overflow-auto"
          onClick={(e) => e.stopPropagation()}
        >
          {lightboxOpen === 'video' ? (
            <video
              src={resolveUrl(shot.outputUrl)}
              className="max-h-[85vh] max-w-[90vw] rounded-lg"
              controls
              autoPlay
              loop
            />
          ) : (
            <img
              src={resolveUrl(lightboxOpen === 'first' ? shot.firstFrameUrl : shot.lastFrameUrl)}
              alt={lightboxOpen === 'first' ? 'First frame' : 'Last frame'}
              className="rounded-lg transition-transform duration-200"
              style={{ transform: `scale(${lightboxZoom})` }}
            />
          )}
        </div>

        {/* Keyboard hint */}
        <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-xs text-gray-500">
          Press <kbd className="rounded border border-gray-600 px-1.5 py-0.5">Esc</kbd> or click outside to close
        </div>
      </div>,
      document.body
    )}
    </TooltipProvider>
  );
}
</file>

<file path="frontend/src/components/generations/GenerationSearch.tsx">
'use client';

/**
 * GenerationSearch Component - Visual Librarian
 *
 * Professional search interface for finding generations using cinematic terminology.
 * Features:
 * - Smart suggestion pills based on indexed content
 * - Reality vs Intent search mode toggle
 * - Cinematic terminology recognition (ECU, Low-Key, Anamorphic, etc.)
 * - Sort and Filter controls
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import {
  Search,
  X,
  Loader2,
  Eye,
  Wand2,
  SlidersHorizontal,
  AlertTriangle,
  SortAsc,
  SortDesc,
  Image,
  Film,
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import clsx from 'clsx';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';

interface IndexStats {
  total: number;
  indexed: number;
  pending: number;
  failed: number;
}

interface SuggestionPill {
  label: string;
  category: string;
  count: number;
}

type SearchMode = 'combined' | 'reality' | 'intent';
type SortBy = 'date' | 'score' | 'name';
type SortOrder = 'asc' | 'desc';

export interface GenerationSortFilterState {
  sortBy: SortBy;
  sortOrder: SortOrder;
  filterMediaType: ('image' | 'video')[];
  filterStatus: ('succeeded' | 'failed' | 'processing')[];
  filterAspectRatio: string[];
}

interface GenerationSearchProps {
  projectId: string;
  onSearchResults: (results: any[], query: string) => void;
  onClearSearch: () => void;
  onSelectAll?: () => void;
  onSortFilterChange?: (state: GenerationSortFilterState) => void;
}

export function GenerationSearch({
  projectId,
  onSearchResults,
  onClearSearch,
  onSelectAll,
  onSortFilterChange,
}: GenerationSearchProps) {
  const [query, setQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [isIndexing, setIsIndexing] = useState(false);
  const [stats, setStats] = useState<IndexStats | null>(null);
  const [suggestions, setSuggestions] = useState<SuggestionPill[]>([]);
  const [searchMode, setSearchMode] = useState<SearchMode>('combined');
  const inputRef = useRef<HTMLInputElement>(null);
  const debounceRef = useRef<NodeJS.Timeout | null>(null);

  // Sort & Filter State
  const [isSortOpen, setIsSortOpen] = useState(false);
  const [isFilterOpen, setIsFilterOpen] = useState(false);
  const [sortFilter, setSortFilter] = useState<GenerationSortFilterState>({
    sortBy: 'date',
    sortOrder: 'desc',
    filterMediaType: [],
    filterStatus: [],
    filterAspectRatio: [],
  });

  // Notify parent when sort/filter changes
  const updateSortFilter = (updates: Partial<GenerationSortFilterState>) => {
    const newState = { ...sortFilter, ...updates };
    setSortFilter(newState);
    onSortFilterChange?.(newState);
  };

  const toggleFilter = <K extends keyof GenerationSortFilterState>(
    category: K,
    value: GenerationSortFilterState[K] extends (infer U)[] ? U : never
  ) => {
    const current = sortFilter[category] as any[];
    const updated = current.includes(value)
      ? current.filter((item: any) => item !== value)
      : [...current, value];
    updateSortFilter({ [category]: updated } as Partial<GenerationSortFilterState>);
  };

  const activeFilterCount =
    sortFilter.filterMediaType.length +
    sortFilter.filterStatus.length +
    sortFilter.filterAspectRatio.length;

  // Load index stats and suggestions on mount
  useEffect(() => {
    fetchStats();
    fetchSuggestions();
  }, [projectId]);

  const fetchSuggestions = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/search/suggestions`);
      if (res.ok) {
        const data = await res.json();
        setSuggestions(data.suggestions || []);
      }
    } catch (err) {
      console.error('Failed to fetch suggestions:', err);
    }
  };

  const fetchStats = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/search/stats`);
      if (res.ok) {
        const data = await res.json();
        setStats(data);
      }
    } catch (err) {
      console.error('Failed to fetch index stats:', err);
    }
  };

  const performSearch = useCallback(
    async (searchQuery: string) => {
      if (!searchQuery.trim() || searchQuery.length < 2) {
        onClearSearch();
        return;
      }

      setIsSearching(true);
      try {
        // Build URL based on search mode
        let url: string;
        if (searchMode === 'reality') {
          url = `${BACKEND_URL}/api/projects/${projectId}/search/reality?q=${encodeURIComponent(searchQuery)}&limit=100`;
        } else if (searchMode === 'intent') {
          url = `${BACKEND_URL}/api/projects/${projectId}/search/intent?q=${encodeURIComponent(searchQuery)}&limit=100`;
        } else {
          url = `${BACKEND_URL}/api/projects/${projectId}/search?q=${encodeURIComponent(searchQuery)}&limit=100`;
        }

        const res = await fetch(url);
        if (res.ok) {
          const data = await res.json();
          onSearchResults(data.results, searchQuery);
        }
      } catch (err) {
        console.error('Search failed:', err);
      } finally {
        setIsSearching(false);
      }
    },
    [projectId, onSearchResults, onClearSearch, searchMode]
  );

  // Debounced search as user types
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setQuery(value);

    if (debounceRef.current) {
      clearTimeout(debounceRef.current);
    }

    if (value.length === 0) {
      onClearSearch();
      return;
    }

    debounceRef.current = setTimeout(() => {
      performSearch(value);
    }, 400);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
      }
      performSearch(query);
    } else if (e.key === 'Escape') {
      handleClear();
    }
  };

  const handleClear = () => {
    setQuery('');
    onClearSearch();
    inputRef.current?.focus();
  };

  const handlePillClick = (label: string) => {
    setQuery(label);
    performSearch(label);
  };

  const handleBatchIndex = async () => {
    setIsIndexing(true);
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/search/index`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ batchSize: 20 }),
      });
      if (res.ok) {
        await fetchStats();
        await fetchSuggestions();
      }
    } catch (err) {
      console.error('Batch index failed:', err);
    } finally {
      setIsIndexing(false);
    }
  };

  const indexPercentage = stats ? Math.round((stats.indexed / Math.max(stats.total, 1)) * 100) : 0;

  return (
    <TooltipProvider>
    <div className="space-y-2">
      {/* Row 1: Generate title + Search Bar + Index Badge + Sort + Filter */}
      <div className="flex items-center gap-4">
        {/* Generate Title - fixed width to ensure Row 2 alignment */}
        <h1 className="w-[141px] shrink-0 text-3xl font-bold tracking-tight">Generate</h1>

        {/* Search Input - Takes remaining space */}
        <div className="relative min-w-0 flex-1">
          <div className="absolute top-1/2 left-3 -translate-y-1/2 text-white/40">
            {isSearching ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Search className="h-4 w-4" />
            )}
          </div>

          <input
            ref={inputRef}
            type="text"
            value={query}
            onChange={handleInputChange}
            onKeyDown={handleKeyDown}
            placeholder="Search... (e.g., 'ECU shallow depth neon')"
            className="w-full rounded-lg border border-white/10 bg-zinc-900/80 py-2 pr-10 pl-10 text-sm text-white placeholder-white/40 transition-all focus:border-white/20 focus:outline-none"
          />

          {query && (
            <button
              onClick={handleClear}
              className="absolute top-1/2 right-3 -translate-y-1/2 text-white/40 transition-colors hover:text-white"
            >
              <X className="h-4 w-4" />
            </button>
          )}
        </div>

        {/* Index Status Badge - Black/white box with colored icon */}
        <Tooltip
          content={
            isIndexing
              ? 'Indexing...'
              : stats
                ? `${stats.indexed}/${stats.total} indexed${stats.failed > 0 ? `, ${stats.failed} failed` : ''}. Click to index remaining.`
                : 'Loading...'
          }
          side="top"
        >
          <button
            onClick={handleBatchIndex}
            disabled={isIndexing}
            className="flex shrink-0 items-center gap-1.5 rounded-lg border border-white/20 bg-white/5 px-3 py-1.5 text-sm font-medium text-white/70 transition-colors hover:bg-white/10 hover:text-white"
          >
            {isIndexing ? (
              <Loader2 className="h-3.5 w-3.5 animate-spin text-white/70" />
            ) : stats && stats.failed > 0 ? (
              <AlertTriangle className="h-3.5 w-3.5 text-red-400" />
            ) : indexPercentage === 100 ? (
              <AlertTriangle className="h-3.5 w-3.5 text-green-400" />
            ) : (
              <AlertTriangle className="h-3.5 w-3.5 text-amber-400" />
            )}
            {indexPercentage}%
          </button>
        </Tooltip>

        {/* Sort & Filter Button Group - gap-2 for tighter spacing */}
        <div className="flex shrink-0 items-center gap-2">
        {/* Sort Button with Dropdown */}
        <div className="relative">
          <button
            onClick={() => setIsSortOpen(!isSortOpen)}
            className="flex min-w-[90px] shrink-0 items-center justify-center gap-1.5 whitespace-nowrap rounded-lg border border-white/10 bg-zinc-900/80 px-3 py-1.5 text-sm text-white/70 transition-colors hover:bg-white/5 hover:text-white"
          >
            {sortFilter.sortOrder === 'asc' ? (
              <SortAsc className="h-3.5 w-3.5" />
            ) : (
              <SortDesc className="h-3.5 w-3.5" />
            )}
            Sort
          </button>

          <AnimatePresence>
            {isSortOpen && (
              <>
                <div className="fixed inset-0 z-40" onClick={() => setIsSortOpen(false)} />
                <motion.div
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 10 }}
                  onClick={(e) => e.stopPropagation()}
                  className="absolute top-full right-0 z-50 mt-2 flex w-64 flex-col overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a] shadow-xl"
                >
                  <div className="flex items-center justify-between border-b border-white/10 p-3">
                    <span className="text-sm font-bold text-white">Sort</span>
                  </div>
                  <div className="space-y-4 overflow-y-auto p-2">
                    {/* Sort By */}
                    <div>
                      <div className="mb-1 px-2 py-1 text-xs font-bold uppercase tracking-wider text-gray-500">
                        Sort By
                      </div>
                      <div className="space-y-1">
                        {[
                          { label: 'Date', value: 'date' },
                          { label: 'Relevance', value: 'score' },
                          { label: 'Name', value: 'name' },
                        ].map(opt => (
                          <label
                            key={opt.value}
                            className="flex cursor-pointer items-center gap-2 rounded-lg px-2 py-1.5 hover:bg-white/5"
                          >
                            <input
                              type="checkbox"
                              checked={sortFilter.sortBy === opt.value}
                              onChange={() => updateSortFilter({ sortBy: opt.value as SortBy })}
                              className="rounded border-white/20 bg-black/50 text-blue-500 focus:ring-blue-500/50"
                            />
                            <span className={clsx('text-sm', sortFilter.sortBy === opt.value ? 'text-blue-400' : 'text-gray-300')}>
                              {opt.label}
                            </span>
                          </label>
                        ))}
                      </div>
                    </div>

                    {/* Order */}
                    <div>
                      <div className="mb-1 px-2 py-1 text-xs font-bold uppercase tracking-wider text-gray-500">
                        Order
                      </div>
                      <div className="space-y-1">
                        {[
                          { label: 'Newest First', value: 'desc' },
                          { label: 'Oldest First', value: 'asc' },
                        ].map(opt => (
                          <label
                            key={opt.value}
                            className="flex cursor-pointer items-center gap-2 rounded-lg px-2 py-1.5 hover:bg-white/5"
                          >
                            <input
                              type="checkbox"
                              checked={sortFilter.sortOrder === opt.value}
                              onChange={() => updateSortFilter({ sortOrder: opt.value as SortOrder })}
                              className="rounded border-white/20 bg-black/50 text-blue-500 focus:ring-blue-500/50"
                            />
                            <span className={clsx('text-sm', sortFilter.sortOrder === opt.value ? 'text-blue-400' : 'text-gray-300')}>
                              {opt.label}
                            </span>
                          </label>
                        ))}
                      </div>
                    </div>
                  </div>
                </motion.div>
              </>
            )}
          </AnimatePresence>
        </div>

        {/* Filter Button with Dropdown */}
        <div className="relative">
          <button
            onClick={() => setIsFilterOpen(!isFilterOpen)}
            className={clsx(
              'flex min-w-[90px] shrink-0 items-center justify-center gap-1.5 whitespace-nowrap rounded-lg border px-3 py-1.5 text-sm transition-colors',
              activeFilterCount > 0
                ? 'border-blue-500/50 bg-blue-500/20 text-blue-400'
                : 'border-white/10 bg-zinc-900/80 text-white/70 hover:bg-white/5 hover:text-white'
            )}
          >
            <SlidersHorizontal className="h-3.5 w-3.5" />
            Filter
            {activeFilterCount > 0 && (
              <span className="rounded-full bg-blue-500 px-1.5 text-[10px] text-white">
                {activeFilterCount}
              </span>
            )}
          </button>

          <AnimatePresence>
            {isFilterOpen && (
              <>
                <div className="fixed inset-0 z-40" onClick={() => setIsFilterOpen(false)} />
                <motion.div
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 10 }}
                  onClick={(e) => e.stopPropagation()}
                  className="absolute top-full right-0 z-50 mt-2 flex max-h-[80vh] w-64 flex-col overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a] shadow-xl"
                >
                  <div className="flex items-center justify-between border-b border-white/10 p-3">
                    <span className="text-sm font-bold text-white">Filters</span>
                    {activeFilterCount > 0 && (
                      <button
                        onClick={() =>
                          updateSortFilter({
                            filterMediaType: [],
                            filterStatus: [],
                            filterAspectRatio: [],
                          })
                        }
                        className="text-xs text-red-400 hover:text-red-300"
                      >
                        Clear All
                      </button>
                    )}
                  </div>
                  <div className="space-y-4 overflow-y-auto p-2">
                    {/* Media Type */}
                    <div>
                      <div className="mb-1 px-2 py-1 text-xs font-bold uppercase tracking-wider text-gray-500">
                        Media Type
                      </div>
                      <div className="space-y-1">
                        {[
                          { value: 'image', label: 'Images', icon: Image },
                          { value: 'video', label: 'Videos', icon: Film },
                        ].map(opt => (
                          <label
                            key={opt.value}
                            className="flex cursor-pointer items-center gap-2 rounded-lg px-2 py-1.5 hover:bg-white/5"
                          >
                            <input
                              type="checkbox"
                              checked={sortFilter.filterMediaType.includes(opt.value as 'image' | 'video')}
                              onChange={() => toggleFilter('filterMediaType', opt.value as 'image' | 'video')}
                              className="rounded border-white/20 bg-black/50 text-blue-500 focus:ring-blue-500/50"
                            />
                            <opt.icon className="h-3.5 w-3.5 text-gray-400" />
                            <span className="text-sm text-gray-300">{opt.label}</span>
                          </label>
                        ))}
                      </div>
                    </div>

                    {/* Status */}
                    <div>
                      <div className="mb-1 px-2 py-1 text-xs font-bold uppercase tracking-wider text-gray-500">
                        Status
                      </div>
                      <div className="space-y-1">
                        {[
                          { value: 'succeeded', label: 'Completed', color: 'text-green-400' },
                          { value: 'processing', label: 'Processing', color: 'text-amber-400' },
                          { value: 'failed', label: 'Failed', color: 'text-red-400' },
                        ].map(opt => (
                          <label
                            key={opt.value}
                            className="flex cursor-pointer items-center gap-2 rounded-lg px-2 py-1.5 hover:bg-white/5"
                          >
                            <input
                              type="checkbox"
                              checked={sortFilter.filterStatus.includes(opt.value as any)}
                              onChange={() => toggleFilter('filterStatus', opt.value as any)}
                              className="rounded border-white/20 bg-black/50 text-blue-500 focus:ring-blue-500/50"
                            />
                            <span className={clsx('text-sm', opt.color)}>{opt.label}</span>
                          </label>
                        ))}
                      </div>
                    </div>

                    {/* Aspect Ratio */}
                    <div>
                      <div className="mb-1 px-2 py-1 text-xs font-bold uppercase tracking-wider text-gray-500">
                        Aspect Ratio
                      </div>
                      <div className="space-y-1">
                        {['16:9', '9:16', '1:1', '21:9', '4:3'].map(ratio => (
                          <label
                            key={ratio}
                            className="flex cursor-pointer items-center gap-2 rounded-lg px-2 py-1.5 hover:bg-white/5"
                          >
                            <input
                              type="checkbox"
                              checked={sortFilter.filterAspectRatio.includes(ratio)}
                              onChange={() => toggleFilter('filterAspectRatio', ratio)}
                              className="rounded border-white/20 bg-black/50 text-blue-500 focus:ring-blue-500/50"
                            />
                            <span className="text-sm text-gray-300">{ratio}</span>
                          </label>
                        ))}
                      </div>
                    </div>
                  </div>
                </motion.div>
              </>
            )}
          </AnimatePresence>
        </div>
        </div>
      </div>

      {/* Row 2: Reality/Both/Intent Toggle + Suggestion Pills + Select All */}
      {/* Uses same structure as Row 1: invisible spacer (141px) + gap (16px) = 157px offset */}
      <div className="flex items-center gap-4">
        {/* Invisible spacer matching title width */}
        <div className="w-[141px] shrink-0" />
        {/* Actual Row 2 content */}
        <div className="flex min-w-0 flex-1 items-center gap-2">
        {/* Reality / Both / Intent Toggle */}
        <div className="flex shrink-0 items-center rounded-lg border border-white/10 bg-zinc-900/80 p-0.5">
          <Tooltip content="Search what AI actually generated (visual analysis)" side="top">
            <button
              onClick={() => setSearchMode('reality')}
              className={clsx(
                'flex items-center gap-1 rounded-md px-2 py-1 text-xs font-medium transition-colors',
                searchMode === 'reality'
                  ? 'bg-white/10 text-white'
                  : 'text-white/50 hover:text-white/80'
              )}
            >
              <Eye className="h-3 w-3" />
              Reality
            </button>
          </Tooltip>
          <Tooltip content="Search both visual content and prompts" side="top">
            <button
              onClick={() => setSearchMode('combined')}
              className={clsx(
                'rounded-md px-2 py-1 text-xs font-medium transition-colors',
                searchMode === 'combined'
                  ? 'bg-white/10 text-white'
                  : 'text-white/50 hover:text-white/80'
              )}
            >
              Both
            </button>
          </Tooltip>
          <Tooltip content="Search what you prompted (user intent)" side="top">
            <button
              onClick={() => setSearchMode('intent')}
              className={clsx(
                'flex items-center gap-1 rounded-md px-2 py-1 text-xs font-medium transition-colors',
                searchMode === 'intent'
                  ? 'bg-white/10 text-white'
                  : 'text-white/50 hover:text-white/80'
              )}
            >
              <Wand2 className="h-3 w-3" />
              Intent
            </button>
          </Tooltip>
        </div>

        {/* Suggestion Pills - Same height as Reality/Both/Intent toggle */}
        <div className="flex min-w-0 flex-1 items-center gap-1 overflow-x-auto scrollbar-hide">
          {suggestions.slice(0, 8).map((pill, i) => (
            <button
              key={i}
              onClick={() => handlePillClick(pill.label)}
              className="shrink-0 rounded-md border border-white/20 bg-white/5 px-2 py-1 text-xs font-medium text-white/70 transition-colors hover:border-amber-500/50 hover:bg-amber-500/10 hover:text-amber-400"
            >
              {pill.label}
            </button>
          ))}
        </div>

        {/* Select All Button - Same size as Sort/Filter buttons */}
        {onSelectAll && (
          <button
            onClick={onSelectAll}
            className="flex min-w-[90px] shrink-0 items-center justify-center gap-1.5 whitespace-nowrap rounded-lg border border-sky-500/30 bg-sky-500/10 px-3 py-1.5 text-sm text-sky-400 transition-colors hover:bg-sky-500/20"
          >
            Select All
          </button>
        )}
        </div>
      </div>
    </div>
    </TooltipProvider>
  );
}
</file>

<file path="frontend/src/components/generations/ParameterManager.tsx">
import { useState, useEffect } from 'react';
import { fetchAPI } from '@/lib/api';
import { Plus, Trash2, Check, Settings2 } from 'lucide-react';
import { clsx } from 'clsx';

interface ModelParameter {
  id: string;
  type: 'sampler' | 'scheduler';
  name: string;
  value: string;
}

interface ParameterManagerProps {
  projectId: string;
  type: 'sampler' | 'scheduler';
  isOpen: boolean;
  onClose: () => void;
  selectedId?: string;
  onSelect?: (parameter: ModelParameter | null) => void;
  embedded?: boolean;
}

export function ParameterManager({
  projectId,
  type,
  isOpen,
  onClose,
  selectedId,
  onSelect,
  embedded = false,
}: ParameterManagerProps) {
  const [parameters, setParameters] = useState<ModelParameter[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isAdding, setIsAdding] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Form State
  const [name, setName] = useState('');
  const [value, setValue] = useState('');

  const COMMON_PRESETS = {
    sampler: [
      { name: 'Euler a', value: 'euler_a' },
      { name: 'Euler', value: 'euler' },
      { name: 'DPM++ 2M Karras', value: 'dpmpp_2m_karras' },
      { name: 'DPM++ SDE Karras', value: 'dpmpp_sde_karras' },
      { name: 'DDIM', value: 'ddim' },
      { name: 'Flow Match Euler', value: 'flow_match_euler' },
    ],
    scheduler: [
      { name: 'Simple', value: 'simple' },
      { name: 'Karras', value: 'karras' },
      { name: 'SGM Uniform', value: 'sgm_uniform' },
      { name: 'Beta', value: 'beta' },
      { name: 'Linear', value: 'linear' },
    ],
  };

  useEffect(() => {
    if (isOpen) {
      loadParameters();
    }
  }, [isOpen, projectId, type]);

  const loadParameters = async () => {
    try {
      const data = await fetchAPI(`/projects/${projectId}/parameters?type=${type}`);
      setParameters(data);
    } catch (err) {
      console.error('Failed to load parameters', err);
    }
  };

  const handleAdd = async (presetName?: string, presetValue?: string) => {
    const nameToSend = presetName || name;
    const valueToSend = presetValue || value;

    if (!nameToSend || !valueToSend) return;

    try {
      await fetchAPI(`/projects/${projectId}/parameters`, {
        method: 'POST',
        body: JSON.stringify({
          type,
          name: nameToSend,
          value: valueToSend,
        }),
      });
      setName('');
      setValue('');
      setIsAdding(false);
      loadParameters();
    } catch (err: any) {
      console.error('Failed to create parameter', err);
      setError(err.message || `Failed to add ${type}`);
    }
  };

  const handleDelete = async (id: string, e: React.MouseEvent) => {
    e.stopPropagation();
    if (!confirm(`Are you sure you want to remove this ${type}?`)) return;
    try {
      await fetchAPI(`/projects/${projectId}/parameters/${id}`, {
        method: 'DELETE',
      });
      loadParameters();
      if (selectedId === id && onSelect) {
        onSelect(null);
      }
    } catch (err) {
      console.error(`Failed to delete ${type}`, err);
    }
  };

  if (!isOpen) return null;

  const content = (
    <div
      className={clsx(
        'flex flex-col overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a] shadow-2xl',
        embedded
          ? 'h-full max-h-full w-full max-w-[400px] min-w-[300px]'
          : 'max-h-[85vh] w-full max-w-4xl'
      )}
    >
      <div className="flex items-center justify-between border-b border-white/10 p-4">
        <h2 className="text-lg font-bold text-white capitalize">{type}s</h2>
        {!embedded && (
          <button onClick={onClose} className="text-gray-400 hover:text-white">
            
          </button>
        )}
      </div>

      <div className="show-scrollbar-on-hover flex-1 overflow-y-auto p-4">
        {isAdding ? (
          <div className="space-y-4 rounded-xl border border-white/10 bg-white/5 p-4">
            <h3 className="text-sm font-medium text-white">
              Add New {type === 'sampler' ? 'Sampler' : 'Scheduler'}
            </h3>

            <div className="space-y-3">
              <div>
                <label className="mb-1 block text-xs text-gray-400">Name</label>
                <input
                  type="text"
                  value={name}
                  onChange={e => setName(e.target.value)}
                  placeholder={type === 'sampler' ? 'e.g. DPM++ 2M Karras' : 'e.g. Karras'}
                  className="w-full rounded-lg border border-white/10 bg-black/50 px-3 py-2 text-sm text-white outline-none focus:border-blue-500"
                />
              </div>
              <div>
                <label className="mb-1 block text-xs text-gray-400">API Value</label>
                <input
                  type="text"
                  value={value}
                  onChange={e => setValue(e.target.value)}
                  placeholder={type === 'sampler' ? 'e.g. dpmpp_2m_karras' : 'e.g. karras'}
                  className="w-full rounded-lg border border-white/10 bg-black/50 px-3 py-2 font-mono text-sm text-white outline-none focus:border-blue-500"
                />
              </div>
            </div>

            {error && <div className="px-1 text-xs text-red-400">{error}</div>}

            <div className="flex justify-end gap-2 pt-2">
              <button
                onClick={() => setIsAdding(false)}
                className="px-3 py-1.5 text-xs text-gray-400 hover:text-white"
              >
                Cancel
              </button>
              <button
                onClick={() => handleAdd()}
                disabled={!name || !value}
                className="rounded-lg bg-blue-600 px-3 py-1.5 text-xs font-medium text-white hover:bg-blue-500 disabled:opacity-50"
              >
                Add
              </button>
            </div>
          </div>
        ) : (
          <div className="space-y-3">
            <button
              onClick={() => setIsAdding(true)}
              className="flex w-full items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 py-2 text-sm text-gray-400 transition-all hover:border-white/40 hover:bg-white/5 hover:text-white"
            >
              <Plus className="h-4 w-4" />
              Add New {type === 'sampler' ? 'Sampler' : 'Scheduler'}
            </button>

            {/* Quick Add Presets */}
            <div className="mb-4 border-b border-white/10 pb-4">
              <p className="mb-2 text-[10px] font-bold tracking-wider text-gray-500 uppercase">
                Quick Add Popular
              </p>
              <div className="flex flex-wrap gap-2">
                {COMMON_PRESETS[type].map(preset => {
                  const isAdded = parameters.some(p => p.value === preset.value);
                  return (
                    <button
                      key={preset.value}
                      onClick={() => !isAdded && handleAdd(preset.name, preset.value)}
                      disabled={isAdded}
                      className={clsx(
                        'rounded border px-2 py-1 text-xs transition-colors',
                        isAdded
                          ? 'cursor-default border-blue-500/50 bg-blue-500/20 text-blue-300'
                          : 'border-white/10 bg-white/5 text-gray-300 hover:bg-white/10 hover:text-white'
                      )}
                    >
                      {isAdded ? ' ' : '+ '}
                      {preset.name}
                    </button>
                  );
                })}
              </div>
            </div>

            <div className="space-y-2">
              {parameters.map((param, index) => {
                const isSelected = selectedId === param.id;
                return (
                  <div
                    key={param.id || `param-${index}`}
                    className={clsx(
                      'flex cursor-pointer items-center justify-between rounded-lg border p-3 transition-colors',
                      isSelected
                        ? 'border-blue-500/50 bg-blue-500/10'
                        : 'border-white/5 bg-white/5 hover:border-white/10'
                    )}
                    onClick={() => onSelect && onSelect(isSelected ? null : param)}
                  >
                    <div className="flex items-center gap-3 overflow-hidden">
                      <div
                        className={clsx(
                          'flex h-8 w-8 flex-shrink-0 items-center justify-center rounded border',
                          isSelected
                            ? 'border-blue-400 bg-blue-500 text-white'
                            : 'border-white/10 bg-white/5 text-gray-500'
                        )}
                      >
                        {isSelected ? (
                          <Check className="h-4 w-4" />
                        ) : (
                          <Settings2 className="h-4 w-4" />
                        )}
                      </div>
                      <div className="min-w-0">
                        <h4
                          className={clsx(
                            'truncate text-sm font-medium',
                            isSelected ? 'text-blue-200' : 'text-white'
                          )}
                        >
                          {param.name}
                        </h4>
                        <div className="truncate font-mono text-[10px] text-gray-500">
                          {param.value}
                        </div>
                      </div>
                    </div>
                    <button
                      onClick={e => handleDelete(param.id, e)}
                      className="p-1.5 text-gray-500 transition-colors hover:text-red-400"
                    >
                      <Trash2 className="h-3 w-3" />
                    </button>
                  </div>
                );
              })}
              {parameters.length === 0 && !isLoading && (
                <p className="py-4 text-center text-xs text-gray-500">No {type}s added yet.</p>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );

  if (embedded) {
    return content;
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
      {content}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/RenderQueuePanel.tsx">
/**
 * Render Queue Panel
 *
 * Multi-pass rendering controls for draft  review  master workflow.
 * Shows cost savings and allows quality tier selection.
 */

import { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import {
  Play,
  Pause,
  RotateCcw,
  CheckCircle,
  AlertCircle,
  Clock,
  DollarSign,
  Zap,
  Star,
  Crown,
  ChevronUp,
  ChevronDown,
  TrendingDown,
  Loader2,
  ArrowUpCircle,
  Layers,
  SplitSquareHorizontal,
  Film,
  Eye,
  CheckCheck,
  Archive,
} from 'lucide-react';
import { ABLightbox } from './ABLightbox';
import { BACKEND_URL } from '@/lib/api';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';

type RenderQuality = 'draft' | 'review' | 'master';
type RenderPassStatus = 'pending' | 'queued' | 'generating' | 'complete' | 'failed' | 'skipped';

interface QualityPreset {
  id: string;
  name: string;
  quality: RenderQuality;
  description: string;
  imageModel: string;
  videoModel: string;
  imageCost: number;
  videoCost: number;
  estimatedTimeImage: number;
  estimatedTimeVideo: number;
}

interface RenderPass {
  id: string;
  shotId: string;
  quality: RenderQuality;
  orderIndex: number;
  status: RenderPassStatus;
  outputUrl?: string;
  actualCost?: number;
}

interface RenderJob {
  id: string;
  sceneChainId: string;
  projectId: string;
  name: string;
  targetQualities: RenderQuality[];
  activeQuality: RenderQuality;
  totalPasses: number;
  completedPasses: number;
  failedPasses: number;
  estimatedCost: number;
  actualCost: number;
  status: 'pending' | 'rendering' | 'paused' | 'complete' | 'failed';
  passes: RenderPass[];
}

interface CostComparison {
  draftCost: number;
  masterCost: number;
  savings: number;
  savingsPercent: number;
}

interface VersionStack {
  shotId: string;
  shotName: string;
  versions: Array<{
    passId: string;
    quality: RenderQuality;
    status: RenderPassStatus;
    outputUrl?: string;
    thumbnailUrl?: string;
    seed?: number;
    model: string;
    cost?: number;
    createdAt: string;
  }>;
  activeVersion: RenderQuality;
  canUpgrade: boolean;
  nextUpgradeQuality?: RenderQuality;
  upgradeCost?: number;
}

interface RenderQueuePanelProps {
  projectId: string;
  sceneChainId: string;
  shotCount: number;
  onRenderComplete?: (quality: RenderQuality, outputs: string[]) => void;
}

const QUALITY_ICONS: Record<RenderQuality, React.ReactNode> = {
  draft: <Zap className="h-4 w-4" />,
  review: <Star className="h-4 w-4" />,
  master: <Crown className="h-4 w-4" />,
};

const QUALITY_COLORS: Record<RenderQuality, string> = {
  draft: 'text-amber-400 bg-amber-500/20 border-amber-500/30',
  review: 'text-blue-400 bg-blue-500/20 border-blue-500/30',
  master: 'text-purple-400 bg-purple-500/20 border-purple-500/30',
};

const STATUS_COLORS: Record<RenderPassStatus, string> = {
  pending: 'text-gray-400',
  queued: 'text-yellow-400',
  generating: 'text-blue-400',
  complete: 'text-green-400',
  failed: 'text-red-400',
  skipped: 'text-gray-500',
};

export function RenderQueuePanel({
  projectId,
  sceneChainId,
  shotCount,
  onRenderComplete,
}: RenderQueuePanelProps) {
  const [isExpanded, setIsExpanded] = useState(true);
  const [presets, setPresets] = useState<Record<RenderQuality, QualityPreset> | null>(null);
  const [selectedQualities, setSelectedQualities] = useState<RenderQuality[]>(['draft']);
  const [currentJob, setCurrentJob] = useState<RenderJob | null>(null);
  const [costComparison, setCostComparison] = useState<CostComparison | null>(null);
  const [versionStacks, setVersionStacks] = useState<VersionStack[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [promotingShot, setPromotingShot] = useState<string | null>(null);
  const [showLightbox, setShowLightbox] = useState(false);
  const [lightboxShotId, setLightboxShotId] = useState<string | undefined>(undefined);
  const [burnInMetadata, setBurnInMetadata] = useState(false); // Refinement C: Watermark toggle
  const [approvedShots, setApprovedShots] = useState<Set<string>>(new Set()); // Shots with approved masters
  const [pendingReviewShots, setPendingReviewShots] = useState<Set<string>>(new Set()); // Shots awaiting review

  // Fetch presets on mount
  useEffect(() => {
    fetchPresets();
    fetchCostComparison();
    fetchVersionStacks();
  }, [projectId, shotCount, sceneChainId]);

  // Poll job status when rendering
  useEffect(() => {
    if (!currentJob || currentJob.status === 'complete' || currentJob.status === 'failed') {
      return;
    }

    const poll = setInterval(() => {
      fetchJobStatus(currentJob.id);
    }, 2000);

    return () => clearInterval(poll);
  }, [currentJob?.id, currentJob?.status]);

  const fetchPresets = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/render-queue/presets`);
      if (res.ok) {
        const data = await res.json();
        setPresets(data.presets);
      }
    } catch (error) {
      console.error('Failed to fetch presets:', error);
    }
  };

  const fetchCostComparison = async () => {
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/cost-comparison?shots=${shotCount}&iterations=3`
      );
      if (res.ok) {
        const data = await res.json();
        setCostComparison(data);
      }
    } catch (error) {
      console.error('Failed to fetch cost comparison:', error);
    }
  };

  const fetchVersionStacks = async () => {
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/scene-chains/${sceneChainId}/version-stacks`
      );
      if (res.ok) {
        const data = await res.json();
        setVersionStacks(data);
      }
    } catch (error) {
      console.error('Failed to fetch version stacks:', error);
    }
  };

  const handlePromoteShot = async (shotId: string, targetQuality: RenderQuality) => {
    if (!currentJob) return;
    setPromotingShot(shotId);

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${currentJob.id}/shots/${shotId}/promote`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ quality: targetQuality }),
        }
      );
      if (res.ok) {
        // Refresh job and version stacks
        await fetchJobStatus(currentJob.id);
        await fetchVersionStacks();
      }
    } catch (error) {
      console.error('Failed to promote shot:', error);
    } finally {
      setPromotingShot(null);
    }
  };

  const fetchJobStatus = async (jobId: string) => {
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${jobId}`
      );
      if (res.ok) {
        const job = await res.json();
        setCurrentJob(job);

        if (job.status === 'complete' && onRenderComplete) {
          const completedOutputs = job.passes
            .filter((p: RenderPass) => p.status === 'complete' && p.outputUrl)
            .map((p: RenderPass) => p.outputUrl!);
          onRenderComplete(job.activeQuality, completedOutputs);
        }
      }
    } catch (error) {
      console.error('Failed to fetch job status:', error);
    }
  };

  const handleStartRender = async () => {
    if (selectedQualities.length === 0) return;
    setIsLoading(true);

    try {
      // Create job
      const createRes = await fetch(`${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sceneChainId,
          qualities: selectedQualities,
          burnInMetadata, // Refinement C: Pass watermark option
        }),
      });

      if (!createRes.ok) {
        throw new Error('Failed to create render job');
      }

      const job = await createRes.json();

      // Start job
      const startRes = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${job.id}/start`,
        { method: 'POST' }
      );

      if (!startRes.ok) {
        throw new Error('Failed to start render job');
      }

      const startedJob = await startRes.json();
      setCurrentJob(startedJob);
    } catch (error) {
      console.error('Failed to start render:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handlePauseResume = async () => {
    if (!currentJob) return;

    const endpoint = currentJob.status === 'paused' ? 'resume' : 'pause';
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${currentJob.id}/${endpoint}`,
        { method: 'POST' }
      );
      if (res.ok) {
        const job = await res.json();
        setCurrentJob(job);
      }
    } catch (error) {
      console.error(`Failed to ${endpoint} job:`, error);
    }
  };

  const handleCancel = async () => {
    if (!currentJob) return;

    try {
      await fetch(`${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${currentJob.id}`, {
        method: 'DELETE',
      });
      setCurrentJob(null);
    } catch (error) {
      console.error('Failed to cancel job:', error);
    }
  };

  const handleRetryFailed = async (passId: string) => {
    if (!currentJob) return;

    try {
      await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/render-queue/jobs/${currentJob.id}/passes/${passId}/retry`,
        { method: 'POST' }
      );
      fetchJobStatus(currentJob.id);
    } catch (error) {
      console.error('Failed to retry pass:', error);
    }
  };

  // Accept Master - Mark shot as finalized, archive draft, update navigator thumbnail
  const handleAcceptMaster = useCallback(
    async (shotId: string, passId: string) => {
      try {
        // 1. Mark the master pass as accepted/finalized
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/render-queue/scene-chains/${sceneChainId}/shots/${shotId}/finalize`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ passId, action: 'accept' }),
          }
        );

        if (res.ok) {
          // Update local state
          setApprovedShots(prev => new Set([...prev, shotId]));
          setPendingReviewShots(prev => {
            const next = new Set(prev);
            next.delete(shotId);
            return next;
          });

          // Refresh version stacks to show updated state
          await fetchVersionStacks();

          // Move to next shot needing review, or close if done
          const nextPendingShot = versionStacks.find(
            s => s.shotId !== shotId && pendingReviewShots.has(s.shotId)
          );
          if (nextPendingShot) {
            setLightboxShotId(nextPendingShot.shotId);
          } else {
            setShowLightbox(false);
          }
        }
      } catch (error) {
        console.error('Failed to accept master:', error);
      }
    },
    [projectId, sceneChainId, versionStacks, pendingReviewShots, fetchVersionStacks]
  );

  // Reject Master - Keep draft as the working version, hide/archive the master
  const handleRejectMaster = useCallback(
    async (shotId: string) => {
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/render-queue/scene-chains/${sceneChainId}/shots/${shotId}/finalize`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'reject' }),
          }
        );

        if (res.ok) {
          // Remove from pending review
          setPendingReviewShots(prev => {
            const next = new Set(prev);
            next.delete(shotId);
            return next;
          });

          // Refresh version stacks
          await fetchVersionStacks();

          // Move to next shot needing review, or close if done
          const nextPendingShot = versionStacks.find(
            s => s.shotId !== shotId && pendingReviewShots.has(s.shotId)
          );
          if (nextPendingShot) {
            setLightboxShotId(nextPendingShot.shotId);
          } else {
            setShowLightbox(false);
          }
        }
      } catch (error) {
        console.error('Failed to reject master:', error);
      }
    },
    [projectId, sceneChainId, versionStacks, pendingReviewShots, fetchVersionStacks]
  );

  // Detect shots with completed masters that need review
  useEffect(() => {
    const shotsNeedingReview = versionStacks
      .filter(stack => {
        const hasMaster = stack.versions.some(
          v => v.quality === 'master' && v.status === 'complete'
        );
        const isNotApproved = !approvedShots.has(stack.shotId);
        return hasMaster && isNotApproved;
      })
      .map(s => s.shotId);

    setPendingReviewShots(new Set(shotsNeedingReview));
  }, [versionStacks, approvedShots]);

  const toggleQuality = (quality: RenderQuality) => {
    setSelectedQualities(prev => {
      if (prev.includes(quality)) {
        return prev.filter(q => q !== quality);
      }
      // Keep sorted order: draft, review, master
      const order: RenderQuality[] = ['draft', 'review', 'master'];
      return [...prev, quality].sort((a, b) => order.indexOf(a) - order.indexOf(b));
    });
  };

  const estimatedCost = selectedQualities.reduce((sum, q) => {
    const preset = presets?.[q];
    if (!preset) return sum;
    return sum + preset.videoCost * shotCount;
  }, 0);

  const estimatedTime = selectedQualities.reduce((sum, q) => {
    const preset = presets?.[q];
    if (!preset) return sum;
    return sum + preset.estimatedTimeVideo * shotCount;
  }, 0);

  const progressPercent = currentJob
    ? (currentJob.completedPasses / currentJob.totalPasses) * 100
    : 0;

  return (
    <TooltipProvider>
    <div className="overflow-hidden rounded-lg border border-white/10 bg-black/40">
      {/* Header */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="flex w-full items-center justify-between px-4 py-3 transition-colors hover:bg-white/5"
      >
        <div className="flex items-center gap-3">
          <div className="flex items-center gap-1.5">
            <Zap className="h-4 w-4 text-amber-400" />
            <span className="text-sm font-medium text-white">Render Queue</span>
          </div>
          {currentJob && (
            <div
              className={clsx(
                'rounded px-2 py-0.5 text-[10px] font-medium uppercase',
                currentJob.status === 'rendering' && 'bg-blue-500/20 text-blue-400',
                currentJob.status === 'paused' && 'bg-yellow-500/20 text-yellow-400',
                currentJob.status === 'complete' && 'bg-green-500/20 text-green-400',
                currentJob.status === 'failed' && 'bg-red-500/20 text-red-400'
              )}
            >
              {currentJob.status}
            </div>
          )}
        </div>
        <div className="flex items-center gap-2">
          {costComparison && costComparison.savingsPercent > 20 && (
            <div className="flex items-center gap-1 text-[10px] text-green-400">
              <TrendingDown className="h-3 w-3" />
              Save {costComparison.savingsPercent.toFixed(0)}%
            </div>
          )}
          {isExpanded ? (
            <ChevronUp className="h-4 w-4 text-gray-400" />
          ) : (
            <ChevronDown className="h-4 w-4 text-gray-400" />
          )}
        </div>
      </button>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            className="overflow-hidden"
          >
            <div className="space-y-4 px-4 pb-4">
              {/* Quality Tier Selection */}
              <div>
                <div className="mb-2 text-[10px] tracking-wider text-gray-500 uppercase">
                  Quality Tiers
                </div>
                <div className="flex gap-2">
                  {(['draft', 'review', 'master'] as RenderQuality[]).map(quality => {
                    const preset = presets?.[quality];
                    const isSelected = selectedQualities.includes(quality);
                    const isDisabled = !!currentJob && currentJob.status === 'rendering';

                    return (
                      <button
                        key={quality}
                        onClick={() => !isDisabled && toggleQuality(quality)}
                        disabled={isDisabled}
                        className={clsx(
                          'flex-1 rounded-lg border p-3 transition-all',
                          isSelected
                            ? QUALITY_COLORS[quality]
                            : 'border-white/10 text-gray-500 hover:border-white/20 hover:text-gray-400',
                          isDisabled && 'cursor-not-allowed opacity-50'
                        )}
                      >
                        <div className="mb-1 flex items-center justify-center gap-1.5">
                          {QUALITY_ICONS[quality]}
                          <span className="text-xs font-medium capitalize">{quality}</span>
                        </div>
                        {preset && (
                          <div className="text-[10px] opacity-70">
                            ${preset.videoCost.toFixed(2)}/shot
                          </div>
                        )}
                      </button>
                    );
                  })}
                </div>
              </div>

              {/* Cost/Time Estimate */}
              {selectedQualities.length > 0 && !currentJob && (
                <div className="flex items-center justify-between rounded-lg bg-white/5 px-3 py-2 text-xs text-gray-400">
                  <div className="flex items-center gap-4">
                    <div className="flex items-center gap-1">
                      <DollarSign className="h-3 w-3" />
                      <span>Est. ${estimatedCost.toFixed(2)}</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <Clock className="h-3 w-3" />
                      <span>~{Math.ceil(estimatedTime / 60)} min</span>
                    </div>
                  </div>
                  <span className="text-gray-500">
                    {shotCount} shot{shotCount !== 1 ? 's' : ''}  {selectedQualities.length} tier
                    {selectedQualities.length !== 1 ? 's' : ''}
                  </span>
                </div>
              )}

              {/* Refinement C: Metadata Burn-in Toggle */}
              {!currentJob &&
                (selectedQualities.includes('draft') || selectedQualities.includes('review')) && (
                  <label className="group flex cursor-pointer items-center gap-3">
                    <div className="relative">
                      <input
                        type="checkbox"
                        checked={burnInMetadata}
                        onChange={e => setBurnInMetadata(e.target.checked)}
                        className="peer sr-only"
                      />
                      <div
                        className={clsx(
                          'h-5 w-9 rounded-full transition-colors',
                          burnInMetadata ? 'bg-cyan-500' : 'bg-white/10 group-hover:bg-white/20'
                        )}
                      />
                      <div
                        className={clsx(
                          'absolute top-0.5 left-0.5 h-4 w-4 rounded-full bg-white shadow-sm transition-transform',
                          burnInMetadata && 'translate-x-4'
                        )}
                      />
                    </div>
                    <div className="flex items-center gap-2">
                      <Film className="h-4 w-4 text-cyan-400" />
                      <span className="text-xs text-gray-300">Burn-in Metadata</span>
                      <span className="text-[10px] text-gray-500">(Seed, Shot #, Quality)</span>
                    </div>
                  </label>
                )}

              {/* Active Job Progress */}
              {currentJob && (
                <div className="space-y-3">
                  {/* Progress Bar */}
                  <div className="space-y-1">
                    <div className="flex justify-between text-[10px]">
                      <span className="text-gray-400">
                        {currentJob.completedPasses} / {currentJob.totalPasses} passes
                      </span>
                      <span className={QUALITY_COLORS[currentJob.activeQuality].split(' ')[0]}>
                        {currentJob.activeQuality} pass
                      </span>
                    </div>
                    <div className="h-2 overflow-hidden rounded-full bg-white/10">
                      <motion.div
                        className={clsx(
                          'h-full rounded-full',
                          currentJob.activeQuality === 'draft' && 'bg-amber-500',
                          currentJob.activeQuality === 'review' && 'bg-blue-500',
                          currentJob.activeQuality === 'master' && 'bg-purple-500'
                        )}
                        initial={{ width: 0 }}
                        animate={{ width: `${progressPercent}%` }}
                        transition={{ duration: 0.3 }}
                      />
                    </div>
                  </div>

                  {/* Cost Tracking */}
                  <div className="flex items-center justify-between text-xs">
                    <span className="text-gray-500">Actual cost</span>
                    <span className="font-mono text-white">
                      ${currentJob.actualCost.toFixed(2)} / ${currentJob.estimatedCost.toFixed(2)}
                    </span>
                  </div>

                  {/* Failed Passes */}
                  {currentJob.failedPasses > 0 && (
                    <div className="rounded-lg border border-red-500/20 bg-red-500/10 p-2">
                      <div className="flex items-center gap-2 text-xs text-red-400">
                        <AlertCircle className="h-4 w-4" />
                        <span>{currentJob.failedPasses} failed</span>
                      </div>
                      <div className="mt-2 flex flex-wrap gap-1">
                        {currentJob.passes
                          .filter(p => p.status === 'failed')
                          .slice(0, 5)
                          .map(p => (
                            <button
                              key={p.id}
                              onClick={() => handleRetryFailed(p.id)}
                              className="flex items-center gap-1 rounded bg-red-500/20 px-2 py-1 text-[10px] text-red-400 hover:bg-red-500/30"
                            >
                              <RotateCcw className="h-3 w-3" />
                              Shot {p.orderIndex + 1}
                            </button>
                          ))}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Action Buttons */}
              <div className="flex gap-2">
                {!currentJob ? (
                  <button
                    onClick={handleStartRender}
                    disabled={selectedQualities.length === 0 || isLoading || shotCount === 0}
                    className={clsx(
                      'flex flex-1 items-center justify-center gap-2 rounded-lg py-2.5 text-sm font-medium transition-all',
                      selectedQualities.length > 0 && !isLoading && shotCount > 0
                        ? 'bg-gradient-to-r from-amber-500 to-orange-500 text-white hover:from-amber-400 hover:to-orange-400'
                        : 'cursor-not-allowed bg-white/10 text-gray-500'
                    )}
                  >
                    {isLoading ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      <Play className="h-4 w-4" />
                    )}
                    Start Render
                  </button>
                ) : (
                  <>
                    <button
                      onClick={handlePauseResume}
                      className={clsx(
                        'flex flex-1 items-center justify-center gap-2 rounded-lg py-2.5 text-sm font-medium transition-all',
                        currentJob.status === 'paused'
                          ? 'bg-green-500/20 text-green-400 hover:bg-green-500/30'
                          : 'bg-yellow-500/20 text-yellow-400 hover:bg-yellow-500/30'
                      )}
                    >
                      {currentJob.status === 'paused' ? (
                        <>
                          <Play className="h-4 w-4" />
                          Resume
                        </>
                      ) : (
                        <>
                          <Pause className="h-4 w-4" />
                          Pause
                        </>
                      )}
                    </button>
                    <button
                      onClick={handleCancel}
                      className="rounded-lg bg-red-500/20 px-4 py-2.5 text-sm font-medium text-red-400 transition-all hover:bg-red-500/30"
                    >
                      Cancel
                    </button>
                  </>
                )}
              </div>

              {/* Savings Explainer */}
              {costComparison && !currentJob && (
                <div className="rounded-lg bg-white/5 px-3 py-2 text-[10px] text-gray-500">
                  <div className="mb-1 flex items-center gap-1 text-green-400">
                    <TrendingDown className="h-3 w-3" />
                    <span className="font-medium">Draft-First Workflow Saves Money</span>
                  </div>
                  <p>
                    Iterate 3 at draft quality (${costComparison.draftCost.toFixed(2)}), then
                    render once at master (${costComparison.masterCost.toFixed(2)}). Save $
                    {costComparison.savings.toFixed(2)} vs. iterating at master quality.
                  </p>
                </div>
              )}

              {/* Version Stacks - Show per-shot upgrade options */}
              {versionStacks.length > 0 && (
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-[10px] tracking-wider text-gray-500 uppercase">
                      <Layers className="h-3 w-3" />
                      Version Stacks
                      {pendingReviewShots.size > 0 && (
                        <span className="ml-1 rounded-full bg-orange-500/20 px-1.5 py-0.5 text-[9px] font-bold text-orange-400">
                          {pendingReviewShots.size} pending review
                        </span>
                      )}
                    </div>
                    <div className="flex items-center gap-2">
                      {/* Review Dailies Button - opens lightbox for first pending review shot */}
                      {pendingReviewShots.size > 0 && (
                        <button
                          onClick={() => {
                            const firstPendingShot = versionStacks.find(s =>
                              pendingReviewShots.has(s.shotId)
                            );
                            setLightboxShotId(firstPendingShot?.shotId);
                            setShowLightbox(true);
                          }}
                          className="flex items-center gap-1.5 rounded border border-orange-500/30 bg-gradient-to-r from-orange-500/30 to-amber-500/30 px-2.5 py-1.5 text-[10px] font-medium text-orange-300 transition-all hover:from-orange-500/40 hover:to-amber-500/40"
                        >
                          <Eye className="h-3.5 w-3.5" />
                          Review Dailies
                        </button>
                      )}
                      {/* A/B Compare Button - opens lightbox for first shot with 2+ passes */}
                      {versionStacks.some(
                        s => s.versions.filter(v => v.status === 'complete').length >= 2
                      ) &&
                        pendingReviewShots.size === 0 && (
                          <button
                            onClick={() => {
                              const comparableShot = versionStacks.find(
                                s => s.versions.filter(v => v.status === 'complete').length >= 2
                              );
                              setLightboxShotId(comparableShot?.shotId);
                              setShowLightbox(true);
                            }}
                            className="flex items-center gap-1.5 rounded bg-cyan-500/20 px-2 py-1 text-[10px] font-medium text-cyan-400 transition-all hover:bg-cyan-500/30"
                          >
                            <SplitSquareHorizontal className="h-3 w-3" />
                            A/B Compare
                          </button>
                        )}
                    </div>
                  </div>
                  <div className="max-h-48 space-y-1.5 overflow-y-auto">
                    {versionStacks.map(stack => {
                      const hasMultiplePasses =
                        stack.versions.filter(v => v.status === 'complete').length >= 2;
                      const isPendingReview = pendingReviewShots.has(stack.shotId);
                      const isApproved = approvedShots.has(stack.shotId);

                      return (
                        <div
                          key={stack.shotId}
                          className={clsx(
                            'flex items-center justify-between rounded-lg px-3 py-2 transition-all',
                            isPendingReview && 'border border-orange-500/20 bg-orange-500/10',
                            isApproved && 'border border-green-500/20 bg-green-500/10',
                            !isPendingReview && !isApproved && 'bg-white/5'
                          )}
                        >
                          <div className="flex items-center gap-3">
                            <div className="flex items-center gap-2">
                              <span className="text-xs text-gray-400">{stack.shotName}</span>
                              {/* Status badges */}
                              {isPendingReview && (
                                <span className="rounded bg-orange-500/20 px-1.5 py-0.5 text-[9px] font-medium text-orange-400">
                                  NEEDS REVIEW
                                </span>
                              )}
                              {isApproved && (
                                <span className="flex items-center gap-1 rounded bg-green-500/20 px-1.5 py-0.5 text-[9px] font-medium text-green-400">
                                  <CheckCheck className="h-3 w-3" />
                                  APPROVED
                                </span>
                              )}
                            </div>
                            <div className="flex items-center gap-1">
                              {(['draft', 'review', 'master'] as RenderQuality[]).map(q => {
                                const version = stack.versions.find(v => v.quality === q);
                                if (!version) {
                                  return (
                                    <Tooltip key={q} content={`${q} - not rendered`} side="top">
                                      <div
                                        className="h-6 w-6 rounded border border-dashed border-white/10"
                                      />
                                    </Tooltip>
                                  );
                                }
                                return (
                                  <Tooltip
                                    key={q}
                                    content={`${q} - ${version.status}${version.seed ? ` (seed: ${version.seed})` : ''}${isPendingReview && q === 'master' ? ' - PENDING REVIEW' : ''}`}
                                    side="top"
                                  >
                                    <div
                                      className={clsx(
                                        'flex h-6 w-6 items-center justify-center rounded text-[10px] font-bold',
                                        version.status === 'complete' && QUALITY_COLORS[q],
                                        version.status === 'generating' &&
                                          'animate-pulse border-2 border-blue-400',
                                        version.status === 'failed' &&
                                          'border border-red-500/30 bg-red-500/20 text-red-400',
                                        version.status === 'pending' &&
                                          'border border-white/20 text-gray-500',
                                        // Highlight master badge when pending review
                                        q === 'master' &&
                                          isPendingReview &&
                                          version.status === 'complete' &&
                                          'ring-2 ring-orange-400/50 ring-offset-1 ring-offset-black'
                                      )}
                                    >
                                      {version.status === 'complete' &&
                                        (q === 'draft' ? 'D' : q === 'review' ? 'R' : 'M')}
                                      {version.status === 'generating' && (
                                        <Loader2 className="h-3 w-3 animate-spin" />
                                      )}
                                      {version.status === 'failed' && '!'}
                                    </div>
                                  </Tooltip>
                                );
                              })}
                            </div>
                          </div>

                          <div className="flex items-center gap-2">
                            {/* Compare & Approve Button for pending review shots */}
                            {isPendingReview && (
                              <button
                                onClick={() => {
                                  setLightboxShotId(stack.shotId);
                                  setShowLightbox(true);
                                }}
                                className="flex items-center gap-1.5 rounded border border-orange-500/30 bg-orange-500/20 px-2 py-1 text-[10px] font-medium text-orange-400 transition-all hover:bg-orange-500/30"
                              >
                                <Eye className="h-3 w-3" />
                                Compare & Approve
                              </button>
                            )}

                            {/* Per-shot Compare Button (when not pending review) */}
                            {!isPendingReview && hasMultiplePasses && (
                              <Tooltip content="Compare versions" side="top">
                                <button
                                  onClick={() => {
                                    setLightboxShotId(stack.shotId);
                                    setShowLightbox(true);
                                  }}
                                  className="rounded p-1 text-cyan-400 transition-all hover:bg-cyan-500/20"
                                >
                                  <SplitSquareHorizontal className="h-3.5 w-3.5" />
                                </button>
                              </Tooltip>
                            )}

                            {/* Upgrade Button */}
                            {stack.canUpgrade && currentJob && !isPendingReview && !isApproved && (
                              <button
                                onClick={() =>
                                  handlePromoteShot(stack.shotId, stack.nextUpgradeQuality!)
                                }
                                disabled={promotingShot === stack.shotId}
                                className={clsx(
                                  'flex items-center gap-1 rounded px-2 py-1 text-[10px] font-medium transition-all',
                                  QUALITY_COLORS[stack.nextUpgradeQuality!],
                                  'hover:scale-105',
                                  promotingShot === stack.shotId && 'cursor-wait opacity-50'
                                )}
                              >
                                {promotingShot === stack.shotId ? (
                                  <Loader2 className="h-3 w-3 animate-spin" />
                                ) : (
                                  <ArrowUpCircle className="h-3 w-3" />
                                )}
                                 {stack.nextUpgradeQuality}
                                {stack.upgradeCost !== undefined && (
                                  <span className="opacity-70">
                                    (${stack.upgradeCost.toFixed(2)})
                                  </span>
                                )}
                              </button>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* A/B Lightbox Modal - Dailies Review */}
      <ABLightbox
        isOpen={showLightbox}
        onClose={() => setShowLightbox(false)}
        projectId={projectId}
        sceneChainId={sceneChainId}
        initialShotId={lightboxShotId}
        onAcceptMaster={handleAcceptMaster}
        onRejectMaster={handleRejectMaster}
      />
    </div>
    </TooltipProvider>
  );
}
</file>

<file path="frontend/src/components/layout/StudioSidebar.tsx">
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import {
  LayoutGrid,
  Film,
  Clapperboard,
  Wand2,
  Music,
  Layers,
  Settings,
  ChevronLeft,
  ChevronRight,
  Users,
} from 'lucide-react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { useState } from 'react';
import { clsx } from 'clsx';

interface SidebarItem {
  id: string;
  icon: React.ComponentType<{ className?: string }>;
  label: string;
  href: string;
  disabled?: boolean;
}

export function StudioSidebar({ projectId }: { projectId?: string }) {
  const [isCollapsed, setIsCollapsed] = useState(false);
  const pathname = usePathname();

  // Workaround for icon import (Type was not in import list, adding Text alias)
  const TypeIcon = ({ className }: { className?: string }) => (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={className}
    >
      <polyline points="4 7 4 4 20 4 20 7" />
      <line x1="9" x2="15" y1="20" y2="20" />
      <line x1="12" x2="12" y1="4" y2="20" />
    </svg>
  );

  const menuItems: SidebarItem[] = projectId
    ? [
        { id: 'dashboard', icon: LayoutGrid, label: 'Dashboard', href: '/' },
        { id: 'script', icon: TypeIcon, label: 'Script', href: `/projects/${projectId}/script` }, // To be created
        {
          id: 'storyboard',
          icon: Clapperboard,
          label: 'Storyboard',
          href: `/projects/${projectId}/storyboard`,
        },
        { id: 'generate', icon: Wand2, label: 'Studio', href: `/projects/${projectId}/generate` },
        {
          id: 'timeline',
          icon: Film,
          label: 'Timeline',
          href: `/projects/${projectId}/timeline`,
          disabled: true,
        },
        {
          id: 'audio',
          icon: Music,
          label: 'VibeSync',
          href: `/projects/${projectId}/audio`,
          disabled: true,
        },
        {
          id: 'assets',
          icon: Layers,
          label: 'Assets',
          href: `/projects/${projectId}/assets`,
          disabled: true,
        },
      ]
    : [
        { id: 'dashboard', icon: LayoutGrid, label: 'Dashboard', href: '/' },
        { id: 'community', icon: Users, label: 'Community', href: '/community', disabled: true },
        { id: 'settings', icon: Settings, label: 'Settings', href: '/settings', disabled: true },
      ];

  return (
    <motion.div
      initial={{ width: 260 }}
      animate={{ width: isCollapsed ? 80 : 260 }}
      transition={{ type: 'spring', stiffness: 300, damping: 30 }}
      className="glass-panel sticky top-0 left-0 z-50 flex h-screen flex-col justify-between border-r border-r-[var(--glass-border)] py-6"
    >
      {/* Logo Area */}
      <div
        className={clsx(
          'mb-8 flex items-center px-6',
          isCollapsed ? 'justify-center' : 'justify-between'
        )}
      >
        {!isCollapsed && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="flex items-center gap-2"
          >
            <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-gradient-to-br from-indigo-500 to-purple-600">
              <Film className="h-4 w-4 fill-white/20 text-white" />
            </div>
            <span className="text-lg font-bold tracking-tight text-white">VibeBoard</span>
          </motion.div>
        )}
        <button
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="rounded-full p-1 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
        >
          {isCollapsed ? <ChevronRight className="h-5 w-5" /> : <ChevronLeft className="h-5 w-5" />}
        </button>
      </div>

      {/* Navigation */}
      <div className="flex-1 space-y-1 px-4">
        {menuItems.map(item => {
          const isActive = pathname === item.href;
          return (
            <Link
              key={item.id}
              href={item.disabled ? '#' : item.href}
              className={clsx(
                'group relative flex items-center gap-3 rounded-lg px-3 py-2.5 transition-all',
                item.disabled ? 'cursor-not-allowed opacity-40' : 'hover:bg-white/5',
                isActive && 'bg-white/10 text-white shadow-[0_0_20px_rgba(99,102,241,0.3)]'
              )}
            >
              {/* Active Glow Bar */}
              {isActive && (
                <motion.div
                  layoutId="active-nav"
                  className="absolute top-1/2 left-0 h-6 w-1 -translate-y-1/2 rounded-r-full bg-indigo-500"
                />
              )}

              <item.icon
                className={clsx(
                  'h-5 w-5 transition-colors',
                  isActive ? 'text-indigo-400' : 'text-gray-400 group-hover:text-gray-200'
                )}
              />

              {!isCollapsed && (
                <motion.span
                  initial={{ opacity: 0, x: -10 }}
                  animate={{ opacity: 1, x: 0 }}
                  className="text-sm font-medium text-gray-300 group-hover:text-white"
                >
                  {item.label}
                </motion.span>
              )}

              {/* Tooltip for collapsed state */}
              {isCollapsed && (
                <div className="pointer-events-none absolute left-full z-50 ml-4 rounded border border-white/10 bg-black/90 px-2 py-1 text-xs whitespace-nowrap text-white opacity-0 transition-opacity group-hover:opacity-100">
                  {item.label}
                </div>
              )}
            </Link>
          );
        })}
      </div>

      {/* Footer / User */}
      <div className="border-t border-white/5 px-4 pt-4">
        <div className={clsx('flex items-center gap-3', isCollapsed ? 'justify-center' : '')}>
          <div className="h-9 w-9 rounded-full border border-white/10 bg-gradient-to-r from-gray-700 to-gray-600" />
          {!isCollapsed && (
            <div className="overflow-hidden">
              <p className="truncate text-sm font-medium text-white">Director</p>
              <p className="truncate text-xs text-gray-500">Pro Studio</p>
            </div>
          )}
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="frontend/src/components/generations/ABLightbox.tsx">
/**
 * A/B Lightbox - Quality Comparison Component
 *
 * REFINEMENT B: The "Mastering" View
 * Allows side-by-side comparison of Draft vs Master renders using a split-screen slider.
 * Helps pros justify the cost difference by seeing exactly what detail was gained.
 *
 * Two modes:
 * 1. ABLightbox - Full integration with Render Queue (requires projectId, sceneChainId)
 * 2. SimpleABLightbox - Direct comparison of any two images/videos (just pass URLs)
 */

import { useState, useCallback, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import {
  X,
  ChevronLeft,
  ChevronRight,
  Zap,
  Star,
  Crown,
  DollarSign,
  Hash,
  Cpu,
  ArrowRight,
  GripVertical,
  ZoomIn,
  ZoomOut,
  Maximize2,
  Move,
  Play,
  Pause,
  SkipBack,
  SkipForward,
  Repeat,
  Check,
  XCircle,
  Monitor,
  Search,
} from 'lucide-react';
import { BACKEND_URL } from '@/lib/api';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';

type RenderQuality = 'draft' | 'review' | 'master';

interface PassInfo {
  passId: string;
  quality: RenderQuality;
  outputUrl: string;
  thumbnailUrl?: string;
  cost: number;
  seed?: number;
  model: string;
  resolution?: string; // e.g., "540p", "1080p", "4K"
  width?: number;
  height?: number;
}

interface ComparisonData {
  shotId: string;
  shotName: string;
  passA: PassInfo | null;
  passB: PassInfo | null;
  costDifference: number;
  qualityUpgrade: string;
}

interface ABLightboxProps {
  isOpen: boolean;
  onClose: () => void;
  projectId: string;
  sceneChainId: string;
  initialShotId?: string;
  initialQualityA?: RenderQuality;
  initialQualityB?: RenderQuality;
  onAcceptMaster?: (shotId: string, passId: string) => void;
  onRejectMaster?: (shotId: string) => void;
}

const QUALITY_ICONS: Record<RenderQuality, React.ReactNode> = {
  draft: <Zap className="h-4 w-4" />,
  review: <Star className="h-4 w-4" />,
  master: <Crown className="h-4 w-4" />,
};

const QUALITY_COLORS: Record<RenderQuality, string> = {
  draft: 'text-amber-400 bg-amber-500/20',
  review: 'text-blue-400 bg-blue-500/20',
  master: 'text-purple-400 bg-purple-500/20',
};

export function ABLightbox({
  isOpen,
  onClose,
  projectId,
  sceneChainId,
  initialShotId,
  initialQualityA = 'draft',
  initialQualityB = 'master',
  onAcceptMaster,
  onRejectMaster,
}: ABLightboxProps) {
  const [comparison, setComparison] = useState<ComparisonData | null>(null);
  const [availableShots, setAvailableShots] = useState<
    Array<{
      shotId: string;
      shotName: string;
      availableQualities: RenderQuality[];
    }>
  >([]);
  const [currentShotIndex, setCurrentShotIndex] = useState(0);
  const [qualityA, setQualityA] = useState<RenderQuality>(initialQualityA);
  const [qualityB, setQualityB] = useState<RenderQuality>(initialQualityB);
  const [sliderPosition, setSliderPosition] = useState(50);
  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // Video refs for synchronized playback
  const videoARef = useRef<HTMLVideoElement>(null);
  const videoBRef = useRef<HTMLVideoElement>(null);

  // Video transport state
  const [isPlaying, setIsPlaying] = useState(true);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isLooping, setIsLooping] = useState(true);

  // Flicker mode state (rapidly toggles between A and B at full width)
  const [flickerMode, setFlickerMode] = useState(false);
  const [flickerShowA, setFlickerShowA] = useState(true);
  const flickerIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Synchronized Zoom & Pan State
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [zoomMode, setZoomMode] = useState(false); // Alt/Option key held

  // Magnifier Lens State (The "Pixel-Peeper")
  const [magnifierEnabled, setMagnifierEnabled] = useState(false);
  const [magnifierPos, setMagnifierPos] = useState({ x: 0, y: 0 });
  const [showMagnifier, setShowMagnifier] = useState(false);
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });
  const MAGNIFIER_SIZE = 180; // Diameter in pixels
  const MAGNIFIER_ZOOM = 4; // 4x zoom inside the lens

  // Update container size when needed (for magnifier)
  useEffect(() => {
    if (containerRef.current && magnifierEnabled) {
      setContainerSize({
        width: containerRef.current.offsetWidth,
        height: containerRef.current.offsetHeight,
      });
    }
  }, [magnifierEnabled, isOpen, comparison]);

  // Fetch available comparisons
  useEffect(() => {
    if (!isOpen) return;

    const fetchComparisons = async () => {
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/render-queue/scene-chains/${sceneChainId}/comparisons`
        );
        if (res.ok) {
          const data = await res.json();
          setAvailableShots(data);

          // Set initial shot
          if (initialShotId) {
            const idx = data.findIndex((s: { shotId: string }) => s.shotId === initialShotId);
            if (idx >= 0) setCurrentShotIndex(idx);
          }
        }
      } catch (error) {
        console.error('Failed to fetch comparisons:', error);
      }
    };

    fetchComparisons();
  }, [isOpen, projectId, sceneChainId, initialShotId]);

  // Fetch comparison data for current shot
  useEffect(() => {
    if (!isOpen || availableShots.length === 0) return;

    const shot = availableShots[currentShotIndex];
    if (!shot) return;

    const fetchComparison = async () => {
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/render-queue/scene-chains/${sceneChainId}/shots/${shot.shotId}/compare?qualityA=${qualityA}&qualityB=${qualityB}`
        );
        if (res.ok) {
          const data = await res.json();
          setComparison(data);
        }
      } catch (error) {
        console.error('Failed to fetch comparison:', error);
      }
    };

    fetchComparison();
  }, [isOpen, availableShots, currentShotIndex, qualityA, qualityB, projectId, sceneChainId]);

  // Handle slider drag
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging || !containerRef.current) return;

      const rect = containerRef.current.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
      setSliderPosition(percent);
    },
    [isDragging]
  );

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  // Navigation
  const goToPrevShot = () => {
    setCurrentShotIndex(prev => (prev > 0 ? prev - 1 : availableShots.length - 1));
    resetZoom();
  };

  const goToNextShot = () => {
    setCurrentShotIndex(prev => (prev < availableShots.length - 1 ? prev + 1 : 0));
    resetZoom();
  };

  // Zoom Controls
  const handleZoomIn = useCallback(() => {
    setZoom(prev => Math.min(prev * 1.5, 8));
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoom(prev => Math.max(prev / 1.5, 1));
  }, []);

  const resetZoom = useCallback(() => {
    setZoom(1);
    setPan({ x: 0, y: 0 });
  }, []);

  // Mouse wheel zoom (synchronized)
  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      if (!containerRef.current) return;
      e.preventDefault();

      const rect = containerRef.current.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Calculate zoom
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.min(Math.max(zoom * delta, 1), 8);

      // Adjust pan to zoom toward mouse position
      if (newZoom !== zoom) {
        const scale = newZoom / zoom;
        const newPanX = mouseX - (mouseX - pan.x) * scale;
        const newPanY = mouseY - (mouseY - pan.y) * scale;

        setPan({ x: newPanX, y: newPanY });
        setZoom(newZoom);
      }
    },
    [zoom, pan]
  );

  // Pan handling (when zoomed in)
  const handlePanStart = useCallback(
    (e: React.MouseEvent) => {
      if (zoom <= 1) return; // Only pan when zoomed
      if (e.altKey || zoomMode) {
        setIsPanning(true);
        setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        e.preventDefault();
      }
    },
    [zoom, pan, zoomMode]
  );

  const handlePanMove = useCallback(
    (e: MouseEvent) => {
      if (!isPanning) return;
      setPan({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y,
      });
    },
    [isPanning, panStart]
  );

  const handlePanEnd = useCallback(() => {
    setIsPanning(false);
  }, []);

  useEffect(() => {
    if (isPanning) {
      document.addEventListener('mousemove', handlePanMove);
      document.addEventListener('mouseup', handlePanEnd);
      return () => {
        document.removeEventListener('mousemove', handlePanMove);
        document.removeEventListener('mouseup', handlePanEnd);
      };
    }
  }, [isPanning, handlePanMove, handlePanEnd]);

  // Track Alt/Option key for zoom mode
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Alt') setZoomMode(true);
    };
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === 'Alt') setZoomMode(false);
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, [isOpen]);

  // Magnifier lens mouse tracking
  const handleMagnifierMove = useCallback(
    (e: React.MouseEvent<HTMLDivElement>) => {
      if (!magnifierEnabled || !containerRef.current) return;

      const rect = containerRef.current.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      setMagnifierPos({ x, y });
      setShowMagnifier(true);
    },
    [magnifierEnabled]
  );

  const handleMagnifierLeave = useCallback(() => {
    setShowMagnifier(false);
  }, []);

  // Video transport controls
  const togglePlayPause = useCallback(() => {
    const videoA = videoARef.current;
    const videoB = videoBRef.current;
    if (!videoA && !videoB) return;

    if (isPlaying) {
      videoA?.pause();
      videoB?.pause();
    } else {
      videoA?.play();
      videoB?.play();
    }
    setIsPlaying(!isPlaying);
  }, [isPlaying]);

  const stepFrame = useCallback(
    (direction: 'forward' | 'backward') => {
      const videoA = videoARef.current;
      const videoB = videoBRef.current;
      if (!videoA && !videoB) return;

      // Pause videos first
      videoA?.pause();
      videoB?.pause();
      setIsPlaying(false);

      // Step by 1/24th of a second (assuming 24fps)
      const frameTime = 1 / 24;
      const newTime =
        direction === 'forward'
          ? Math.min(currentTime + frameTime, duration)
          : Math.max(currentTime - frameTime, 0);

      if (videoA) videoA.currentTime = newTime;
      if (videoB) videoB.currentTime = newTime;
      setCurrentTime(newTime);
    },
    [currentTime, duration]
  );

  // Sync video time updates
  useEffect(() => {
    const videoA = videoARef.current;
    if (!videoA) return;

    const handleTimeUpdate = () => {
      setCurrentTime(videoA.currentTime);
    };
    const handleLoadedMetadata = () => {
      setDuration(videoA.duration);
    };
    const handleEnded = () => {
      if (!isLooping) setIsPlaying(false);
    };

    videoA.addEventListener('timeupdate', handleTimeUpdate);
    videoA.addEventListener('loadedmetadata', handleLoadedMetadata);
    videoA.addEventListener('ended', handleEnded);

    return () => {
      videoA.removeEventListener('timeupdate', handleTimeUpdate);
      videoA.removeEventListener('loadedmetadata', handleLoadedMetadata);
      videoA.removeEventListener('ended', handleEnded);
    };
  }, [isLooping, comparison]);

  // Flicker mode toggle effect
  useEffect(() => {
    if (flickerMode) {
      flickerIntervalRef.current = setInterval(() => {
        setFlickerShowA(prev => !prev);
      }, 150); // Toggle every 150ms for rapid comparison
    } else {
      if (flickerIntervalRef.current) {
        clearInterval(flickerIntervalRef.current);
        flickerIntervalRef.current = null;
      }
      setFlickerShowA(true);
    }

    return () => {
      if (flickerIntervalRef.current) {
        clearInterval(flickerIntervalRef.current);
      }
    };
  }, [flickerMode]);

  // Accept/Reject handlers
  const handleAcceptMaster = useCallback(() => {
    if (comparison?.shotId && comparison?.passB?.passId && onAcceptMaster) {
      onAcceptMaster(comparison.shotId, comparison.passB.passId);
    }
  }, [comparison, onAcceptMaster]);

  const handleRejectMaster = useCallback(() => {
    if (comparison?.shotId && onRejectMaster) {
      onRejectMaster(comparison.shotId);
    }
  }, [comparison, onRejectMaster]);

  // Helper to format time as MM:SS.FF
  const formatTime = (time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    const frames = Math.floor((time % 1) * 24);
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${frames.toString().padStart(2, '0')}`;
  };

  // Helper to get resolution label
  const getResolutionLabel = (pass: PassInfo): string => {
    if (pass.resolution) return pass.resolution;
    if (pass.height) {
      if (pass.height >= 2160) return '4K';
      if (pass.height >= 1080) return '1080p';
      if (pass.height >= 720) return '720p';
      if (pass.height >= 540) return '540p';
      return `${pass.height}p`;
    }
    return pass.quality === 'master' ? '4K' : pass.quality === 'review' ? '1080p' : '540p';
  };

  // Helper to determine if comparison has video content
  const isVideoComparison =
    comparison?.passA?.outputUrl &&
    (comparison.passA.outputUrl.endsWith('.mp4') || comparison.passA.outputUrl.includes('video'));

  // Keyboard navigation (includes zoom shortcuts, transport, flicker)
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
      if (e.key === 'ArrowLeft' && !e.metaKey && !e.shiftKey) goToPrevShot();
      if (e.key === 'ArrowRight' && !e.metaKey && !e.shiftKey) goToNextShot();
      // Zoom shortcuts: + / - or = / -
      if (e.key === '=' || e.key === '+') handleZoomIn();
      if (e.key === '-') handleZoomOut();
      if (e.key === '0') resetZoom();
      // Video transport shortcuts
      if (e.key === ' ' && !e.shiftKey) {
        e.preventDefault();
        togglePlayPause();
      }
      // Frame stepping with shift+arrow
      if (e.key === 'ArrowLeft' && e.shiftKey) stepFrame('backward');
      if (e.key === 'ArrowRight' && e.shiftKey) stepFrame('forward');
      // Flicker mode with 'f' key
      if (e.key === 'f') setFlickerMode(prev => !prev);
      // Magnifier mode with 'm' key
      if (e.key === 'm') setMagnifierEnabled(prev => !prev);
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      // Could add hold-spacebar flicker here if desired
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, [isOpen, onClose, handleZoomIn, handleZoomOut, resetZoom, togglePlayPause, stepFrame]);

  if (!isOpen) return null;

  const currentShot = availableShots[currentShotIndex];

  return (
    <TooltipProvider>
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm"
        onClick={e => e.target === e.currentTarget && onClose()}
      >
        {/* Close Button */}
        <button
          onClick={onClose}
          className="absolute top-4 right-4 z-50 rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
        >
          <X className="h-6 w-6" />
        </button>

        {/* Navigation Arrows */}
        {availableShots.length > 1 && (
          <>
            <button
              onClick={goToPrevShot}
              className="absolute top-1/2 left-4 -translate-y-1/2 rounded-full bg-white/10 p-3 text-white transition-colors hover:bg-white/20"
            >
              <ChevronLeft className="h-8 w-8" />
            </button>
            <button
              onClick={goToNextShot}
              className="absolute top-1/2 right-4 -translate-y-1/2 rounded-full bg-white/10 p-3 text-white transition-colors hover:bg-white/20"
            >
              <ChevronRight className="h-8 w-8" />
            </button>
          </>
        )}

        {/* Main Content */}
        <div className="w-full max-w-6xl px-16">
          {/* Shot Name & Navigation */}
          <div className="mb-2 flex items-center justify-center gap-4">
            <h2 className="text-lg font-medium text-white/80">
              {comparison?.shotName || currentShot?.shotName || 'A/B Comparison'}
            </h2>
            {availableShots.length > 1 && (
              <span className="text-sm text-gray-500">
                ({currentShotIndex + 1} / {availableShots.length})
              </span>
            )}
          </div>

          {/* Professional Metadata Header - DaVinci Resolve Style */}
          {comparison?.passA && comparison?.passB && (
            <div className="mb-3 flex items-stretch justify-between overflow-hidden rounded-lg border border-white/10 bg-black/40">
              {/* Left Side (Quality A) Metadata */}
              <div className="flex-1 border-r border-white/10 px-4 py-2">
                <div className="flex items-center gap-3">
                  <span
                    className={clsx(
                      'rounded px-2 py-0.5 text-xs font-bold tracking-wider uppercase',
                      QUALITY_COLORS[qualityA]
                    )}
                  >
                    {qualityA}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span className="font-mono text-sm text-white/80">
                    {getResolutionLabel(comparison.passA)}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span className="max-w-[120px] truncate text-sm text-white/60">
                    {comparison.passA.model.split('/').pop()}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span className="font-mono text-sm text-green-400">
                    ${comparison.passA.cost.toFixed(2)}
                  </span>
                </div>
              </div>

              {/* Center Controls - Zoom */}
              <div className="flex items-center gap-1 bg-white/5 px-3">
                <Tooltip content="Zoom out (-)" side="top">
                  <button
                    onClick={handleZoomOut}
                    disabled={zoom <= 1}
                    className="rounded p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                  >
                    <ZoomOut className="h-4 w-4" />
                  </button>
                </Tooltip>
                <Tooltip content="Reset zoom (0)" side="top">
                  <button
                    onClick={resetZoom}
                    disabled={zoom === 1}
                    className="min-w-[48px] rounded px-2 py-1 font-mono text-xs text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                  >
                    {Math.round(zoom * 100)}%
                  </button>
                </Tooltip>
                <Tooltip content="Zoom in (+)" side="top">
                  <button
                    onClick={handleZoomIn}
                    disabled={zoom >= 8}
                    className="rounded p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                  >
                    <ZoomIn className="h-4 w-4" />
                  </button>
                </Tooltip>
                <div className="mx-1 h-6 w-px bg-white/10" />
                <Tooltip content="Flicker mode (F)" side="top">
                  <button
                    onClick={() => setFlickerMode(prev => !prev)}
                    className={clsx(
                      'rounded p-1.5 transition-colors',
                      flickerMode
                        ? 'bg-cyan-500/30 text-cyan-400'
                        : 'text-gray-400 hover:bg-white/10 hover:text-white'
                    )}
                  >
                    <Monitor className="h-4 w-4" />
                  </button>
                </Tooltip>
                <Tooltip content="Magnifier lens (M)" side="top">
                  <button
                    onClick={() => setMagnifierEnabled(prev => !prev)}
                    className={clsx(
                      'rounded p-1.5 transition-colors',
                      magnifierEnabled
                        ? 'bg-purple-500/30 text-purple-400'
                        : 'text-gray-400 hover:bg-white/10 hover:text-white'
                    )}
                  >
                    <Search className="h-4 w-4" />
                  </button>
                </Tooltip>
              </div>

              {/* Right Side (Quality B) Metadata */}
              <div className="flex-1 border-l border-white/10 px-4 py-2 text-right">
                <div className="flex items-center justify-end gap-3">
                  <span className="font-mono text-sm text-green-400">
                    ${comparison.passB.cost.toFixed(2)}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span className="max-w-[120px] truncate text-sm text-white/60">
                    {comparison.passB.model.split('/').pop()}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span className="font-mono text-sm text-white/80">
                    {getResolutionLabel(comparison.passB)}
                  </span>
                  <span className="text-sm text-white/60"></span>
                  <span
                    className={clsx(
                      'rounded px-2 py-0.5 text-xs font-bold tracking-wider uppercase',
                      QUALITY_COLORS[qualityB]
                    )}
                  >
                    {qualityB}
                  </span>
                </div>
              </div>
            </div>
          )}

          {/* Quality Selector - only if more than 2 qualities available */}
          {currentShot && currentShot.availableQualities.length > 2 && (
            <div className="mb-3 flex justify-center gap-4">
              <div className="flex items-center gap-2 rounded-lg bg-black/30 px-3 py-1.5">
                <span className="text-xs text-gray-500">Compare:</span>
                <select
                  value={qualityA}
                  onChange={e => setQualityA(e.target.value as RenderQuality)}
                  className="rounded border border-white/20 bg-white/10 px-2 py-0.5 text-sm text-white"
                >
                  {currentShot.availableQualities.map(q => (
                    <option key={q} value={q} className="bg-gray-900">
                      {q.charAt(0).toUpperCase() + q.slice(1)}
                    </option>
                  ))}
                </select>
                <span className="text-gray-500">vs</span>
                <select
                  value={qualityB}
                  onChange={e => setQualityB(e.target.value as RenderQuality)}
                  className="rounded border border-white/20 bg-white/10 px-2 py-0.5 text-sm text-white"
                >
                  {currentShot.availableQualities.map(q => (
                    <option key={q} value={q} className="bg-gray-900">
                      {q.charAt(0).toUpperCase() + q.slice(1)}
                    </option>
                  ))}
                </select>
              </div>
            </div>
          )}

          {/* Split-Screen Comparison */}
          {comparison?.passA && comparison?.passB ? (
            <div
              ref={containerRef}
              className={clsx(
                'relative aspect-video overflow-hidden rounded-lg bg-gray-900',
                isPanning
                  ? 'cursor-grabbing'
                  : zoomMode && zoom > 1
                    ? 'cursor-grab'
                    : magnifierEnabled
                      ? 'cursor-none'
                      : 'cursor-col-resize'
              )}
              onMouseDown={e => {
                if (magnifierEnabled) return; // Don't drag slider in magnifier mode
                // Check if clicking on the slider handle area
                const rect = containerRef.current?.getBoundingClientRect();
                if (rect) {
                  const x = e.clientX - rect.left;
                  const sliderX = (sliderPosition / 100) * rect.width;
                  const isNearSlider = Math.abs(x - sliderX) < 30;

                  if (isNearSlider && !e.altKey && !zoomMode) {
                    setIsDragging(true);
                  } else if ((e.altKey || zoomMode) && zoom > 1) {
                    handlePanStart(e);
                  } else if (!e.altKey && !zoomMode) {
                    setIsDragging(true);
                  }
                }
              }}
              onMouseMove={handleMagnifierMove}
              onMouseLeave={handleMagnifierLeave}
              onWheel={handleWheel}
            >
              {/* Synchronized transform wrapper for both sides */}
              <div
                className="absolute inset-0"
                style={{
                  transform: `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`,
                  transformOrigin: 'center center',
                  transition: isPanning ? 'none' : 'transform 0.1s ease-out',
                }}
              >
                {/* Left Side (Quality A) - Flicker mode or Split mode */}
                <div
                  className="absolute inset-0 overflow-hidden transition-opacity duration-75"
                  style={{
                    clipPath: flickerMode ? 'none' : `inset(0 ${100 - sliderPosition}% 0 0)`,
                    opacity: flickerMode ? (flickerShowA ? 1 : 0) : 1,
                  }}
                >
                  {comparison.passA.outputUrl.endsWith('.mp4') ||
                  comparison.passA.outputUrl.includes('video') ? (
                    <video
                      ref={videoARef}
                      src={comparison.passA.outputUrl}
                      className="h-full w-full object-contain"
                      autoPlay={isPlaying}
                      loop={isLooping}
                      muted
                      playsInline
                    />
                  ) : (
                    <img
                      src={comparison.passA.outputUrl}
                      alt={`${qualityA} quality`}
                      className="h-full w-full object-contain"
                      draggable={false}
                    />
                  )}
                </div>

                {/* Right Side (Quality B) - Flicker mode or Split mode */}
                <div
                  className="absolute inset-0 overflow-hidden transition-opacity duration-75"
                  style={{
                    clipPath: flickerMode ? 'none' : `inset(0 0 0 ${sliderPosition}%)`,
                    opacity: flickerMode ? (flickerShowA ? 0 : 1) : 1,
                  }}
                >
                  {comparison.passB.outputUrl.endsWith('.mp4') ||
                  comparison.passB.outputUrl.includes('video') ? (
                    <video
                      ref={videoBRef}
                      src={comparison.passB.outputUrl}
                      className="h-full w-full object-contain"
                      autoPlay={isPlaying}
                      loop={isLooping}
                      muted
                      playsInline
                    />
                  ) : (
                    <img
                      src={comparison.passB.outputUrl}
                      alt={`${qualityB} quality`}
                      className="h-full w-full object-contain"
                      draggable={false}
                    />
                  )}
                </div>
              </div>

              {/* Flicker Mode Indicator */}
              {flickerMode && (
                <div
                  className={clsx(
                    'absolute top-4 left-1/2 z-20 -translate-x-1/2 rounded-lg px-4 py-2 text-sm font-bold tracking-wider uppercase transition-all duration-75',
                    flickerShowA ? QUALITY_COLORS[qualityA] : QUALITY_COLORS[qualityB]
                  )}
                >
                  {flickerShowA ? qualityA : qualityB}
                </div>
              )}

              {/* Labels (outside transform to stay fixed) - hidden in flicker mode */}
              {!flickerMode && (
                <>
                  <div
                    className={clsx(
                      'absolute top-4 left-4 z-10 flex items-center gap-2 rounded-lg px-3 py-1.5',
                      QUALITY_COLORS[qualityA]
                    )}
                  >
                    {QUALITY_ICONS[qualityA]}
                    <span className="text-sm font-medium uppercase">{qualityA}</span>
                  </div>
                  <div
                    className={clsx(
                      'absolute top-4 right-4 z-10 flex items-center gap-2 rounded-lg px-3 py-1.5',
                      QUALITY_COLORS[qualityB]
                    )}
                  >
                    {QUALITY_ICONS[qualityB]}
                    <span className="text-sm font-medium uppercase">{qualityB}</span>
                  </div>
                </>
              )}

              {/* Slider Handle - hidden in flicker mode */}
              {!flickerMode && (
                <div
                  className="absolute top-0 bottom-0 z-20 w-1 cursor-col-resize bg-white/80"
                  style={{ left: `${sliderPosition}%`, transform: 'translateX(-50%)' }}
                >
                  <div className="absolute top-1/2 left-1/2 flex h-10 w-10 -translate-x-1/2 -translate-y-1/2 items-center justify-center rounded-full bg-white/90 shadow-lg">
                    <GripVertical className="h-5 w-5 text-gray-600" />
                  </div>
                </div>
              )}

              {/* Zoom indicator */}
              {zoom > 1 && !flickerMode && (
                <div className="absolute top-4 left-1/2 z-10 -translate-x-1/2 rounded-full bg-black/70 px-3 py-1.5 text-xs font-medium text-white/90">
                  {Math.round(zoom * 100)}%
                </div>
              )}

              {/* Help Hints */}
              {!isDragging && !isPanning && !flickerMode && !magnifierEnabled && (
                <div className="absolute bottom-4 left-1/2 z-10 flex -translate-x-1/2 gap-2">
                  <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                    Drag slider to compare
                  </div>
                  {zoom === 1 && (
                    <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                      Scroll to zoom
                    </div>
                  )}
                  {zoom > 1 && (
                    <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                      Hold  + drag to pan
                    </div>
                  )}
                </div>
              )}

              {/* Magnifier Lens - The "Pixel-Peeper" */}
              {magnifierEnabled && showMagnifier && containerSize.width > 0 && (
                <div
                  className="pointer-events-none absolute z-30 overflow-hidden rounded-full border-2 border-purple-400/80 shadow-xl"
                  style={{
                    width: MAGNIFIER_SIZE,
                    height: MAGNIFIER_SIZE,
                    left: magnifierPos.x - MAGNIFIER_SIZE / 2,
                    top: magnifierPos.y - MAGNIFIER_SIZE / 2,
                    boxShadow:
                      '0 0 20px rgba(168, 85, 247, 0.4), inset 0 0 10px rgba(0, 0, 0, 0.5)',
                  }}
                >
                  {/* Magnified Master (Right side - Quality B) content */}
                  <div
                    className="absolute"
                    style={{
                      width: containerSize.width,
                      height: containerSize.height,
                      transform: `scale(${MAGNIFIER_ZOOM})`,
                      transformOrigin: `${magnifierPos.x}px ${magnifierPos.y}px`,
                      left: -magnifierPos.x + MAGNIFIER_SIZE / 2,
                      top: -magnifierPos.y + MAGNIFIER_SIZE / 2,
                    }}
                  >
                    {comparison.passB.outputUrl.endsWith('.mp4') ||
                    comparison.passB.outputUrl.includes('video') ? (
                      <video
                        src={comparison.passB.outputUrl}
                        className="h-full w-full object-contain"
                        autoPlay={isPlaying}
                        loop={isLooping}
                        muted
                        playsInline
                      />
                    ) : (
                      <img
                        src={comparison.passB.outputUrl}
                        alt="Magnified master"
                        className="h-full w-full object-contain"
                        draggable={false}
                      />
                    )}
                  </div>
                  {/* Crosshair */}
                  <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
                    <div className="h-full w-px bg-purple-400/30" />
                    <div className="absolute h-px w-full bg-purple-400/30" />
                  </div>
                  {/* Quality label */}
                  <div className="absolute bottom-1 left-1/2 -translate-x-1/2 rounded bg-purple-500/80 px-2 py-0.5 text-[9px] font-bold tracking-wider text-white uppercase">
                    {qualityB} @ {MAGNIFIER_ZOOM}
                  </div>
                </div>
              )}

              {/* Magnifier Mode Hint */}
              {magnifierEnabled && !showMagnifier && (
                <div className="absolute bottom-4 left-1/2 z-10 -translate-x-1/2 rounded-full border border-purple-400/30 bg-purple-500/30 px-3 py-1.5 text-xs text-purple-300">
                  Hover to inspect {qualityB} at {MAGNIFIER_ZOOM} zoom
                </div>
              )}
            </div>
          ) : (
            <div className="flex aspect-video items-center justify-center rounded-lg bg-gray-900 text-gray-500">
              {availableShots.length === 0
                ? 'No comparisons available. Render at multiple quality levels first.'
                : 'Loading comparison...'}
            </div>
          )}

          {/* Professional Footer - Video Transport & Actions */}
          {comparison?.passA && comparison?.passB && (
            <div className="mt-3 flex items-center justify-between overflow-hidden rounded-lg border border-white/10 bg-black/40">
              {/* Left Side - Reject / Keep Draft */}
              <div className="flex-1 px-4 py-2.5">
                <button
                  onClick={handleRejectMaster}
                  disabled={!onRejectMaster}
                  className={clsx(
                    'flex items-center gap-2 rounded-lg px-4 py-2 transition-all',
                    onRejectMaster
                      ? 'border border-red-500/30 bg-red-500/20 text-red-400 hover:bg-red-500/30'
                      : 'cursor-not-allowed border border-white/10 bg-white/5 text-gray-500'
                  )}
                >
                  <XCircle className="h-4 w-4" />
                  <span className="text-sm font-medium">
                    Keep {qualityA.charAt(0).toUpperCase() + qualityA.slice(1)} Only
                  </span>
                </button>
              </div>

              {/* Center - Video Transport Controls */}
              <div className="flex items-center gap-1 bg-white/5 px-4 py-2.5">
                {isVideoComparison ? (
                  <>
                    {/* Frame step backward */}
                    <Tooltip content="Previous frame (Shift+)" side="top">
                      <button
                        onClick={() => stepFrame('backward')}
                        className="rounded p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                      >
                        <SkipBack className="h-4 w-4" />
                      </button>
                    </Tooltip>

                    {/* Play/Pause */}
                    <Tooltip content="Play/Pause (Space)" side="top">
                      <button
                        onClick={togglePlayPause}
                        className="rounded-full bg-white/10 p-2.5 text-white transition-colors hover:bg-white/20"
                      >
                        {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5" />}
                      </button>
                    </Tooltip>

                    {/* Frame step forward */}
                    <Tooltip content="Next frame (Shift+)" side="top">
                      <button
                        onClick={() => stepFrame('forward')}
                        className="rounded p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                      >
                        <SkipForward className="h-4 w-4" />
                      </button>
                    </Tooltip>

                    {/* Loop toggle */}
                    <Tooltip content="Toggle loop" side="top">
                      <button
                        onClick={() => setIsLooping(prev => !prev)}
                        className={clsx(
                          'rounded p-2 transition-colors',
                          isLooping
                            ? 'bg-blue-500/20 text-blue-400'
                            : 'text-gray-400 hover:bg-white/10 hover:text-white'
                        )}
                      >
                        <Repeat className="h-4 w-4" />
                      </button>
                    </Tooltip>

                    {/* Timecode */}
                    <div className="ml-2 rounded bg-black/40 px-2 py-1 font-mono text-xs text-white/70">
                      {formatTime(currentTime)} / {formatTime(duration)}
                    </div>
                  </>
                ) : (
                  /* Image mode - just show upgrade cost */
                  <div className="px-4 text-sm text-gray-400">
                    Upgrade cost:{' '}
                    <span className="font-medium text-green-400">
                      +${comparison.costDifference.toFixed(2)}
                    </span>
                  </div>
                )}
              </div>

              {/* Right Side - Accept Master */}
              <div className="flex flex-1 justify-end px-4 py-2.5">
                <button
                  onClick={handleAcceptMaster}
                  disabled={!onAcceptMaster}
                  className={clsx(
                    'flex items-center gap-2 rounded-lg px-4 py-2 transition-all',
                    onAcceptMaster
                      ? 'border border-green-500/30 bg-green-500/20 text-green-400 hover:bg-green-500/30'
                      : 'cursor-not-allowed border border-white/10 bg-white/5 text-gray-500'
                  )}
                >
                  <Check className="h-4 w-4" />
                  <span className="text-sm font-medium">
                    Approve {qualityB.charAt(0).toUpperCase() + qualityB.slice(1)}
                  </span>
                </button>
              </div>
            </div>
          )}

          {/* Seed Info - Compact row below footer */}
          {comparison?.passA &&
            comparison?.passB &&
            (comparison.passA.seed || comparison.passB.seed) && (
              <div className="mt-2 flex items-center justify-center gap-6 text-xs text-gray-500">
                {comparison.passA.seed && (
                  <div className="flex items-center gap-1.5">
                    <Hash className="h-3 w-3" />
                    <span className="text-gray-400">{qualityA}:</span>
                    <span className="font-mono">{comparison.passA.seed}</span>
                  </div>
                )}
                {comparison.passB.seed && (
                  <div className="flex items-center gap-1.5">
                    <Hash className="h-3 w-3" />
                    <span className="text-gray-400">{qualityB}:</span>
                    <span className="font-mono">{comparison.passB.seed}</span>
                  </div>
                )}
              </div>
            )}
        </div>
      </motion.div>
    </AnimatePresence>
    </TooltipProvider>
  );
}

// =============================================================================
// Simple A/B Lightbox - Direct comparison without Render Queue integration
// =============================================================================

interface SimpleABLightboxProps {
  isOpen: boolean;
  onClose: () => void;
  imageA: {
    url: string;
    label: string;
    sublabel?: string;
  };
  imageB: {
    url: string;
    label: string;
    sublabel?: string;
  };
  title?: string;
}

export function SimpleABLightbox({
  isOpen,
  onClose,
  imageA,
  imageB,
  title = 'A/B Comparison',
}: SimpleABLightboxProps) {
  const [sliderPosition, setSliderPosition] = useState(50);
  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // Synchronized Zoom & Pan State
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [zoomMode, setZoomMode] = useState(false);

  // Reset on open/close
  useEffect(() => {
    if (isOpen) {
      setSliderPosition(50);
      setZoom(1);
      setPan({ x: 0, y: 0 });
    }
  }, [isOpen]);

  // Handle slider drag
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging || !containerRef.current) return;

      const rect = containerRef.current.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
      setSliderPosition(percent);
    },
    [isDragging]
  );

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  // Zoom Controls
  const handleZoomIn = useCallback(() => {
    setZoom(prev => Math.min(prev * 1.5, 8));
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoom(prev => Math.max(prev / 1.5, 1));
  }, []);

  const resetZoom = useCallback(() => {
    setZoom(1);
    setPan({ x: 0, y: 0 });
  }, []);

  // Mouse wheel zoom
  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      if (!containerRef.current) return;
      e.preventDefault();

      const rect = containerRef.current.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoom = Math.min(Math.max(zoom * delta, 1), 8);

      if (newZoom !== zoom) {
        const scale = newZoom / zoom;
        const newPanX = mouseX - (mouseX - pan.x) * scale;
        const newPanY = mouseY - (mouseY - pan.y) * scale;

        setPan({ x: newPanX, y: newPanY });
        setZoom(newZoom);
      }
    },
    [zoom, pan]
  );

  // Pan handling
  const handlePanStart = useCallback(
    (e: React.MouseEvent) => {
      if (zoom <= 1) return;
      if (e.altKey || zoomMode) {
        setIsPanning(true);
        setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        e.preventDefault();
      }
    },
    [zoom, pan, zoomMode]
  );

  const handlePanMove = useCallback(
    (e: MouseEvent) => {
      if (!isPanning) return;
      setPan({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y,
      });
    },
    [isPanning, panStart]
  );

  const handlePanEnd = useCallback(() => {
    setIsPanning(false);
  }, []);

  useEffect(() => {
    if (isPanning) {
      document.addEventListener('mousemove', handlePanMove);
      document.addEventListener('mouseup', handlePanEnd);
      return () => {
        document.removeEventListener('mousemove', handlePanMove);
        document.removeEventListener('mouseup', handlePanEnd);
      };
    }
  }, [isPanning, handlePanMove, handlePanEnd]);

  // Keyboard controls
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
      if (e.key === 'Alt') setZoomMode(true);
      if (e.key === '=' || e.key === '+') handleZoomIn();
      if (e.key === '-') handleZoomOut();
      if (e.key === '0') resetZoom();
    };
    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === 'Alt') setZoomMode(false);
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, [isOpen, onClose, handleZoomIn, handleZoomOut, resetZoom]);

  const isVideo = (url: string) => url.endsWith('.mp4') || url.includes('video');

  if (!isOpen) return null;

  return (
    <TooltipProvider>
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm"
        onClick={e => e.target === e.currentTarget && onClose()}
      >
        {/* Close Button */}
        <button
          onClick={onClose}
          className="absolute top-4 right-4 z-50 rounded-lg bg-white/10 p-2 text-white transition-colors hover:bg-white/20"
        >
          <X className="h-6 w-6" />
        </button>

        <div className="w-full max-w-5xl px-8">
          {/* Header */}
          <div className="mb-4 flex items-center justify-between">
            <h2 className="text-xl font-bold text-white">{title}</h2>

            {/* Zoom Controls */}
            <div className="flex items-center gap-1 rounded-lg bg-white/5 p-1">
              <Tooltip content="Zoom out (-)" side="top">
                <button
                  onClick={handleZoomOut}
                  disabled={zoom <= 1}
                  className="rounded p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                >
                  <ZoomOut className="h-4 w-4" />
                </button>
              </Tooltip>
              <Tooltip content="Reset zoom (0)" side="top">
                <button
                  onClick={resetZoom}
                  disabled={zoom === 1}
                  className="min-w-[40px] rounded px-2 py-1 text-xs text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                >
                  {Math.round(zoom * 100)}%
                </button>
              </Tooltip>
              <Tooltip content="Zoom in (+)" side="top">
                <button
                  onClick={handleZoomIn}
                  disabled={zoom >= 8}
                  className="rounded p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white disabled:cursor-not-allowed disabled:opacity-30"
                >
                  <ZoomIn className="h-4 w-4" />
                </button>
              </Tooltip>
            </div>
          </div>

          {/* Split-Screen Comparison */}
          <div
            ref={containerRef}
            className={clsx(
              'relative aspect-video overflow-hidden rounded-lg bg-gray-900',
              isPanning
                ? 'cursor-grabbing'
                : zoomMode && zoom > 1
                  ? 'cursor-grab'
                  : 'cursor-col-resize'
            )}
            onMouseDown={e => {
              const rect = containerRef.current?.getBoundingClientRect();
              if (rect) {
                const x = e.clientX - rect.left;
                const sliderX = (sliderPosition / 100) * rect.width;
                const isNearSlider = Math.abs(x - sliderX) < 30;

                if (isNearSlider && !e.altKey && !zoomMode) {
                  setIsDragging(true);
                } else if ((e.altKey || zoomMode) && zoom > 1) {
                  handlePanStart(e);
                } else if (!e.altKey && !zoomMode) {
                  setIsDragging(true);
                }
              }
            }}
            onWheel={handleWheel}
          >
            {/* Synchronized transform wrapper */}
            <div
              className="absolute inset-0"
              style={{
                transform: `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`,
                transformOrigin: 'center center',
                transition: isPanning ? 'none' : 'transform 0.1s ease-out',
              }}
            >
              {/* Left Side (A) */}
              <div
                className="absolute inset-0 overflow-hidden"
                style={{ clipPath: `inset(0 ${100 - sliderPosition}% 0 0)` }}
              >
                {isVideo(imageA.url) ? (
                  <video
                    src={imageA.url}
                    className="h-full w-full object-contain"
                    autoPlay
                    loop
                    muted
                    playsInline
                  />
                ) : (
                  <img
                    src={imageA.url}
                    alt={imageA.label}
                    className="h-full w-full object-contain"
                    draggable={false}
                  />
                )}
              </div>

              {/* Right Side (B) */}
              <div
                className="absolute inset-0 overflow-hidden"
                style={{ clipPath: `inset(0 0 0 ${sliderPosition}%)` }}
              >
                {isVideo(imageB.url) ? (
                  <video
                    src={imageB.url}
                    className="h-full w-full object-contain"
                    autoPlay
                    loop
                    muted
                    playsInline
                  />
                ) : (
                  <img
                    src={imageB.url}
                    alt={imageB.label}
                    className="h-full w-full object-contain"
                    draggable={false}
                  />
                )}
              </div>
            </div>

            {/* Labels */}
            <div className="absolute top-4 left-4 z-10 flex flex-col rounded-lg bg-blue-500/20 px-3 py-1.5 text-blue-400">
              <span className="text-sm font-medium">{imageA.label}</span>
              {imageA.sublabel && (
                <span className="text-xs text-blue-300/70">{imageA.sublabel}</span>
              )}
            </div>
            <div className="absolute top-4 right-4 z-10 flex flex-col items-end rounded-lg bg-purple-500/20 px-3 py-1.5 text-purple-400">
              <span className="text-sm font-medium">{imageB.label}</span>
              {imageB.sublabel && (
                <span className="text-xs text-purple-300/70">{imageB.sublabel}</span>
              )}
            </div>

            {/* Slider Handle */}
            <div
              className="absolute top-0 bottom-0 z-20 w-1 cursor-col-resize bg-white/80"
              style={{ left: `${sliderPosition}%`, transform: 'translateX(-50%)' }}
            >
              <div className="absolute top-1/2 left-1/2 flex h-10 w-10 -translate-x-1/2 -translate-y-1/2 items-center justify-center rounded-full bg-white/90 shadow-lg">
                <GripVertical className="h-5 w-5 text-gray-600" />
              </div>
            </div>

            {/* Zoom indicator */}
            {zoom > 1 && (
              <div className="absolute top-4 left-1/2 z-10 -translate-x-1/2 rounded-full bg-black/70 px-3 py-1.5 text-xs font-medium text-white/90">
                {Math.round(zoom * 100)}%
              </div>
            )}

            {/* Help Hints */}
            {!isDragging && !isPanning && (
              <div className="absolute bottom-4 left-1/2 z-10 flex -translate-x-1/2 gap-2">
                <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                  Drag slider to compare
                </div>
                {zoom === 1 && (
                  <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                    Scroll to zoom
                  </div>
                )}
                {zoom > 1 && (
                  <div className="rounded-full bg-black/60 px-3 py-1.5 text-xs text-white/70">
                    Hold  + drag to pan
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      </motion.div>
    </AnimatePresence>
    </TooltipProvider>
  );
}
</file>

<file path="frontend/src/components/storyboard/CinematicTagsModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
'use client';

import { useState, useMemo, useEffect } from 'react';
import { Search, X, Check, ChevronDown, ChevronRight, Film } from 'lucide-react';
import { clsx } from 'clsx';
import {
  ALL_CATEGORIES,
  CATEGORY_MAP,
  CinematicTag,
  TagCategory,
  TagSubcategory,
  searchTags,
  getTagsForSubcategory,
} from '@/data/CinematicTags';
import { GENRE_TEMPLATES, GenreTemplate } from '@/data/GenreTemplates';
import { Genre } from '@/data/CameraPresets';

interface CinematicTagsModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectTag: (tag: CinematicTag, categoryId: string) => void;
  initialCategory?: string;
  embedded?: boolean;
  selectedTags?: string[];
}

export function CinematicTagsModal({
  isOpen,
  onClose,
  onSelectTag,
  initialCategory,
  embedded = false,
  selectedTags = [],
}: CinematicTagsModalProps) {
  const [activeCategory, setActiveCategory] = useState<string | null>(initialCategory || null);
  const [activeSubcategory, setActiveSubcategory] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [expandedSubcategories, setExpandedSubcategories] = useState<Set<string>>(new Set());
  const [selectedGenre, setSelectedGenre] = useState<Genre | null>(null);

  // Update active category when initialCategory changes
  useEffect(() => {
    if (initialCategory) {
      setActiveCategory(initialCategory);
      setActiveSubcategory(null);
    }
  }, [initialCategory]);

  const category = activeCategory ? CATEGORY_MAP[activeCategory] : null;
  const genreTemplate = selectedGenre ? GENRE_TEMPLATES[selectedGenre] : null;

  // Filter tags based on search and subcategory
  const filteredTags = useMemo(() => {
    let tags: CinematicTag[] = [];

    if (searchQuery) {
      return searchTags(searchQuery);
    }

    if (!category) {
      tags = [];
    } else if (activeSubcategory) {
      tags = getTagsForSubcategory(activeCategory!, activeSubcategory);
    } else {
      tags = category.tags;
    }

    // Apply Genre Sorting if active
    if (genreTemplate && tags.length > 0) {
      return [...tags].sort((a, b) => {
        const aRec = genreTemplate.recommendedTags.includes(a.id);
        const bRec = genreTemplate.recommendedTags.includes(b.id);
        const aAvoid = genreTemplate.avoidedTags.includes(a.id);
        const bAvoid = genreTemplate.avoidedTags.includes(b.id);

        // Recommended first
        if (aRec && !bRec) return -1;
        if (!aRec && bRec) return 1;

        // Avoided last
        if (aAvoid && !bAvoid) return 1;
        if (!aAvoid && bAvoid) return -1;

        return 0;
      });
    }

    return tags;
  }, [searchQuery, category, activeCategory, activeSubcategory, genreTemplate]);

  const toggleSubcategory = (subcategoryId: string) => {
    setExpandedSubcategories(prev => {
      const next = new Set(prev);
      if (next.has(subcategoryId)) {
        next.delete(subcategoryId);
      } else {
        next.add(subcategoryId);
      }
      return next;
    });
  };

  const handleSelectTag = (tag: CinematicTag) => {
    const categoryId = activeCategory || findCategoryForTag(tag.id);
    onSelectTag(tag, categoryId);
  };

  const findCategoryForTag = (tagId: string): string => {
    for (const cat of ALL_CATEGORIES) {
      if (cat.tags.some(t => t.id === tagId)) {
        return cat.id;
      }
    }
    return 'unknown';
  };

  if (!isOpen) return null;

  const content = (
    <div
      className={clsx(
        'flex flex-col overflow-hidden rounded-xl border border-white/10 bg-[#1a1a1a] shadow-2xl',
        embedded
          ? 'h-full max-h-full w-full max-w-[700px] min-w-[400px]'
          : 'max-h-[80vh] w-full max-w-2xl'
      )}
    >
      {/* Header */}
      <div className="flex items-center justify-between border-b border-white/10 p-4">
        <div className="flex items-center gap-4">
          <h2 className="text-lg font-bold text-white">
            {category ? (
              <span className="flex items-center gap-2">
                <span>{category.icon}</span>
                {category.label}
              </span>
            ) : (
              'Cinematic Tags'
            )}
          </h2>

          {/* Genre Selector */}
          <div className="group relative">
            <button className="flex items-center gap-2 rounded-lg border border-purple-500/30 bg-purple-500/10 px-3 py-1.5 text-xs font-medium text-purple-300 transition-colors hover:bg-purple-500/20">
              <Film className="h-3 w-3" />
              {selectedGenre ? (
                <span className="flex items-center gap-2">
                  <span>{GENRE_TEMPLATES[selectedGenre].icon}</span>
                  <span>{GENRE_TEMPLATES[selectedGenre].name}</span>
                </span>
              ) : (
                'AI Director: Genre'
              )}
              <ChevronDown className="h-3 w-3 opacity-50" />
            </button>

            <div className="absolute top-full left-0 z-50 mt-2 hidden max-h-64 w-48 overflow-y-auto rounded-lg border border-white/20 bg-[#1a1a1a] shadow-xl group-hover:block">
              <button
                onClick={() => setSelectedGenre(null)}
                className="w-full px-3 py-2 text-left text-xs text-gray-400 hover:bg-white/5 hover:text-white"
              >
                No Genre Filter
              </button>
              {Object.values(GENRE_TEMPLATES).map(template => (
                <button
                  key={template.id}
                  onClick={() => setSelectedGenre(template.id)}
                  className={clsx(
                    'flex w-full items-center justify-between px-3 py-2 text-left text-xs transition-colors hover:bg-white/5',
                    selectedGenre === template.id
                      ? 'bg-purple-500/10 text-purple-400'
                      : 'text-gray-300 hover:text-white'
                  )}
                >
                  <span className="flex items-center gap-2">
                    <span>{template.icon}</span>
                    <span>{template.name}</span>
                  </span>
                </button>
              ))}
            </div>
          </div>
        </div>

        <button onClick={onClose} className="text-gray-400 hover:text-white">
          <X className="h-5 w-5" />
        </button>
      </div>

      {/* Category Pills */}
      <div className="border-b border-white/10 p-4">
        <div className="flex flex-wrap gap-2">
          <button
            onClick={() => {
              setActiveCategory(null);
              setActiveSubcategory(null);
            }}
            className={clsx(
              'rounded-lg px-3 py-1.5 text-xs font-medium transition-colors',
              activeCategory === null
                ? 'bg-blue-600 text-white'
                : 'bg-white/5 text-gray-300 hover:bg-white/10'
            )}
          >
            All
          </button>
          {ALL_CATEGORIES.map(cat => (
            <button
              key={cat.id}
              onClick={() => {
                setActiveCategory(cat.id);
                setActiveSubcategory(null);
                setSearchQuery('');
              }}
              className={clsx(
                'flex items-center gap-1.5 rounded-lg px-3 py-1.5 text-xs font-medium transition-colors',
                activeCategory === cat.id
                  ? 'bg-blue-600 text-white'
                  : 'bg-white/5 text-gray-300 hover:bg-white/10'
              )}
            >
              <span>{cat.icon}</span>
              {cat.label}
            </button>
          ))}
        </div>
      </div>

      {/* Search */}
      <div className="border-b border-white/5 bg-black/20 p-4">
        <div className="relative">
          <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-500" />
          <input
            type="text"
            placeholder="Search tags..."
            value={searchQuery}
            onChange={e => setSearchQuery(e.target.value)}
            className="w-full rounded-lg border border-white/10 bg-black/30 py-2 pr-3 pl-9 text-sm text-white placeholder-gray-500 focus:border-white/30 focus:outline-none"
          />
        </div>
        {selectedGenre && (
          <div className="mt-2 flex items-center gap-1.5 text-[10px] text-purple-400">
            <span className="h-1.5 w-1.5 animate-pulse rounded-full bg-purple-500" />
            AI Director active: Prioritizing {GENRE_TEMPLATES[selectedGenre].name} style
          </div>
        )}
      </div>

      {/* Content Area */}
      <div className="flex flex-1 overflow-hidden">
        {/* Subcategory Sidebar (if category selected) */}
        {category?.subcategories && !searchQuery && (
          <div className="w-48 overflow-y-auto border-r border-white/10 bg-black/10">
            <div className="space-y-1 p-2">
              <button
                onClick={() => setActiveSubcategory(null)}
                className={clsx(
                  'w-full rounded-lg px-3 py-2 text-left text-xs transition-colors',
                  activeSubcategory === null
                    ? 'bg-blue-600/20 text-blue-400'
                    : 'text-gray-400 hover:bg-white/5 hover:text-white'
                )}
              >
                All {category.label}
              </button>
              {category.subcategories.map(sub => (
                <button
                  key={sub.id}
                  onClick={() => setActiveSubcategory(sub.id)}
                  className={clsx(
                    'flex w-full items-center justify-between rounded-lg px-3 py-2 text-left text-xs transition-colors',
                    activeSubcategory === sub.id
                      ? 'bg-blue-600/20 text-blue-400'
                      : 'text-gray-400 hover:bg-white/5 hover:text-white'
                  )}
                >
                  <span>{sub.label}</span>
                  <span className="text-[10px] opacity-50">{sub.tagIds.length}</span>
                </button>
              ))}
            </div>
          </div>
        )}

        {/* Tags Grid */}
        <div className="scroller flex-1 overflow-y-auto p-4">
          {searchQuery ? (
            // Search Results
            <div className="space-y-2">
              <p className="mb-3 text-xs text-gray-500">
                {filteredTags.length} results for "{searchQuery}"
              </p>
              {filteredTags.map(tag => (
                <TagItem
                  key={tag.id}
                  tag={tag}
                  isSelected={selectedTags.includes(tag.id)}
                  isRecommended={
                    selectedGenre
                      ? GENRE_TEMPLATES[selectedGenre].recommendedTags.includes(tag.id)
                      : false
                  }
                  onClick={() => handleSelectTag(tag)}
                />
              ))}
            </div>
          ) : category ? (
            // Category View
            activeSubcategory ? (
              // Subcategory tags
              <div className="space-y-2">
                {filteredTags.map(tag => (
                  <TagItem
                    key={tag.id}
                    tag={tag}
                    isSelected={selectedTags.includes(tag.id)}
                    isRecommended={
                      selectedGenre
                        ? GENRE_TEMPLATES[selectedGenre].recommendedTags.includes(tag.id)
                        : false
                    }
                    onClick={() => handleSelectTag(tag)}
                  />
                ))}
              </div>
            ) : (
              // All tags in category, grouped by subcategory
              <div className="space-y-6">
                {category.subcategories?.map(sub => {
                  // Use the helper but filter by genre if needed
                  const subTags = getTagsForSubcategory(category.id, sub.id);

                  // Manually sort subcategory tags because standard getTagsFor... returns default order
                  let displayTags = subTags;
                  if (genreTemplate) {
                    displayTags = [...subTags].sort((a, b) => {
                      const aRec = genreTemplate.recommendedTags.includes(a.id);
                      const bRec = genreTemplate.recommendedTags.includes(b.id);
                      if (aRec && !bRec) return -1;
                      if (!aRec && bRec) return 1;
                      return 0;
                    });
                  }

                  const isExpanded = expandedSubcategories.has(sub.id);

                  return (
                    <div key={sub.id} className="space-y-2">
                      <button
                        onClick={() => toggleSubcategory(sub.id)}
                        className="flex items-center gap-2 text-xs font-bold tracking-wider text-gray-400 uppercase transition-colors hover:text-white"
                      >
                        {isExpanded ? (
                          <ChevronDown className="h-3 w-3" />
                        ) : (
                          <ChevronRight className="h-3 w-3" />
                        )}
                        {sub.label}
                        <span className="text-[10px] font-normal opacity-50">
                          ({subTags.length})
                        </span>
                      </button>

                      {isExpanded && (
                        <div className="grid grid-cols-2 gap-2 pl-5">
                          {displayTags.map(tag => (
                            <TagItem
                              key={tag.id}
                              tag={tag}
                              isSelected={selectedTags.includes(tag.id)}
                              isRecommended={
                                selectedGenre
                                  ? GENRE_TEMPLATES[selectedGenre].recommendedTags.includes(tag.id)
                                  : false
                              }
                              onClick={() => handleSelectTag(tag)}
                              compact
                            />
                          ))}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )
          ) : (
            // All Categories Overview
            <div className="space-y-6">
              {ALL_CATEGORIES.map(cat => (
                <div key={cat.id} className="space-y-2">
                  <button
                    onClick={() => setActiveCategory(cat.id)}
                    className="flex items-center gap-2 text-sm font-bold text-white transition-colors hover:text-blue-400"
                  >
                    <span>{cat.icon}</span>
                    {cat.label}
                    <span className="text-[10px] font-normal text-gray-500">
                      ({cat.tags.length} tags)
                    </span>
                  </button>
                  <p className="pl-6 text-xs text-gray-500">{cat.description}</p>

                  {/* Preview tags - if genre sorted, show recommended first */}
                  <div className="flex flex-wrap gap-1 pl-6">
                    {(() => {
                      let previewTags = [...cat.tags];
                      if (genreTemplate) {
                        previewTags.sort((a, b) => {
                          const aRec = genreTemplate.recommendedTags.includes(a.id);
                          const bRec = genreTemplate.recommendedTags.includes(b.id);
                          return aRec === bRec ? 0 : aRec ? -1 : 1;
                        });
                      }
                      return previewTags.slice(0, 5).map(tag => (
                        <div key={tag.id} className="relative">
                          <button
                            onClick={() => handleSelectTag(tag)}
                            className={clsx(
                              'rounded border px-2 py-1 text-[10px] transition-colors',
                              genreTemplate?.recommendedTags.includes(tag.id)
                                ? 'border-purple-500/30 bg-purple-500/10 text-purple-300 hover:bg-purple-500/20'
                                : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                            )}
                          >
                            {tag.name}
                          </button>
                        </div>
                      ));
                    })()}
                    {cat.tags.length > 5 && (
                      <button
                        onClick={() => setActiveCategory(cat.id)}
                        className="px-2 py-1 text-[10px] text-blue-400 hover:text-blue-300"
                      >
                        +{cat.tags.length - 5} more
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}

          {filteredTags.length === 0 && searchQuery && (
            <div className="py-8 text-center">
              <p className="text-sm text-gray-500">No tags found for "{searchQuery}"</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );

  if (embedded) {
    return content;
  }

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm"
      onClick={onClose}
    >
      <div onClick={e => e.stopPropagation()}>{content}</div>
    </div>
  );
}

// Tag Item Component
function TagItem({
  tag,
  isSelected,
  isRecommended,
  onClick,
  compact = false,
}: {
  tag: CinematicTag;
  isSelected: boolean;
  isRecommended?: boolean;
  onClick: () => void;
  compact?: boolean;
}) {
  return (
    <button
      onClick={onClick}
      className={clsx(
        'group relative flex items-center gap-3 rounded-lg border text-left transition-all',
        compact ? 'p-2' : 'p-3',
        isSelected
          ? 'border-blue-500/50 bg-blue-500/10'
          : isRecommended
            ? 'border-purple-500/20 bg-purple-500/5 hover:border-purple-500/40 hover:bg-purple-500/10'
            : 'border-white/5 bg-white/5 hover:border-white/10 hover:bg-white/10'
      )}
    >
      <div
        className={clsx(
          'flex flex-shrink-0 items-center justify-center rounded border transition-colors',
          compact ? 'h-5 w-5' : 'h-6 w-6',
          isSelected
            ? 'border-blue-400 bg-blue-500 text-white'
            : isRecommended
              ? 'border-purple-500/30 bg-purple-500/10 text-purple-400'
              : 'border-white/10 bg-white/5 text-gray-500'
        )}
      >
        {isSelected && <Check className={compact ? 'h-3 w-3' : 'h-4 w-4'} />}
        {!isSelected && isRecommended && <Film className={compact ? 'h-3 w-3' : 'h-4 w-4'} />}
      </div>
      <div className="min-w-0 flex-1">
        <div className="flex items-center gap-2">
          <h4
            className={clsx(
              'font-medium transition-colors',
              compact ? 'text-xs' : 'truncate text-sm',
              isSelected
                ? 'text-blue-200'
                : isRecommended
                  ? 'text-purple-300 group-hover:text-purple-200'
                  : 'text-white'
            )}
          >
            {tag.name}
          </h4>
          {isRecommended && !compact && (
            <span className="rounded bg-purple-500/20 px-1.5 py-0.5 text-[9px] font-bold tracking-wider text-purple-300 uppercase">
              AI Pick
            </span>
          )}
        </div>
        {!compact && tag.description && (
          <p
            className={clsx(
              'truncate text-[10px] transition-colors',
              isRecommended ? 'text-purple-400/70' : 'text-gray-500'
            )}
          >
            {tag.description}
          </p>
        )}
      </div>
    </button>
  );
}

// Compact version for dropdown replacement
export function CinematicTagsDropdown({
  categoryId,
  onSelectTag,
  className,
}: {
  categoryId: string;
  onSelectTag: (tag: CinematicTag) => void;
  className?: string;
}) {
  const [isOpen, setIsOpen] = useState(false);
  const category = CATEGORY_MAP[categoryId];

  if (!category) return null;

  return (
    <div className={clsx('relative', className)}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={clsx(
          'flex w-full items-center justify-between rounded border border-white/10 bg-white/5 px-2 py-1.5 text-xs text-gray-300 transition-colors hover:bg-white/10 hover:text-white',
          isOpen && 'border-white/30 bg-white/10 text-white'
        )}
      >
        <span className="flex items-center gap-1.5 truncate">
          <span>{category.icon}</span> {category.label}
        </span>
        <ChevronDown
          className={clsx('h-3 w-3 opacity-50 transition-transform', isOpen && 'rotate-180')}
        />
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)} />

          {/* Dropdown */}
          <div className="absolute top-full right-0 left-0 z-50 mt-1 max-h-64 overflow-y-auto rounded-lg border border-white/20 bg-[#1a1a1a] shadow-xl">
            {/* Subcategory Groups */}
            {category.subcategories?.map(sub => (
              <div key={sub.id}>
                <div className="sticky top-0 bg-white/5 px-3 py-1.5 text-[10px] font-bold text-gray-500 uppercase">
                  {sub.label}
                </div>
                {getTagsForSubcategory(categoryId, sub.id).map(tag => (
                  <button
                    key={tag.id}
                    onClick={() => {
                      onSelectTag(tag);
                      setIsOpen(false);
                    }}
                    className="w-full px-3 py-1.5 text-left text-xs text-gray-300 transition-colors hover:bg-blue-500/20 hover:text-blue-400"
                  >
                    {tag.name}
                  </button>
                ))}
              </div>
            ))}

            {/* Flat list if no subcategories */}
            {!category.subcategories &&
              category.tags.map(tag => (
                <button
                  key={tag.id}
                  onClick={() => {
                    onSelectTag(tag);
                    setIsOpen(false);
                  }}
                  className="w-full px-3 py-1.5 text-left text-xs text-gray-300 transition-colors hover:bg-blue-500/20 hover:text-blue-400"
                >
                  {tag.name}
                </button>
              ))}
          </div>
        </>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/app/projects/[id]/storyboard/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import dynamic from 'next/dynamic';
import { Plus, Play, Film, Clock, Loader2, ChevronLeft, Settings, X } from 'lucide-react';
import { BACKEND_URL } from '@/lib/api';
import StoryboardShot, { ShotData, calculateImageCost, calculateVideoCost, calculateTotalShotCost } from '@/components/storyboard/StoryboardShot';
import { formatCost } from '@/lib/ModelPricing';
import { clsx } from 'clsx';
import { Tooltip } from '@/components/ui/Tooltip';
import { usePageAutoSave, StoryboardSession, hasRecoverableContent } from '@/lib/pageSessionStore';
import { RecoveryToast } from '@/components/ui/RecoveryToast';

// Dynamic import for PromptBuilder (heavy modal component)
const PromptBuilder = dynamic(
  () => import('@/components/prompts/PromptBuilder').then(m => ({ default: m.PromptBuilder })),
  {
    loading: () => (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="h-6 w-6 animate-spin text-cyan-400" />
      </div>
    ),
    ssr: false,
  }
);

interface SceneChain {
  id: string;
  name: string;
  description?: string;
  status: string;
  targetDuration?: number;
  aspectRatio: string;
  segments: ShotData[];
}

export default function StoryboardPage() {
  const params = useParams();
  const router = useRouter();
  const projectId = params.id as string;

  // Scene Chain state
  const [chains, setChains] = useState<SceneChain[]>([]);
  const [selectedChainId, setSelectedChainId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  // Create chain modal
  const [isCreating, setIsCreating] = useState(false);
  const [newChainName, setNewChainName] = useState('');
  const [newChainDescription, setNewChainDescription] = useState('');

  // Settings
  const [aspectRatio, setAspectRatio] = useState('16:9');
  const [frameModel, setFrameModel] = useState('fal-ai/flux/dev');

  // Popular image generation models for frame generation
  const frameModels = [
    { id: 'fal-ai/flux/dev', name: 'FLUX.1 Dev', provider: 'Fal' },
    { id: 'fal-ai/flux/schnell', name: 'FLUX.1 Schnell', provider: 'Fal' },
    { id: 'fal-ai/flux-pro', name: 'FLUX.1 Pro', provider: 'Fal' },
    { id: 'fal-ai/flux-pro/v1.1-ultra', name: 'FLUX 1.1 Pro Ultra', provider: 'Fal' },
    { id: 'fal-ai/recraft-v3', name: 'Recraft V3', provider: 'Fal' },
    { id: 'fal-ai/ideogram/v3', name: 'Ideogram V3', provider: 'Fal' },
    { id: 'fal-ai/stable-diffusion-v35-large', name: 'SD 3.5 Large', provider: 'Fal' },
    { id: 'fal-ai/imagen4/preview', name: 'Imagen 4', provider: 'Fal' },
  ];

  // Video resolution state
  const [videoResolution, setVideoResolution] = useState('720p');

  // Video resolution options by model family
  // Maps model ID patterns to available resolutions
  const VIDEO_RESOLUTION_MAP: Record<string, { id: string; label: string; pixels: string }[]> = {
    'kling': [
      { id: '480p', label: '480p', pixels: '854480' },
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'wan': [
      { id: '480p', label: '480p', pixels: '854480' },
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'luma': [
      { id: '540p', label: '540p', pixels: '960540' },
      { id: '720p', label: '720p', pixels: '1280720' },
    ],
    'minimax': [
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'vidu': [
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'ltx': [
      { id: '480p', label: '480p', pixels: '768512' },
      { id: '720p', label: '720p', pixels: '1280720' },
    ],
    'hunyuan': [
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'pixverse': [
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
    'default': [
      { id: '480p', label: '480p', pixels: '854480' },
      { id: '720p', label: '720p', pixels: '1280720' },
      { id: '1080p', label: '1080p', pixels: '19201080' },
    ],
  };

  // Generation state
  const [generatingShots, setGeneratingShots] = useState<Set<string>>(new Set());
  const [generatingFirstFrames, setGeneratingFirstFrames] = useState<Set<string>>(new Set());
  const [generatingLastFrames, setGeneratingLastFrames] = useState<Set<string>>(new Set());

  // Elements for @reference autocomplete
  const [elements, setElements] = useState<Array<{
    id: string;
    name: string;
    type?: string;
    url?: string;
    fileUrl?: string;
    thumbnail?: string;
    projectId?: string;
  }>>([]);

  // Smart Prompt Builder state
  const [isPromptBuilderOpen, setIsPromptBuilderOpen] = useState(false);
  const [promptBuilderTarget, setPromptBuilderTarget] = useState<{
    shotId: string;
    frameType: 'first' | 'last' | 'video'; // 'video' for video prompt enhancement
    imageModelId?: string; // The image model used to generate this frame
    videoModelId?: string; // The video model (for video prompt enhancement)
  } | null>(null);

  // Session recovery
  const [hasMounted, setHasMounted] = useState(false);
  const [showRecoveryToast, setShowRecoveryToast] = useState(false);
  const [recoverableSession, setRecoverableSession] = useState<StoryboardSession | null>(null);
  const {
    saveSession,
    getSession,
    clearSession,
    dismissRecovery,
    isRecoveryDismissed,
  } = usePageAutoSave<StoryboardSession>('storyboard');

  // Mount detection
  useEffect(() => {
    setHasMounted(true);
  }, []);

  // Check for recoverable session
  useEffect(() => {
    if (!hasMounted || !projectId) return;
    const session = getSession(projectId);
    if (session && hasRecoverableContent(session) && !isRecoveryDismissed(projectId)) {
      setRecoverableSession(session);
      setShowRecoveryToast(true);
    }
  }, [hasMounted, projectId, getSession, isRecoveryDismissed]);

  // Auto-save session (save current selection state)
  useEffect(() => {
    if (!projectId || !hasMounted) return;
    // Only save if there's meaningful selection
    if (!selectedChainId) return;

    const saveInterval = setInterval(() => {
      saveSession({
        projectId,
        selectedSceneChainId: selectedChainId,
        isDirty: true,
      });
    }, 500);
    return () => clearInterval(saveInterval);
  }, [projectId, hasMounted, selectedChainId, aspectRatio, saveSession]);

  const handleRestoreSession = () => {
    if (!recoverableSession) return;
    // Restore selection state
    if (recoverableSession.selectedSceneChainId) {
      setSelectedChainId(recoverableSession.selectedSceneChainId);
      // Fetch the chain details after restoring
      fetchChainDetails(recoverableSession.selectedSceneChainId);
    }
    setShowRecoveryToast(false);
    setRecoverableSession(null);
  };

  const handleDismissRecovery = () => {
    if (projectId) {
      dismissRecovery(projectId);
      clearSession(projectId);
    }
    setShowRecoveryToast(false);
    setRecoverableSession(null);
  };

  // Load chains and elements
  useEffect(() => {
    if (projectId) {
      fetchChains();
      fetchElements();
    }
  }, [projectId]);

  const fetchElements = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/elements`);
      if (res.ok) {
        const data = await res.json();
        const mapped = data.map((e: Record<string, unknown>) => ({
          id: e.id as string,
          name: e.name as string,
          type: e.type as string,
          url: (() => {
            const u = e.fileUrl as string;
            if (!u) return '';
            if (u.startsWith('http') || u.startsWith('data:')) return u;
            return `${BACKEND_URL}${u.startsWith('/') ? '' : '/'}${u}`;
          })(),
          fileUrl: e.fileUrl as string,
          thumbnail: e.thumbnail as string,
          projectId: e.projectId as string,
        }));
        setElements(mapped);
      }
    } catch (error) {
      console.error('Failed to fetch elements:', error);
    }
  };

  const fetchChains = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/scene-chains`);
      if (res.ok) {
        const data = await res.json();
        setChains(data);

        // Auto-select first chain if none selected
        if (!selectedChainId && data.length > 0) {
          setSelectedChainId(data[0].id);
        }
      }
    } catch (error) {
      console.error('Failed to fetch scene chains:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchChainDetails = async (chainId: string) => {
    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/scene-chains/${chainId}`);
      if (res.ok) {
        const data = await res.json();
        setChains(prev => prev.map(c => (c.id === chainId ? data : c)));
      }
    } catch (error) {
      console.error('Failed to fetch chain details:', error);
    }
  };

  // Get selected chain
  const selectedChain = chains.find(c => c.id === selectedChainId);

  // Get available resolutions based on the selected chain's video model
  const getAvailableResolutions = () => {
    const defaultVideoModel = selectedChain?.segments?.[0]?.videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video';
    const modelLower = defaultVideoModel.toLowerCase();

    for (const [key, resolutions] of Object.entries(VIDEO_RESOLUTION_MAP)) {
      if (key !== 'default' && modelLower.includes(key)) {
        return resolutions;
      }
    }
    return VIDEO_RESOLUTION_MAP.default;
  };

  const availableResolutions = getAvailableResolutions();

  // Calculate total duration
  const totalDuration =
    selectedChain?.segments?.reduce((acc, seg) => acc + (seg.duration || 5), 0) || 0;

  // Calculate SPENT cost totals for the scene (actual iterations run)
  const spentCosts = selectedChain?.segments?.reduce(
    (acc, seg) => {
      const shotCost = calculateTotalShotCost(seg);
      return {
        imageCost: acc.imageCost + shotCost.imageCost,
        videoCost: acc.videoCost + shotCost.videoCost,
        imageIterations: acc.imageIterations + shotCost.imageIterations,
        videoIterations: acc.videoIterations + shotCost.videoIterations,
      };
    },
    { imageCost: 0, videoCost: 0, imageIterations: 0, videoIterations: 0 }
  ) || { imageCost: 0, videoCost: 0, imageIterations: 0, videoIterations: 0 };

  // Calculate ESTIMATED cost for next run (1 iteration of each)
  const estimatedImageCost = selectedChain?.segments?.reduce((acc, seg) => {
    const costPerFrame = calculateImageCost(seg.imageModel, seg.imageResolution);
    return acc + (costPerFrame * 2); // First frame + Last frame
  }, 0) || 0;

  const estimatedVideoCost = selectedChain?.segments?.reduce((acc, seg) => {
    return acc + calculateVideoCost(seg.videoModel, seg.videoResolution, seg.duration || 5);
  }, 0) || 0;

  // Use spent costs if any iterations exist, otherwise show estimates
  const hasIterations = spentCosts.imageIterations > 0 || spentCosts.videoIterations > 0;
  const totalImageCost = hasIterations ? spentCosts.imageCost : estimatedImageCost;
  const totalVideoCost = hasIterations ? spentCosts.videoCost : estimatedVideoCost;
  const totalCost = totalImageCost + totalVideoCost;

  // Create new chain
  const handleCreateChain = async () => {
    if (!newChainName.trim()) return;

    try {
      const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/scene-chains`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: newChainName,
          description: newChainDescription,
          aspectRatio,
        }),
      });

      if (res.ok) {
        const newChain = await res.json();
        setChains(prev => [...prev, newChain]);
        setSelectedChainId(newChain.id);
        setIsCreating(false);
        setNewChainName('');
        setNewChainDescription('');
      }
    } catch (error) {
      console.error('Failed to create chain:', error);
    }
  };

  // Add new shot/segment
  const handleAddShot = async () => {
    if (!selectedChainId) return;

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: '',
            duration: 10,
            orderIndex: selectedChain?.segments?.length || 0,
          }),
        }
      );

      if (res.ok) {
        fetchChainDetails(selectedChainId);
      }
    } catch (error) {
      console.error('Failed to add segment:', error);
    }
  };

  // Update shot
  const handleUpdateShot = async (shotId: string, updates: Partial<ShotData>) => {
    if (!selectedChainId) return;

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates),
        }
      );

      if (res.ok) {
        // Optimistically update local state
        setChains(prev =>
          prev.map(chain => {
            if (chain.id !== selectedChainId) return chain;
            return {
              ...chain,
              segments: chain.segments?.map(seg =>
                seg.id === shotId ? { ...seg, ...updates } : seg
              ),
            };
          })
        );
      }
    } catch (error) {
      console.error('Failed to update segment:', error);
    }
  };

  // Delete shot
  const handleDeleteShot = async (shotId: string) => {
    if (!selectedChainId) return;
    if (!confirm('Delete this shot?')) return;

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`,
        {
          method: 'DELETE',
        }
      );

      if (res.ok) {
        fetchChainDetails(selectedChainId);
      }
    } catch (error) {
      console.error('Failed to delete segment:', error);
    }
  };

  // Upload frame
  const handleUploadFrame = async (shotId: string, frameType: 'first' | 'last', file: File) => {
    if (!selectedChainId) return;

    const formData = new FormData();
    formData.append('file', file);
    formData.append('frameType', frameType);

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}/frame`,
        {
          method: 'POST',
          body: formData,
        }
      );

      if (res.ok) {
        const data = await res.json();
        // Update local state with the new frame URL
        setChains(prev =>
          prev.map(chain => {
            if (chain.id !== selectedChainId) return chain;
            return {
              ...chain,
              segments: chain.segments?.map(seg => {
                if (seg.id !== shotId) return seg;
                return {
                  ...seg,
                  [frameType === 'first' ? 'firstFrameUrl' : 'lastFrameUrl']: data.fileUrl,
                };
              }),
            };
          })
        );
      }
    } catch (error) {
      console.error('Failed to upload frame:', error);
    }
  };

  // Generate single shot
  const handleGenerateShot = async (shotId: string) => {
    if (!selectedChainId) return;

    setGeneratingShots(prev => new Set(prev).add(shotId));

    // Update local status to generating
    setChains(prev =>
      prev.map(chain => {
        if (chain.id !== selectedChainId) return chain;
        return {
          ...chain,
          segments: chain.segments?.map(seg =>
            seg.id === shotId ? { ...seg, status: 'generating' as const } : seg
          ),
        };
      })
    );

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}/generate`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ aspectRatio, resolution: videoResolution }),
        }
      );

      if (res.ok) {
        // Poll for completion
        pollShotStatus(shotId);
      } else {
        setGeneratingShots(prev => {
          const next = new Set(prev);
          next.delete(shotId);
          return next;
        });
        handleUpdateShot(shotId, { status: 'failed', failureReason: 'Failed to start generation' });
      }
    } catch (error) {
      console.error('Failed to generate shot:', error);
      setGeneratingShots(prev => {
        const next = new Set(prev);
        next.delete(shotId);
        return next;
      });
      handleUpdateShot(shotId, { status: 'failed', failureReason: 'Network error' });
    }
  };

  // Poll shot status
  const pollShotStatus = async (shotId: string) => {
    if (!selectedChainId) return;

    const pollInterval = setInterval(async () => {
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`
        );
        if (res.ok) {
          const data = await res.json();

          // Update local state
          setChains(prev =>
            prev.map(chain => {
              if (chain.id !== selectedChainId) return chain;
              return {
                ...chain,
                segments: chain.segments?.map(seg =>
                  seg.id === shotId ? { ...seg, ...data } : seg
                ),
              };
            })
          );

          // Check for terminal status
          if (data.status === 'complete' || data.status === 'failed') {
            clearInterval(pollInterval);
            setGeneratingShots(prev => {
              const next = new Set(prev);
              next.delete(shotId);
              return next;
            });

            // Increment video iteration count on successful completion
            if (data.status === 'complete') {
              const shot = selectedChain?.segments?.find(s => s.id === shotId);
              const newVideoIters = (shot?.videoIterations || 0) + 1;
              // Update local state
              setChains(prev =>
                prev.map(chain => {
                  if (chain.id !== selectedChainId) return chain;
                  return {
                    ...chain,
                    segments: chain.segments?.map(seg =>
                      seg.id === shotId ? { ...seg, videoIterations: newVideoIters } : seg
                    ),
                  };
                })
              );
              // Persist to backend
              handleUpdateShot(shotId, { videoIterations: newVideoIters });
            }
          }
        }
      } catch (error) {
        console.error('Polling error:', error);
        clearInterval(pollInterval);
        setGeneratingShots(prev => {
          const next = new Set(prev);
          next.delete(shotId);
          return next;
        });
      }
    }, 3000);
  };

  // Generate all shots
  const handleGenerateAll = async () => {
    if (!selectedChain?.segments?.length) return;

    for (const segment of selectedChain.segments) {
      if (segment.status !== 'complete' && segment.prompt?.trim()) {
        await handleGenerateShot(segment.id);
        // Small delay between shots
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
  };

  // Generate single frame from prompt
  const handleGenerateFrame = async (shotId: string, frameType: 'first' | 'last') => {
    if (!selectedChainId) return;

    // Set generating state
    if (frameType === 'first') {
      setGeneratingFirstFrames(prev => new Set(prev).add(shotId));
    } else {
      setGeneratingLastFrames(prev => new Set(prev).add(shotId));
    }

    try {
      // Get the shot to extract element references from the prompt
      const shot = selectedChain?.segments?.find(s => s.id === shotId);
      const prompt = frameType === 'first' ? shot?.firstFramePrompt : shot?.lastFramePrompt;

      // Extract @ElementName references from prompt and resolve to image URLs
      const elementReferences: string[] = [];
      if (prompt) {
        const mentionPattern = /@(\w+)/g;
        let match;
        while ((match = mentionPattern.exec(prompt)) !== null) {
          const elementName = match[1];
          const element = elements.find(e =>
            e.name.toLowerCase() === elementName.toLowerCase() ||
            e.name.replace(/\s+/g, '').toLowerCase() === elementName.toLowerCase()
          );
          if (element) {
            const imageUrl = element.url || element.fileUrl || element.thumbnail;
            if (imageUrl) {
              elementReferences.push(imageUrl);
            }
          }
        }
      }

      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}/generate-frame`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            frameType,
            model: frameModel,
            elementReferences: elementReferences.length > 0 ? elementReferences : undefined,
          }),
        }
      );

      if (res.ok) {
        const data = await res.json();
        // Update local state with the new frame URL and increment iteration count
        // Backend returns { url: "..." } not { frameUrl: "..." }
        const urlField = frameType === 'first' ? 'firstFrameUrl' : 'lastFrameUrl';
        const iterField = frameType === 'first' ? 'firstFrameIterations' : 'lastFrameIterations';
        setChains(prev =>
          prev.map(chain => {
            if (chain.id !== selectedChainId) return chain;
            return {
              ...chain,
              segments: chain.segments?.map(seg => {
                if (seg.id !== shotId) return seg;
                const currentIters = seg[iterField] || 0;
                return { ...seg, [urlField]: data.url, [iterField]: currentIters + 1 };
              }),
            };
          })
        );
        // Persist iteration count to backend
        const shot = selectedChain?.segments?.find(s => s.id === shotId);
        const newIterCount = (shot?.[iterField] || 0) + 1;
        handleUpdateShot(shotId, { [iterField]: newIterCount });
      } else {
        const errorData = await res.json();
        console.error('Failed to generate frame:', errorData.error);
        alert(`Failed to generate frame: ${errorData.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Failed to generate frame:', error);
      alert('Network error generating frame');
    } finally {
      // Clear generating state
      if (frameType === 'first') {
        setGeneratingFirstFrames(prev => {
          const next = new Set(prev);
          next.delete(shotId);
          return next;
        });
      } else {
        setGeneratingLastFrames(prev => {
          const next = new Set(prev);
          next.delete(shotId);
          return next;
        });
      }
    }
  };

  // Open Smart Prompt Builder for frame prompt enhancement
  const handleEnhanceFramePrompt = (shotId: string, frameType: 'first' | 'last') => {
    // Get the shot's image model selection for frame generation
    const shot = selectedChain?.segments?.find(s => s.id === shotId);
    setPromptBuilderTarget({
      shotId,
      frameType,
      imageModelId: shot?.imageModel || frameModel,
    });
    setIsPromptBuilderOpen(true);
  };

  // Open Smart Prompt Builder for video prompt enhancement
  const handleEnhanceVideoPrompt = (shotId: string) => {
    // Get the shot's video model selection for video generation
    const shot = selectedChain?.segments?.find(s => s.id === shotId);
    setPromptBuilderTarget({
      shotId,
      frameType: 'video',
      videoModelId: shot?.videoModel || 'fal-ai/kling-video/v2.1/master/image-to-video',
    });
    setIsPromptBuilderOpen(true);
  };

  // Get current prompt for Prompt Builder
  const getPromptBuilderInitialPrompt = () => {
    if (!promptBuilderTarget) return '';
    const shot = selectedChain?.segments?.find(s => s.id === promptBuilderTarget.shotId);
    if (!shot) return '';
    if (promptBuilderTarget.frameType === 'video') {
      return shot.prompt || '';
    }
    const field = promptBuilderTarget.frameType === 'first' ? 'firstFramePrompt' : 'lastFramePrompt';
    return shot[field] || '';
  };

  // Handle Prompt Builder result
  const handlePromptBuilderChange = (newPrompt: string) => {
    if (!promptBuilderTarget) return;
    if (promptBuilderTarget.frameType === 'video') {
      handleUpdateShot(promptBuilderTarget.shotId, { prompt: newPrompt });
    } else {
      const field = promptBuilderTarget.frameType === 'first' ? 'firstFramePrompt' : 'lastFramePrompt';
      handleUpdateShot(promptBuilderTarget.shotId, { [field]: newPrompt });
    }
    setIsPromptBuilderOpen(false);
    setPromptBuilderTarget(null);
  };

  // Format duration for display
  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
  };

  if (loading) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-zinc-950 text-white">
        <Loader2 className="h-8 w-8 animate-spin text-purple-500" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-zinc-950 text-white">
      {/* Session Recovery Toast */}
      {recoverableSession && (
        <RecoveryToast
          isVisible={showRecoveryToast}
          savedAt={recoverableSession.savedAt}
          pageType="storyboard"
          onRestore={handleRestoreSession}
          onDismiss={handleDismissRecovery}
        />
      )}

      {/* Header */}
      <header className="sticky top-0 z-40 border-b border-white/10 bg-zinc-950/90 backdrop-blur-lg">
        <div className="mx-auto max-w-7xl px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={() => router.push(`/projects/${projectId}`)}
                className="rounded-lg p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
              >
                <ChevronLeft className="h-5 w-5" />
              </button>
              <div>
                <h1 className="flex items-center gap-2 text-xl font-bold">
                  <Film className="h-5 w-5 text-purple-400" />
                  Storyboard
                </h1>
                {selectedChain && <p className="text-sm text-gray-400">{selectedChain.name}</p>}
              </div>
            </div>

            <div className="flex items-center gap-4">
              {/* Timeline summary */}
              {selectedChain && (
                <div className="flex items-center gap-2 rounded-lg border border-white/10 bg-white/5 px-3 py-1.5">
                  <Clock className="h-4 w-4 text-gray-400" />
                  <span className="text-sm text-white">
                    {selectedChain.segments?.length || 0} shots
                  </span>
                  <span className="text-gray-500"></span>
                  <span className="text-sm font-medium text-purple-400">
                    {formatDuration(totalDuration)}
                  </span>
                </div>
              )}

              {/* Cost summary */}
              {selectedChain && selectedChain.segments && selectedChain.segments.length > 0 && (
                <Tooltip
                  content={hasIterations
                    ? `Spent: ${spentCosts.imageIterations} frames (${formatCost(spentCosts.imageCost)}) + ${spentCosts.videoIterations} videos (${formatCost(spentCosts.videoCost)})`
                    : `Estimate: ${selectedChain.segments.length * 2} frames + ${selectedChain.segments.length} videos`
                  }
                  side="bottom"
                >
                  <div className="flex items-center gap-2 rounded-lg border border-white/10 bg-white/5 px-3 py-1.5">
                    <span className={clsx(
                      'text-[10px] uppercase',
                      hasIterations ? 'text-cyan-400' : 'text-gray-500'
                    )}>
                      {hasIterations ? 'Spent' : 'Est.'}
                    </span>
                    <span className="text-xs text-amber-400">{formatCost(totalImageCost)}</span>
                    <span className="text-gray-600">+</span>
                    <span className="text-xs text-emerald-400">{formatCost(totalVideoCost)}</span>
                    <span className="text-gray-600">=</span>
                    <span className="text-sm font-medium text-white">{formatCost(totalCost)}</span>
                  </div>
                </Tooltip>
              )}

              {/* Model selector for frame generation */}
              <Tooltip content="Image model for First/Last Frame generation" side="bottom">
                <select
                  value={frameModel}
                  onChange={e => setFrameModel(e.target.value)}
                  className="rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-white focus:ring-1 focus:ring-purple-500 focus:outline-none"
                >
                  {frameModels.map(model => (
                    <option key={model.id} value={model.id}>
                      {model.name}
                    </option>
                  ))}
                </select>
              </Tooltip>

              {/* Video resolution selector */}
              <Tooltip content="Video output resolution" side="bottom">
                <select
                  value={videoResolution}
                  onChange={e => setVideoResolution(e.target.value)}
                  className="w-24 rounded-lg border border-white/10 bg-white/5 px-2 py-1.5 text-sm text-white focus:ring-1 focus:ring-cyan-500 focus:outline-none"
                >
                  {availableResolutions.map(res => (
                    <option key={res.id} value={res.id}>
                      {res.label}
                    </option>
                  ))}
                </select>
              </Tooltip>

              {/* Aspect ratio selector */}
              <select
                value={aspectRatio}
                onChange={e => setAspectRatio(e.target.value)}
                className="rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-white focus:ring-1 focus:ring-purple-500 focus:outline-none"
              >
                <option value="16:9">16:9</option>
                <option value="9:16">9:16 (Vertical)</option>
                <option value="1:1">1:1 (Square)</option>
                <option value="4:3">4:3</option>
              </select>

              {/* Generate All button */}
              {selectedChain?.segments && selectedChain.segments.length > 0 && (
                <button
                  onClick={handleGenerateAll}
                  disabled={generatingShots.size > 0}
                  className={clsx(
                    'flex items-center gap-2 rounded-lg px-4 py-2 font-medium transition-all',
                    generatingShots.size > 0
                      ? 'cursor-wait bg-amber-500/20 text-amber-400'
                      : 'bg-purple-600 text-white hover:bg-purple-500'
                  )}
                >
                  {generatingShots.size > 0 ? (
                    <>
                      <Loader2 className="h-4 w-4 animate-spin" />
                      Generating ({generatingShots.size})
                    </>
                  ) : (
                    <>
                      <Play className="h-4 w-4" />
                      Generate All
                    </>
                  )}
                </button>
              )}
            </div>
          </div>
        </div>
      </header>

      <div className="mx-auto max-w-7xl px-6 py-8">
        <div className="flex gap-8">
          {/* Chain selector sidebar */}
          <div className="w-64 flex-shrink-0">
            <div className="sticky top-28">
              <div className="mb-4 flex items-center justify-between">
                <h2 className="text-sm font-semibold tracking-wider text-gray-400 uppercase">
                  Scenes
                </h2>
                <Tooltip content="New Scene" side="left">
                  <button
                    onClick={() => setIsCreating(true)}
                    className="rounded-lg p-1.5 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                  >
                    <Plus className="h-4 w-4" />
                  </button>
                </Tooltip>
              </div>

              <div className="space-y-2">
                {chains.length === 0 ? (
                  <div className="rounded-lg border-2 border-dashed border-white/10 py-8 text-center text-sm text-gray-500">
                    <Film className="mx-auto mb-2 h-8 w-8 opacity-50" />
                    <p>No scenes yet</p>
                    <button
                      onClick={() => setIsCreating(true)}
                      className="mt-2 text-purple-400 hover:text-purple-300"
                    >
                      Create first scene
                    </button>
                  </div>
                ) : (
                  chains.map(chain => (
                    <button
                      key={chain.id}
                      onClick={() => {
                        setSelectedChainId(chain.id);
                        fetchChainDetails(chain.id);
                      }}
                      className={clsx(
                        'w-full rounded-lg border p-3 text-left transition-all',
                        selectedChainId === chain.id
                          ? 'border-purple-500/30 bg-purple-500/10 text-white'
                          : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white'
                      )}
                    >
                      <div className="truncate font-medium">{chain.name}</div>
                      {chain.description && (
                        <div className="mt-1 truncate text-xs text-gray-500">
                          {chain.description}
                        </div>
                      )}
                      <div className="mt-2 flex items-center gap-2 text-xs text-gray-500">
                        <span>{chain.segments?.length || 0} shots</span>
                        <span></span>
                        <span>{chain.aspectRatio}</span>
                      </div>
                    </button>
                  ))
                )}
              </div>
            </div>
          </div>

          {/* Main content - shots list */}
          <div className="flex-1">
            {selectedChain ? (
              <>
                {/* Shots list */}
                <div className="space-y-6">
                  {selectedChain.segments?.length === 0 ? (
                    <div className="rounded-xl border-2 border-dashed border-white/10 py-16 text-center">
                      <Film className="mx-auto mb-4 h-12 w-12 text-gray-600" />
                      <p className="mb-4 text-gray-500">No shots in this scene yet</p>
                      <button
                        onClick={handleAddShot}
                        className="rounded-lg bg-purple-600 px-4 py-2 text-white transition-colors hover:bg-purple-500"
                      >
                        Add First Shot
                      </button>
                    </div>
                  ) : (
                    <>
                      {selectedChain.segments.map((shot, index) => (
                        <StoryboardShot
                          key={shot.id}
                          shot={{ ...shot, orderIndex: index, status: shot.status || 'pending' }}
                          sceneTitle={selectedChain.name}
                          sceneDescription={selectedChain.description}
                          elements={elements}
                          projectId={projectId}
                          onUpdate={handleUpdateShot}
                          onDelete={handleDeleteShot}
                          onGenerate={handleGenerateShot}
                          onUploadFrame={handleUploadFrame}
                          onGenerateFrame={handleGenerateFrame}
                          onEnhanceFramePrompt={handleEnhanceFramePrompt}
                          onEnhanceVideoPrompt={handleEnhanceVideoPrompt}
                          isGenerating={generatingShots.has(shot.id)}
                          isGeneratingFirstFrame={generatingFirstFrames.has(shot.id)}
                          isGeneratingLastFrame={generatingLastFrames.has(shot.id)}
                        />
                      ))}

                      {/* Add shot button */}
                      <button
                        onClick={handleAddShot}
                        className="flex w-full items-center justify-center gap-2 rounded-xl border-2 border-dashed border-white/10 py-4 text-gray-500 transition-all hover:border-white/30 hover:bg-white/5 hover:text-white"
                      >
                        <Plus className="h-5 w-5" />
                        Add Shot
                      </button>
                    </>
                  )}
                </div>

                {/* Timeline visualization */}
                {selectedChain.segments && selectedChain.segments.length > 0 && (
                  <div className="mt-8 rounded-xl border border-white/10 bg-white/5 p-4">
                    <h3 className="mb-3 text-sm font-medium text-gray-400">Timeline</h3>
                    <div className="flex h-12 gap-1">
                      {selectedChain.segments.map((shot, index) => {
                        const widthPercent =
                          totalDuration > 0
                            ? ((shot.duration || 5) / totalDuration) * 100
                            : 100 / selectedChain.segments.length;
                        return (
                          <div
                            key={shot.id}
                            className={clsx(
                              'flex h-full items-center justify-center rounded text-xs font-medium transition-all',
                              shot.status === 'complete'
                                ? 'border border-green-500/30 bg-green-500/30 text-green-300'
                                : shot.status === 'generating'
                                  ? 'animate-pulse border border-amber-500/30 bg-amber-500/30 text-amber-300'
                                  : shot.status === 'failed'
                                    ? 'border border-red-500/30 bg-red-500/30 text-red-300'
                                    : 'border border-white/10 bg-white/10 text-gray-400'
                            )}
                            style={{ width: `${widthPercent}%`, minWidth: '40px' }}
                            title={`Shot ${index + 1}: ${shot.duration || 5}s`}
                          >
                            {index + 1}
                          </div>
                        );
                      })}
                    </div>
                    <div className="mt-2 flex justify-between text-xs text-gray-500">
                      <span>0:00</span>
                      <span>{formatDuration(totalDuration)}</span>
                    </div>
                  </div>
                )}
              </>
            ) : (
              <div className="py-20 text-center">
                <Film className="mx-auto mb-4 h-16 w-16 text-gray-600" />
                <p className="mb-4 text-gray-500">
                  Select a scene or create a new one to get started
                </p>
                <button
                  onClick={() => setIsCreating(true)}
                  className="rounded-lg bg-purple-600 px-6 py-3 text-white transition-colors hover:bg-purple-500"
                >
                  Create Scene
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Create chain modal */}
      {isCreating && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4"
          onClick={() => setIsCreating(false)}
        >
          <div
            className="w-full max-w-md rounded-xl border border-white/10 bg-[#1a1a1a] p-6"
            onClick={e => e.stopPropagation()}
          >
            <h2 className="mb-4 text-xl font-bold">New Scene</h2>

            <div className="space-y-4">
              <div>
                <label className="mb-1 block text-sm text-gray-400">Scene Name</label>
                <input
                  type="text"
                  value={newChainName}
                  onChange={e => setNewChainName(e.target.value)}
                  placeholder="e.g., Opening Sequence"
                  className="w-full rounded-lg border border-white/10 bg-black/30 px-3 py-2 text-white placeholder-gray-600 focus:ring-1 focus:ring-purple-500 focus:outline-none"
                  autoFocus
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-gray-400">Description (Optional)</label>
                <textarea
                  value={newChainDescription}
                  onChange={e => setNewChainDescription(e.target.value)}
                  placeholder="Brief description of the scene..."
                  rows={3}
                  className="w-full resize-none rounded-lg border border-white/10 bg-black/30 px-3 py-2 text-white placeholder-gray-600 focus:ring-1 focus:ring-purple-500 focus:outline-none"
                />
              </div>
            </div>

            <div className="mt-6 flex justify-end gap-3">
              <button
                onClick={() => setIsCreating(false)}
                className="px-4 py-2 text-gray-400 transition-colors hover:text-white"
              >
                Cancel
              </button>
              <button
                onClick={handleCreateChain}
                disabled={!newChainName.trim()}
                className="rounded-lg bg-purple-600 px-4 py-2 text-white transition-colors hover:bg-purple-500 disabled:cursor-not-allowed disabled:opacity-50"
              >
                Create Scene
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Smart Prompt Builder Modal */}
      {isPromptBuilderOpen && promptBuilderTarget && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
          <div className="relative max-h-[90vh] w-full max-w-2xl overflow-y-auto rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl">
            <div className="sticky top-0 z-10 flex items-center justify-between border-b border-white/10 bg-[#1a1a1a] px-6 py-4">
              <h2 className="text-lg font-semibold text-white">
                Smart Prompt Builder - {promptBuilderTarget.frameType === 'video' ? 'Video' : promptBuilderTarget.frameType === 'first' ? 'First Frame' : 'Last Frame'}
              </h2>
              <button
                onClick={() => {
                  setIsPromptBuilderOpen(false);
                  setPromptBuilderTarget(null);
                }}
                className="text-gray-400 hover:text-white"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            <PromptBuilder
              initialPrompt={getPromptBuilderInitialPrompt()}
              modelId={promptBuilderTarget.frameType === 'video'
                ? (promptBuilderTarget.videoModelId || 'fal-ai/kling-video/v2.1/master/image-to-video')
                : (promptBuilderTarget.imageModelId || frameModel)
              }
              generationType={promptBuilderTarget.frameType === 'video' ? 'video' : 'image'}
              elements={elements.map(e => ({
                id: e.id,
                name: e.name,
                type: (e.type as 'character' | 'prop' | 'location' | 'style') || 'character',
                description: '',
                imageUrl: e.url || e.fileUrl || e.thumbnail,
                consistencyWeight: 0.5,
              }))}
              initialLoRAs={[]}
              onPromptChange={(newPrompt, negativePrompt) => {
                handlePromptBuilderChange(newPrompt);
              }}
              onClose={() => {
                setIsPromptBuilderOpen(false);
                setPromptBuilderTarget(null);
              }}
            />
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/ShotNavigator.tsx">
import { useState, useRef, useEffect, useImperativeHandle, forwardRef } from 'react';
import {
  ChevronDown,
  ChevronUp,
  Play,
  X,
  Plus,
  Link2,
  Unlink,
  Video,
  Settings2,
  Eye,
  EyeOff,
  AlertTriangle,
  CheckCircle,
  Zap,
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { useDroppable } from '@dnd-kit/core';
import { BACKEND_URL } from '@/lib/api';
import { ContinuityHeatmap } from '@/components/continuity/ContinuityHeatmap';
import { RenderQueuePanel } from './RenderQueuePanel';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';

interface FrameSlot {
  id: string;
  type: 'beginning' | 'ending';
  shotIndex: number;
  imageUrl?: string | null;
  generationId?: string | null;
  prompt?: string;
}

interface Shot {
  id: string;
  orderIndex: number;
  prompt: string;
  duration: number;
  status: 'pending' | 'generating' | 'complete' | 'failed';
  firstFrameUrl?: string | null;
  lastFrameUrl?: string | null;
  outputUrl?: string | null;
  failureReason?: string | null;
}

interface SceneGroup {
  id: string;
  name: string;
  shots: Shot[];
}

interface ShotNavigatorProps {
  projectId: string;
  scenes?: any[]; // Legacy support
  activeDragId?: string | null;
  isOverNavigator?: boolean;
  onDropIndexChange?: (index: number | null) => void;
  onRemove?: (shotId: string) => void;
  onFrameDropExternal?: (
    shotId: string,
    frameType: 'beginning' | 'ending',
    imageUrl: string
  ) => void;
}

// Ref type for external access to navigator methods
export interface ShotNavigatorRef {
  handleFrameDrop: (
    shotId: string,
    frameType: 'beginning' | 'ending',
    imageUrl: string
  ) => Promise<void>;
  refreshShots: () => void;
}

export const ShotNavigator = forwardRef<ShotNavigatorRef, ShotNavigatorProps>(
  (
    {
      projectId,
      scenes = [],
      activeDragId,
      isOverNavigator,
      onDropIndexChange,
      onRemove,
      onFrameDropExternal,
    },
    ref
  ) => {
    const [isOpen, setIsOpen] = useState(true);
    const [sceneChains, setSceneChains] = useState<any[]>([]);
    const [selectedChainId, setSelectedChainId] = useState<string | null>(null);
    const [shots, setShots] = useState<Shot[]>([]);
    const [isCreatingChain, setIsCreatingChain] = useState(false);
    const [newChainName, setNewChainName] = useState('');

    // Continuity Check state
    const [continuityEnabled, setContinuityEnabled] = useState(false);
    const [continuityReferenceUrl, setContinuityReferenceUrl] = useState<string | null>(null);
    const [continuityTargetShot, setContinuityTargetShot] = useState<Shot | null>(null);
    const [showContinuityPanel, setShowContinuityPanel] = useState(false);

    // Container-level droppable
    const { setNodeRef: setContainerRef } = useDroppable({
      id: 'shot-navigator-container',
      data: { isContainer: true },
    });

    // Fetch scene chains
    useEffect(() => {
      if (projectId) {
        fetchSceneChains();
      }
    }, [projectId]);

    // Fetch shots when chain is selected
    useEffect(() => {
      if (selectedChainId) {
        fetchChainShots();
      }
    }, [selectedChainId]);

    const fetchSceneChains = async () => {
      try {
        const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/scene-chains`);
        if (res.ok) {
          const data = await res.json();
          setSceneChains(data);
          // Auto-select first chain if none selected
          if (data.length > 0 && !selectedChainId) {
            setSelectedChainId(data[0].id);
          }
        }
      } catch (error) {
        console.error('Failed to fetch scene chains:', error);
      }
    };

    const fetchChainShots = async () => {
      if (!selectedChainId) return;
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}`
        );
        if (res.ok) {
          const data = await res.json();
          setShots(data.segments || []);
        }
      } catch (error) {
        console.error('Failed to fetch chain:', error);
      }
    };

    const handleCreateChain = async () => {
      if (!newChainName.trim()) return;
      try {
        const res = await fetch(`${BACKEND_URL}/api/projects/${projectId}/scene-chains`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: newChainName }),
        });
        if (res.ok) {
          const newChain = await res.json();
          setSceneChains(prev => [...prev, newChain]);
          setSelectedChainId(newChain.id);
          setNewChainName('');
          setIsCreatingChain(false);
        } else {
          const errorData = await res.json().catch(() => ({}));
          console.error('Failed to create chain:', res.status, errorData);
          alert(`Failed to create scene: ${errorData.error || res.statusText}`);
        }
      } catch (error) {
        console.error('Failed to create chain:', error);
        alert('Failed to create scene - check console for details');
      }
    };

    const handleAddShot = async () => {
      if (!selectedChainId) return;
      try {
        const res = await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: '',
              duration: 5,
              orderIndex: shots.length,
            }),
          }
        );
        if (res.ok) {
          fetchChainShots();
        }
      } catch (error) {
        console.error('Failed to add shot:', error);
      }
    };

    const handleRemoveShot = async (shotId: string) => {
      if (!selectedChainId) return;
      try {
        await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`,
          {
            method: 'DELETE',
          }
        );
        fetchChainShots();
      } catch (error) {
        console.error('Failed to remove shot:', error);
      }
    };

    const handleFrameDropInternal = async (
      shotId: string,
      frameType: 'beginning' | 'ending',
      imageUrl: string
    ) => {
      if (!selectedChainId) return;

      const updateField = frameType === 'beginning' ? 'firstFrameUrl' : 'lastFrameUrl';

      try {
        await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`,
          {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ [updateField]: imageUrl }),
          }
        );
        fetchChainShots();
      } catch (error) {
        console.error('Failed to update frame:', error);
      }
    };

    // Expose methods via ref for parent component access
    useImperativeHandle(ref, () => ({
      handleFrameDrop: handleFrameDropInternal,
      refreshShots: fetchChainShots,
    }));

    const handleGenerateShot = async (shotId: string) => {
      if (!selectedChainId) return;
      try {
        await fetch(
          `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}/generate`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ aspectRatio: '16:9' }),
          }
        );
        // Start polling
        pollShotStatus(shotId);
      } catch (error) {
        console.error('Failed to generate shot:', error);
      }
    };

    const pollShotStatus = async (shotId: string) => {
      const poll = setInterval(async () => {
        try {
          const res = await fetch(
            `${BACKEND_URL}/api/projects/${projectId}/scene-chains/${selectedChainId}/segments/${shotId}`
          );
          if (res.ok) {
            const data = await res.json();
            if (data.status === 'complete' || data.status === 'failed') {
              clearInterval(poll);
              fetchChainShots();
            }
          }
        } catch (error) {
          clearInterval(poll);
        }
      }, 3000);
    };

    const showInsertIndicators = !!(activeDragId && isOverNavigator);
    const selectedChain = sceneChains.find(c => c.id === selectedChainId);
    const totalDuration = shots.reduce((sum, s) => sum + (s.duration || 5), 0);

    return (
      <TooltipProvider>
      <div className="border-b border-white/10 bg-[#0a0a0a]">
        {/* Header */}
        <button
          onClick={() => setIsOpen(!isOpen)}
          className="flex w-full items-center justify-between px-8 py-3 transition-colors hover:bg-white/5"
        >
          <div className="flex items-center gap-2 text-sm font-medium text-gray-300">
            <span>Shot Navigator</span>
            {isOpen ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />}
          </div>
          <div className="flex items-center gap-4 text-xs text-gray-500">
            <span>{shots.length} Shots</span>
            <span>{totalDuration}s Total</span>
          </div>
        </button>

        <AnimatePresence>
          {isOpen && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: 'auto', opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              className="overflow-hidden"
            >
              {/* Scene Chain Selector */}
              <div className="flex items-center gap-3 border-b border-white/5 px-8 py-2">
                <select
                  value={selectedChainId || ''}
                  onChange={e => setSelectedChainId(e.target.value || null)}
                  className="rounded border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-gray-300 focus:border-blue-500/50 focus:outline-none"
                >
                  <option value="">Select Scene...</option>
                  {sceneChains.map(chain => (
                    <option key={chain.id} value={chain.id}>
                      {chain.name}
                    </option>
                  ))}
                </select>

                {isCreatingChain ? (
                  <div className="flex items-center gap-2">
                    <input
                      type="text"
                      value={newChainName}
                      onChange={e => setNewChainName(e.target.value)}
                      placeholder="Scene name..."
                      className="w-40 rounded border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-gray-300 focus:border-blue-500/50 focus:outline-none"
                      autoFocus
                      onKeyDown={e => {
                        if (e.key === 'Enter') handleCreateChain();
                        if (e.key === 'Escape') setIsCreatingChain(false);
                      }}
                    />
                    <button
                      onClick={handleCreateChain}
                      className="rounded bg-blue-500/20 px-3 py-1.5 text-sm text-blue-400 hover:bg-blue-500/30"
                    >
                      Create
                    </button>
                    <button
                      onClick={() => setIsCreatingChain(false)}
                      className="p-1.5 text-gray-500 hover:text-gray-300"
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => setIsCreatingChain(true)}
                    className="flex items-center gap-1.5 rounded border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-gray-400 hover:bg-white/10 hover:text-gray-300"
                  >
                    <Plus className="h-3.5 w-3.5" />
                    New Scene
                  </button>
                )}

                {/* Continuity Check Toggle */}
                <div className="ml-auto flex items-center gap-2">
                  <button
                    onClick={() => setContinuityEnabled(!continuityEnabled)}
                    className={clsx(
                      'flex items-center gap-2 rounded border px-3 py-1.5 text-sm transition-all',
                      continuityEnabled
                        ? 'border-amber-500/30 bg-amber-500/20 text-amber-400 hover:bg-amber-500/30'
                        : 'border-white/10 bg-white/5 text-gray-500 hover:bg-white/10 hover:text-gray-300'
                    )}
                  >
                    {continuityEnabled ? (
                      <Eye className="h-3.5 w-3.5" />
                    ) : (
                      <EyeOff className="h-3.5 w-3.5" />
                    )}
                    Continuity Check
                  </button>
                </div>
              </div>

              {/* Shots Grid */}
              <div
                ref={setContainerRef}
                id="shot-navigator-container"
                className={clsx(
                  'overflow-x-auto px-8 py-6 transition-colors',
                  activeDragId && 'bg-white/[0.02]',
                  isOverNavigator && 'bg-blue-500/5'
                )}
              >
                {selectedChainId ? (
                  <div className="flex min-w-max items-start gap-2">
                    {shots.map((shot, index) => (
                      <ShotCard
                        key={shot.id}
                        shot={shot}
                        index={index}
                        showInsertIndicator={showInsertIndicators}
                        onRemove={handleRemoveShot}
                        onFrameDrop={handleFrameDropInternal}
                        onGenerate={handleGenerateShot}
                        activeDragId={activeDragId}
                        continuityEnabled={continuityEnabled}
                        referenceImageUrl={shots[0]?.firstFrameUrl}
                        onContinuityCheck={targetShot => {
                          setContinuityTargetShot(targetShot);
                          setContinuityReferenceUrl(shots[0]?.firstFrameUrl || null);
                          setShowContinuityPanel(true);
                        }}
                      />
                    ))}

                    {/* Add Shot Button */}
                    <button
                      onClick={handleAddShot}
                      className={clsx(
                        'flex h-[160px] w-[280px] flex-col items-center justify-center rounded-lg border-2 border-dashed transition-all',
                        shots.length === 0
                          ? 'border-blue-500/30 bg-blue-500/5 text-blue-400'
                          : 'border-white/10 text-gray-500 hover:border-white/20 hover:text-gray-400'
                      )}
                    >
                      <Plus className="mb-2 h-8 w-8" />
                      <span className="text-sm font-medium">Add Shot</span>
                      {shots.length === 0 && (
                        <span className="mt-1 text-xs text-gray-500">
                          or drag a generation here
                        </span>
                      )}
                    </button>
                  </div>
                ) : (
                  <div className="flex items-center justify-center py-8 text-sm text-gray-500">
                    Select or create a scene to start building your storyboard
                  </div>
                )}
              </div>

              {/* Render Queue Panel */}
              {selectedChainId && shots.length > 0 && (
                <div className="border-t border-white/10 px-8 py-3">
                  <RenderQueuePanel
                    projectId={projectId}
                    sceneChainId={selectedChainId}
                    shotCount={shots.length}
                    onRenderComplete={(quality, outputs) => {
                      console.log(`Render complete (${quality}):`, outputs);
                      fetchChainShots();
                    }}
                  />
                </div>
              )}

              {/* Continuity Heatmap Panel */}
              <AnimatePresence>
                {showContinuityPanel &&
                  continuityReferenceUrl &&
                  continuityTargetShot?.firstFrameUrl && (
                    <motion.div
                      initial={{ height: 0, opacity: 0 }}
                      animate={{ height: 'auto', opacity: 1 }}
                      exit={{ height: 0, opacity: 0 }}
                      className="overflow-hidden border-t border-white/10"
                    >
                      <div className="px-8 py-4">
                        <div className="mb-3 flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <AlertTriangle className="h-4 w-4 text-amber-400" />
                            <span className="text-sm font-medium text-gray-300">
                              Continuity Check: Shot 1  Shot{' '}
                              {shots.findIndex(s => s.id === continuityTargetShot.id) + 1}
                            </span>
                          </div>
                          <button
                            onClick={() => {
                              setShowContinuityPanel(false);
                              setContinuityTargetShot(null);
                            }}
                            className="p-1 text-gray-500 transition-colors hover:text-white"
                          >
                            <X className="h-4 w-4" />
                          </button>
                        </div>
                        <ContinuityHeatmap
                          referenceImageUrl={
                            continuityReferenceUrl.startsWith('http')
                              ? continuityReferenceUrl
                              : `${BACKEND_URL}${continuityReferenceUrl}`
                          }
                          generatedImageUrl={
                            continuityTargetShot.firstFrameUrl.startsWith('http')
                              ? continuityTargetShot.firstFrameUrl
                              : `${BACKEND_URL}${continuityTargetShot.firstFrameUrl}`
                          }
                          onClose={() => {
                            setShowContinuityPanel(false);
                            setContinuityTargetShot(null);
                          }}
                        />
                      </div>
                    </motion.div>
                  )}
              </AnimatePresence>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
      </TooltipProvider>
    );
  }
);

ShotNavigator.displayName = 'ShotNavigator';

interface ShotCardProps {
  shot: Shot;
  index: number;
  showInsertIndicator?: boolean;
  onRemove: (id: string) => void;
  onFrameDrop: (shotId: string, frameType: 'beginning' | 'ending', imageUrl: string) => void;
  onGenerate: (shotId: string) => void;
  activeDragId?: string | null;
  continuityEnabled?: boolean;
  referenceImageUrl?: string | null;
  onContinuityCheck?: (shot: Shot) => void;
}

function ShotCard({
  shot,
  index,
  showInsertIndicator,
  onRemove,
  onFrameDrop,
  onGenerate,
  activeDragId,
  continuityEnabled,
  referenceImageUrl,
  onContinuityCheck,
}: ShotCardProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const beginningInputRef = useRef<HTMLInputElement>(null);
  const endingInputRef = useRef<HTMLInputElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isUploading, setIsUploading] = useState<'beginning' | 'ending' | null>(null);

  // Droppable zones for beginning and ending frames
  const { setNodeRef: setBeginningRef, isOver: isOverBeginning } = useDroppable({
    id: `shot-${shot.id}-beginning`,
    data: { shotId: shot.id, frameType: 'beginning' },
  });

  const { setNodeRef: setEndingRef, isOver: isOverEnding } = useDroppable({
    id: `shot-${shot.id}-ending`,
    data: { shotId: shot.id, frameType: 'ending' },
  });

  // Handle file upload for frame slots
  const handleFileUpload = async (file: File, frameType: 'beginning' | 'ending') => {
    if (!file.type.startsWith('image/')) {
      alert('Please upload an image file');
      return;
    }

    setIsUploading(frameType);
    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${BACKEND_URL}/upload`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) throw new Error('Upload failed');

      const data = await response.json();
      const imageUrl = data.fileUrl || data.url;

      // Ensure URL is absolute
      const absoluteUrl = imageUrl.startsWith('http') ? imageUrl : `${BACKEND_URL}${imageUrl}`;

      // Call the frame drop handler with the uploaded image URL
      onFrameDrop(shot.id, frameType, absoluteUrl);
    } catch (error) {
      console.error('Upload error:', error);
      alert('Failed to upload image. Please try again.');
    } finally {
      setIsUploading(null);
    }
  };

  const handleFrameClick = (frameType: 'beginning' | 'ending') => {
    const inputRef = frameType === 'beginning' ? beginningInputRef : endingInputRef;
    inputRef.current?.click();
  };

  const handleMouseEnter = () => {
    if (shot.outputUrl && videoRef.current) {
      videoRef.current.currentTime = 0;
      videoRef.current.play().catch(() => {});
      setIsPlaying(true);
    }
  };

  const handleMouseLeave = () => {
    if (videoRef.current) {
      videoRef.current.pause();
      videoRef.current.currentTime = 0;
      setIsPlaying(false);
    }
  };

  const getImageUrl = (url?: string | null): string | undefined => {
    if (!url) return undefined;
    // Handle absolute URLs, data URLs, and relative URLs
    if (url.startsWith('http') || url.startsWith('data:')) return url;
    return `${BACKEND_URL}${url}`;
  };

  const hasBeginning = !!shot.firstFrameUrl;
  const hasEnding = !!shot.lastFrameUrl;
  const canGenerate = hasBeginning && shot.status !== 'generating';

  return (
    <div className="flex items-center gap-1">
      {/* Shot Card */}
      <div
        className={clsx(
          'flex w-[280px] flex-col rounded-lg border bg-white/5 transition-all',
          shot.status === 'generating'
            ? 'border-amber-500/50'
            : shot.status === 'complete'
              ? 'border-green-500/30'
              : shot.status === 'failed'
                ? 'border-red-500/30'
                : 'border-white/10'
        )}
      >
        {/* Header */}
        <div className="flex items-center justify-between border-b border-white/5 px-3 py-2">
          <div className="flex items-center gap-2">
            <span className="rounded bg-blue-500/20 px-2 py-0.5 text-xs font-medium text-blue-400">
              Shot {index + 1}
            </span>
            <span className="text-xs text-gray-500">{shot.duration}s</span>
          </div>
          <div className="flex items-center gap-1">
            {shot.status === 'generating' && (
              <span className="animate-pulse text-xs text-amber-400">Generating...</span>
            )}
            {/* Continuity Check Button - only show when enabled and shot has a beginning frame */}
            {continuityEnabled && shot.firstFrameUrl && referenceImageUrl && index > 0 && (
              <Tooltip content="Check visual continuity against reference" side="left">
                <button
                  onClick={() => onContinuityCheck?.(shot)}
                  className="rounded p-1 text-amber-400 transition-colors hover:bg-amber-500/10 hover:text-amber-300"
                >
                  <Eye className="h-3.5 w-3.5" />
                </button>
              </Tooltip>
            )}
            <button
              onClick={() => onRemove(shot.id)}
              className="p-1 text-gray-500 transition-colors hover:text-red-400"
            >
              <X className="h-3.5 w-3.5" />
            </button>
          </div>
        </div>

        {/* Hidden file inputs for click-to-upload */}
        <input
          ref={beginningInputRef}
          type="file"
          accept="image/*"
          className="hidden"
          onChange={e => {
            const file = e.target.files?.[0];
            if (file) handleFileUpload(file, 'beginning');
            e.target.value = ''; // Reset for re-upload
          }}
        />
        <input
          ref={endingInputRef}
          type="file"
          accept="image/*"
          className="hidden"
          onChange={e => {
            const file = e.target.files?.[0];
            if (file) handleFileUpload(file, 'ending');
            e.target.value = ''; // Reset for re-upload
          }}
        />

        {/* Frames Row */}
        <div className="flex items-center gap-2 p-3">
          {/* Beginning Frame */}
          <div
            ref={setBeginningRef}
            onClick={() => !hasBeginning && !isUploading && handleFrameClick('beginning')}
            className={clsx(
              'relative aspect-video flex-1 overflow-hidden rounded-lg border-2 border-dashed transition-all',
              !hasBeginning && !isUploading && 'cursor-pointer',
              isOverBeginning && activeDragId
                ? 'scale-105 border-blue-500 bg-blue-500/10'
                : hasBeginning
                  ? 'border-green-500/30 bg-green-500/5'
                  : 'border-white/20 hover:border-white/30 hover:bg-white/5'
            )}
          >
            {isUploading === 'beginning' ? (
              <div className="flex h-full w-full flex-col items-center justify-center text-blue-400">
                <div className="mb-1 h-5 w-5 animate-spin rounded-full border-2 border-blue-400 border-t-transparent" />
                <span className="text-[10px]">Uploading...</span>
              </div>
            ) : hasBeginning ? (
              <>
                <img
                  src={getImageUrl(shot.firstFrameUrl)}
                  alt="Beginning frame"
                  className="h-full w-full object-cover"
                />
                <div className="absolute inset-0 flex items-end justify-center bg-gradient-to-t from-black/60 to-transparent pb-1 opacity-0 transition-opacity hover:opacity-100">
                  <span className="text-[10px] font-medium text-white">Beginning</span>
                </div>
              </>
            ) : (
              <div className="flex h-full w-full flex-col items-center justify-center text-gray-500 transition-colors hover:text-gray-300">
                <Plus className="mb-1 h-4 w-4" />
                <span className="text-[10px]">Beginning</span>
                <span className="mt-0.5 text-[8px] text-gray-600">Click or drag</span>
              </div>
            )}
          </div>

          {/* Connection Line */}
          <div className="flex flex-col items-center gap-1">
            {hasBeginning && hasEnding ? (
              <Link2 className="h-4 w-4 text-green-400" />
            ) : (
              <Unlink className="h-4 w-4 text-gray-600" />
            )}
            <div
              className={clsx(
                'h-0.5 w-8 rounded-full',
                hasBeginning && hasEnding ? 'bg-green-500/50' : 'bg-white/10'
              )}
            />
          </div>

          {/* Ending Frame */}
          <div
            ref={setEndingRef}
            onClick={() => !hasEnding && !isUploading && handleFrameClick('ending')}
            className={clsx(
              'relative aspect-video flex-1 overflow-hidden rounded-lg border-2 border-dashed transition-all',
              !hasEnding && !isUploading && 'cursor-pointer',
              isOverEnding && activeDragId
                ? 'scale-105 border-purple-500 bg-purple-500/10'
                : hasEnding
                  ? 'border-purple-500/30 bg-purple-500/5'
                  : 'border-white/20 hover:border-white/30 hover:bg-white/5'
            )}
          >
            {isUploading === 'ending' ? (
              <div className="flex h-full w-full flex-col items-center justify-center text-purple-400">
                <div className="mb-1 h-5 w-5 animate-spin rounded-full border-2 border-purple-400 border-t-transparent" />
                <span className="text-[10px]">Uploading...</span>
              </div>
            ) : hasEnding ? (
              <>
                <img
                  src={getImageUrl(shot.lastFrameUrl)}
                  alt="Ending frame"
                  className="h-full w-full object-cover"
                />
                <div className="absolute inset-0 flex items-end justify-center bg-gradient-to-t from-black/60 to-transparent pb-1 opacity-0 transition-opacity hover:opacity-100">
                  <span className="text-[10px] font-medium text-white">Ending</span>
                </div>
              </>
            ) : (
              <div className="flex h-full w-full flex-col items-center justify-center text-gray-500 transition-colors hover:text-gray-300">
                <Plus className="mb-1 h-4 w-4" />
                <span className="text-[10px]">Ending</span>
                <span className="mt-0.5 text-[8px] text-gray-600">Click or drag</span>
              </div>
            )}
          </div>
        </div>

        {/* Output Preview / Generate Button */}
        {shot.outputUrl ? (
          <div
            className="px-3 pb-3"
            onMouseEnter={handleMouseEnter}
            onMouseLeave={handleMouseLeave}
          >
            <div className="relative aspect-video overflow-hidden rounded-lg border border-white/10 bg-black/50">
              <video
                ref={videoRef}
                src={getImageUrl(shot.outputUrl) || undefined}
                className="h-full w-full object-cover"
                muted
                playsInline
                loop
              />
              <div className="absolute inset-0 flex items-center justify-center bg-black/30 opacity-0 transition-opacity hover:opacity-100">
                <Play className="h-8 w-8 fill-white/20 text-white" />
              </div>
              <div className="absolute bottom-2 left-2 rounded bg-green-500/80 px-2 py-0.5 text-[10px] font-medium text-white">
                Complete
              </div>
            </div>
          </div>
        ) : (
          <div className="px-3 pb-3">
            <button
              onClick={() => canGenerate && onGenerate(shot.id)}
              disabled={!canGenerate || shot.status === 'generating'}
              className={clsx(
                'flex w-full items-center justify-center gap-2 rounded-lg py-2 text-sm font-medium transition-all',
                canGenerate && shot.status !== 'generating'
                  ? 'border border-blue-500/30 bg-blue-500/20 text-blue-400 hover:bg-blue-500/30'
                  : 'cursor-not-allowed border border-white/5 bg-white/5 text-gray-500'
              )}
            >
              {shot.status === 'generating' ? (
                <>
                  <div className="h-4 w-4 animate-spin rounded-full border-2 border-amber-400 border-t-transparent" />
                  Generating...
                </>
              ) : (
                <>
                  <Video className="h-4 w-4" />
                  {canGenerate ? 'Generate Video' : 'Add frames to generate'}
                </>
              )}
            </button>
          </div>
        )}

        {/* Error State */}
        {shot.status === 'failed' && shot.failureReason && (
          <div className="px-3 pb-3">
            <div className="rounded border border-red-500/20 bg-red-500/10 px-2 py-1 text-xs text-red-400">
              {shot.failureReason}
            </div>
          </div>
        )}
      </div>

      {/* Connection to next shot */}
      {index < 999 && ( // Always show connection placeholder
        <div className="flex w-4 items-center justify-center">
          <div className="h-2 w-2 rounded-full bg-white/10" />
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/EngineSelectorV2.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import {
  ChevronDown,
  Video,
  Image as ImageIcon,
  Sparkles,
  Clock,
  Layers,
  Music,
  Mic,
} from 'lucide-react';
import { clsx } from 'clsx';
import { EngineLibraryModal } from './EngineLibraryModal';
import { ALL_MODELS, PROVIDER_DEFINITIONS, getModelsByCapability } from '@/lib/ModelRegistry';
import { Tooltip } from '@/components/ui/Tooltip';

interface EngineSelectorProps {
  selectedProvider: string;
  selectedModel: string;
  onSelect: (provider: string, model: string) => void;
  className?: string; // Support custom class names
  mode?: 'image' | 'video';
  variant?: 'default' | 'compact';

  // New Props for internal controls
  quantity?: number;
  onQuantityChange?: (q: number) => void;
  duration?: string;
  onDurationChange?: (d: string) => void;
  audioFile?: File | null;
  onAudioChange?: (f: File | null) => void;
}

export function EngineSelectorV2({
  selectedProvider,
  selectedModel,
  onSelect,
  className,
  mode,
  variant = 'default',
  quantity,
  onQuantityChange,
  duration,
  onDurationChange,
  audioFile,
  onAudioChange,
}: EngineSelectorProps) {
  const [isLibraryOpen, setIsLibraryOpen] = useState(false);

  // Find current model info
  const currentModel = ALL_MODELS.find(m => m.id === selectedModel);
  // Find current provider info
  const providerDef = currentModel
    ? PROVIDER_DEFINITIONS[currentModel.provider]
    : PROVIDER_DEFINITIONS[selectedProvider] || PROVIDER_DEFINITIONS['fal'];

  // Capabilities
  const isVideo = currentModel?.type === 'video';
  const supportsAudio =
    currentModel?.capability === 'avatar' ||
    currentModel?.capability === 'text-to-video' ||
    currentModel?.capability === 'image-to-video';
  const supportedDurations = ['5', '10'];

  return (
    <div className={clsx('relative', className)}>
      <div className="flex flex-col gap-1.5">
        {variant === 'default' && (
          <label className="px-1 text-xs font-bold tracking-wider text-gray-500 uppercase">
            Generation Engine
          </label>
        )}

        <div className="flex items-center gap-2">
          {/* Main Selector */}
          <Tooltip content="Change Model" side="top">
            <button
              onClick={() => setIsLibraryOpen(true)}
              className={clsx(
                'group relative flex flex-1 items-center justify-between rounded-xl border border-white/10 bg-white/5 text-left transition-all hover:border-white/20 hover:bg-white/10',
                variant === 'compact' ? 'h-10 px-2' : 'p-3'
              )}
            >
            <div className="flex items-center gap-3">
              {/* Icon */}
              <div
                className={clsx(
                  'flex flex-shrink-0 items-center justify-center rounded-lg transition-colors',
                  providerDef?.bgColor || 'bg-gray-800',
                  variant === 'compact' ? 'h-6 w-6' : 'h-10 w-10'
                )}
              >
                {providerDef?.icon && (
                  <providerDef.icon
                    className={clsx(
                      variant === 'compact' ? 'h-3.5 w-3.5' : 'h-5 w-5',
                      providerDef.color
                    )}
                  />
                )}
              </div>

              {/* Text */}
              <div className="min-w-0">
                <div className="flex items-center gap-2">
                  <span
                    className={clsx(
                      'block max-w-[100px] truncate font-bold text-white transition-colors group-hover:text-blue-400 sm:max-w-none',
                      variant === 'compact' ? 'text-xs' : 'text-sm'
                    )}
                  >
                    {currentModel?.name || 'Select Model'}
                  </span>
                </div>
                {variant === 'default' && (
                  <div className="mt-0.5 flex items-center gap-2">
                    <span className={clsx('text-xs', providerDef?.color || 'text-gray-400')}>
                      {providerDef?.name || 'Unknown Provider'}
                    </span>
                    <span className="text-xs text-gray-600"></span>
                    <span className="line-clamp-1 w-32 text-xs text-gray-500 md:w-auto">
                      {currentModel?.desc || 'AI Generation Model'}
                    </span>
                  </div>
                )}
              </div>
            </div>

            <ChevronDown
              className={clsx(
                'ml-2 flex-shrink-0 text-gray-500 transition-colors group-hover:text-white',
                variant === 'compact' ? 'h-4 w-4' : 'h-5 w-5'
              )}
            />
            </button>
          </Tooltip>
        </div>
      </div>

      <EngineLibraryModal
        isOpen={isLibraryOpen}
        onClose={() => setIsLibraryOpen(false)}
        currentModelId={selectedModel}
        onSelect={model => onSelect(model.provider, model.id)}
        initialCategory={
          mode === 'video' ? 'text-to-video' : mode === 'image' ? 'text-to-image' : 'all'
        }
        quantity={quantity}
        onQuantityChange={onQuantityChange}
        duration={duration}
        onDurationChange={onDurationChange}
        audioFile={audioFile}
        onAudioChange={onAudioChange}
      />
    </div>
  );
}

/**
 * Simplified video-only provider selector
 * Used where only video generation is relevant (e.g. extending video)
 */
export function CloudVideoSelector({
  selected,
  onSelect,
}: {
  selected: string;
  onSelect: (provider: string, model: string) => void;
}) {
  // Get unique providers that have video models
  const videoModels = getModelsByCapability('text-to-video').concat(
    getModelsByCapability('image-to-video')
  );
  const providerIds = Array.from(new Set(videoModels.map(m => m.provider)));

  return (
    <div className="space-y-2">
      <label className="text-xs font-bold tracking-wider text-gray-400 uppercase">
        Cloud Video Provider
      </label>
      <div className="grid grid-cols-3 gap-2">
        {providerIds.map(providerId => {
          const provider = PROVIDER_DEFINITIONS[providerId];
          const count = videoModels.filter(m => m.provider === providerId).length;

          return (
            <button
              key={providerId}
              onClick={() => {
                // Select first video model for this provider
                const defaultModel = videoModels.find(m => m.provider === providerId);
                if (defaultModel) onSelect(providerId, defaultModel.id);
              }}
              className={clsx(
                'flex flex-col items-center rounded-xl border p-3 transition-all',
                selected === providerId
                  ? `${provider.bgColor} border-current ${provider.color.replace('text-', 'border-')}`
                  : 'border-white/10 bg-white/5 hover:border-white/20 hover:bg-white/10'
              )}
            >
              <provider.icon className={clsx('mb-1 h-6 w-6', provider.color)} />
              <span className="text-xs font-medium text-white">{provider.name}</span>
              <span className="text-[10px] text-gray-500">{count} models</span>
            </button>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/GenerationResults.tsx">
import { useState, useMemo } from 'react';
import { Generation, Element } from '@/lib/store';
import { GenerationCard } from '@/components/generations/GenerationCard';
import { GenerationSearch, GenerationSortFilterState } from '@/components/generations/GenerationSearch';
import { Copy, FilePlus, Trash2, CheckSquare, X, Download, Search } from 'lucide-react';
import { toast } from 'sonner';

interface GenerationResultsProps {
  generations: Generation[];
  elements: Element[];
  selectedGenerationIds: string[];
  onToggleSelection: (id: string, e: React.MouseEvent) => void;
  onSelectionChange: (ids: string[]) => void;

  // Actions
  onUpdate: (id: string, updates: Partial<Generation>) => Promise<void>;
  onDelete: (id: string) => Promise<void>;
  onIterate: (prompt: string) => Promise<void>;
  onUseSettings: (gen: Generation) => void;
  onAnimate: (url: string) => Promise<void>;
  onUpscale: (url: string, model: string) => Promise<void>;
  onRetake: (url: string) => void;
  onInpaint: (url: string, ar?: string) => void;
  onEnhanceVideo: (id: string, mode?: 'full' | 'audio-only' | 'smooth-only') => Promise<void>;
  onReshoot?: (imageUrl: string, instruction: string) => Promise<void>;

  // Batch
  onBatchMove: (sessionId: string) => Promise<void>;
  onBatchDelete: () => Promise<void>;
  onBatchDownload: () => Promise<void>;

  // Other UI
  sessions: { id: string; name: string }[];
  onEdit: (gen: Generation) => void;
  onSaveElement: (url: string, type: 'image' | 'video') => void;
  projectId: string;
}

export function GenerationResults({
  generations,
  elements,
  selectedGenerationIds,
  onToggleSelection,
  onSelectionChange,
  onUpdate,
  onDelete,
  onIterate,
  onUseSettings,
  onAnimate,
  onUpscale,
  onRetake,
  onInpaint,
  onEnhanceVideo,
  onReshoot,
  onBatchMove,
  onBatchDelete,
  onBatchDownload,
  sessions,
  onEdit,
  onSaveElement,
  projectId,
}: GenerationResultsProps) {
  // Search state
  const [searchResults, setSearchResults] = useState<any[] | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>('');

  // Sort & Filter state
  const [sortFilter, setSortFilter] = useState<GenerationSortFilterState>({
    sortBy: 'date',
    sortOrder: 'desc',
    filterMediaType: [],
    filterStatus: [],
    filterAspectRatio: [],
  });

  // Helper to determine media type from generation
  const getMediaType = (gen: Generation): 'image' | 'video' => {
    // Check output type first
    const outputType = gen.outputs?.[0]?.type;
    if (outputType) return outputType;

    // Fall back to URL extension check
    const url = gen.outputs?.[0]?.url || '';
    if (url.match(/\.(mp4|webm|mov|avi)$/i)) {
      return 'video';
    }
    return 'image';
  };

  // Helper to extract aspect ratio from generation
  const getAspectRatio = (gen: Generation): string => {
    return gen.aspectRatio || '16:9';
  };

  // Display either search results or all generations, with filtering and sorting applied
  const displayedGenerations = useMemo(() => {
    let result = searchResults !== null ? (searchResults as Generation[]) : generations;

    // Apply filters
    if (sortFilter.filterMediaType.length > 0) {
      result = result.filter(gen => sortFilter.filterMediaType.includes(getMediaType(gen)));
    }

    if (sortFilter.filterStatus.length > 0) {
      result = result.filter(gen => {
        const status = gen.status || 'succeeded';
        // Map various status values to our filter categories
        if (sortFilter.filterStatus.includes('succeeded') && status === 'succeeded') {
          return true;
        }
        if (sortFilter.filterStatus.includes('processing') && (status === 'running' || status === 'queued')) {
          return true;
        }
        if (sortFilter.filterStatus.includes('failed') && status === 'failed') {
          return true;
        }
        return false;
      });
    }

    if (sortFilter.filterAspectRatio.length > 0) {
      result = result.filter(gen => {
        const ar = getAspectRatio(gen);
        return sortFilter.filterAspectRatio.includes(ar);
      });
    }

    // Apply sorting
    result = [...result].sort((a, b) => {
      let comparison = 0;

      switch (sortFilter.sortBy) {
        case 'date':
          const dateA = new Date(a.createdAt || 0).getTime();
          const dateB = new Date(b.createdAt || 0).getTime();
          comparison = dateA - dateB;
          break;
        case 'name':
          const nameA = (a.inputPrompt || '').toLowerCase();
          const nameB = (b.inputPrompt || '').toLowerCase();
          comparison = nameA.localeCompare(nameB);
          break;
        case 'score':
          // For search results, use searchScore if available
          const scoreA = (a as any).searchScore || 0;
          const scoreB = (b as any).searchScore || 0;
          comparison = scoreA - scoreB;
          break;
      }

      return sortFilter.sortOrder === 'asc' ? comparison : -comparison;
    });

    return result;
  }, [searchResults, generations, sortFilter]);

  const handleSearchResults = (results: any[], query: string) => {
    setSearchResults(results);
    setSearchQuery(query);
  };

  const handleClearSearch = () => {
    setSearchResults(null);
    setSearchQuery('');
  };

  const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';

  const handleFindSimilarComposition = async (generationId: string) => {
    toast.loading('Finding similar compositions...', { id: 'find-similar' });
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/search/similar/${generationId}?type=framing`
      );
      if (res.ok) {
        const data = await res.json();
        if (data.results && data.results.length > 0) {
          setSearchResults(data.results);
          setSearchQuery(`Similar composition to #${generationId.slice(0, 8)}`);
          toast.success(`Found ${data.results.length} similar compositions`, { id: 'find-similar' });
        } else {
          toast.info('No similar compositions found. Try indexing more images.', { id: 'find-similar' });
        }
      }
    } catch (err) {
      console.error('Find similar composition failed:', err);
      toast.error('Failed to find similar compositions', { id: 'find-similar' });
    }
  };

  const handleFindSimilarLighting = async (generationId: string) => {
    toast.loading('Finding similar lighting...', { id: 'find-similar' });
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/search/similar/${generationId}?type=lighting`
      );
      if (res.ok) {
        const data = await res.json();
        if (data.results && data.results.length > 0) {
          setSearchResults(data.results);
          setSearchQuery(`Similar lighting to #${generationId.slice(0, 8)}`);
          toast.success(`Found ${data.results.length} with similar lighting`, { id: 'find-similar' });
        } else {
          toast.info('No similar lighting found. Try indexing more images.', { id: 'find-similar' });
        }
      }
    } catch (err) {
      console.error('Find similar lighting failed:', err);
      toast.error('Failed to find similar lighting', { id: 'find-similar' });
    }
  };

  const handleFindSimilarVisual = async (generationId: string) => {
    toast.loading('Finding visually similar images (AI)...', { id: 'find-similar' });
    try {
      const res = await fetch(
        `${BACKEND_URL}/api/projects/${projectId}/search/vector/similar/${generationId}`
      );
      if (res.ok) {
        const data = await res.json();
        if (data.results && data.results.length > 0) {
          // Convert to expected format
          const formattedResults = data.results.map((r: any) => ({
            ...r,
            id: r.generationId,
            score: Math.round(r.similarity * 100),
          }));
          setSearchResults(formattedResults);
          setSearchQuery(`Visually similar to #${generationId.slice(0, 8)}`);
          toast.success(`Found ${data.results.length} visually similar`, { id: 'find-similar' });
        } else {
          toast.info('No visually similar images found. Try embedding more images.', { id: 'find-similar' });
        }
      } else {
        const errData = await res.json();
        toast.error(errData.error || 'Vector search failed', { id: 'find-similar' });
      }
    } catch (err) {
      console.error('Find similar visual failed:', err);
      toast.error('Failed to find similar images', { id: 'find-similar' });
    }
  };

  const handleBatchCopyLinks = () => {
    const selectedGens = generations.filter(g => selectedGenerationIds.includes(g.id));
    const links = selectedGens
      .map(g => {
        const url = g.outputs?.[0]?.url;
        if (!url) return null;
        return url.startsWith('http') ? url : `http://localhost:3001${url}`;
      })
      .filter(Boolean)
      .join('\n');

    if (links) {
      navigator.clipboard.writeText(links);
      toast.success(`Copied ${selectedGenerationIds.length} links to clipboard!`);
    }
  };

  const selectAllGenerations = () => {
    // Select only the currently displayed (filtered) generations
    onSelectionChange(displayedGenerations.map(g => g.id));
  };

  const deselectAllGenerations = () => {
    onSelectionChange([]);
  };

  return (
    <div className="flex-1 overflow-y-auto p-8 pb-32">
      <header className="mb-8">
        {/* Full-width title bar with integrated search - matches mockup exactly */}
        <GenerationSearch
          projectId={projectId}
          onSearchResults={handleSearchResults}
          onClearSearch={handleClearSearch}
          onSelectAll={selectAllGenerations}
          onSortFilterChange={setSortFilter}
        />
      </header>

      <div className="grid grid-cols-1 gap-8 lg:grid-cols-3">
        <div className="lg:col-span-3">
          {/* Dynamic heading based on search state */}
          <h2 className="mb-4 flex items-center gap-2 text-xl font-bold">
            {searchQuery ? (
              <>
                <Search className="h-5 w-5 text-purple-400" />
                Results for "{searchQuery}"
                <span className="text-sm font-normal text-white/50">
                  ({displayedGenerations.length} found)
                </span>
              </>
            ) : (
              'Recent Generations'
            )}
          </h2>
          <div
            className="grid gap-3"
            style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(260px, 1fr))' }}
          >
            {displayedGenerations.map((gen, index) => (
              <GenerationCard
                key={gen.id || `gen-${index}`}
                generation={gen}
                elements={elements}
                onUpdate={onUpdate}
                onDelete={onDelete}
                onIterate={onIterate}
                onUseSettings={onUseSettings}
                onAnimate={onAnimate}
                onUpscale={onUpscale}
                onEdit={() => onEdit(gen)}
                onRetake={onRetake}
                onInpaint={onInpaint}
                onEnhanceVideo={onEnhanceVideo}
                onReshoot={onReshoot}
                isSelected={selectedGenerationIds.includes(gen.id)}
                onToggleSelection={e => onToggleSelection(gen.id, e)}
                onSaveAsElement={(url, type) => onSaveElement(url, type)}
                onFindSimilarComposition={handleFindSimilarComposition}
                onFindSimilarLighting={handleFindSimilarLighting}
                onFindSimilarVisual={handleFindSimilarVisual}
              />
            ))}
          </div>
        </div>
      </div>

      {/* Batch Action Toolbar */}
      {selectedGenerationIds.length > 0 && (
        <div className="animate-in slide-in-from-bottom-4 fade-in absolute bottom-32 left-1/2 z-50 flex -translate-x-1/2 items-center gap-6 rounded-xl border border-white/10 bg-[#1a1a1a] px-6 py-3 shadow-2xl duration-200">
          <span className="text-sm font-medium text-white">
            {selectedGenerationIds.length} selected
          </span>
          <div className="h-4 w-px bg-white/10" />
          <div className="flex items-center gap-2">
            <select
              onChange={e => {
                if (e.target.value) onBatchMove(e.target.value);
              }}
              className="rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-white focus:ring-1 focus:ring-blue-500 focus:outline-none"
              defaultValue=""
            >
              <option value="" disabled>
                Move to Session...
              </option>
              {sessions.map(s => (
                <option key={s.id} value={s.id}>
                  {s.name}
                </option>
              ))}
            </select>
            <button
              onClick={handleBatchCopyLinks}
              className="flex items-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 px-3 py-1.5 text-sm font-medium text-blue-400"
            >
              <Copy className="h-4 w-4" /> Copy Links
            </button>
            <button
              onClick={onBatchDownload}
              className="flex items-center gap-2 rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm font-medium text-white"
            >
              <Download className="h-4 w-4" /> Download
            </button>
            <button
              onClick={onBatchDelete}
              className="flex items-center gap-2 rounded-lg border border-red-500/20 bg-red-500/10 px-3 py-1.5 text-sm font-medium text-red-500"
            >
              <Trash2 className="h-4 w-4" /> Delete
            </button>
            <div className="mx-1 h-4 w-px bg-white/10" />
            <button
              onClick={deselectAllGenerations}
              className="p-1.5 text-gray-400 hover:text-white"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/generations/EngineLibraryModal.tsx">
import React, { useState, useMemo, useRef } from 'react';
import {
  X,
  Search,
  Image as ImageIcon,
  Video,
  User,
  Crown,
  Sparkles,
  Check,
  Film,
  Upload,
  Mic,
  Music,
  Wand2,
} from 'lucide-react';
import clsx from 'clsx';
import { motion, AnimatePresence } from 'framer-motion';
import { ALL_MODELS, ModelInfo, ModelCapability, PROVIDER_DEFINITIONS } from '@/lib/ModelRegistry';
import { getModelPriceString } from '@/lib/ModelPricing';
import { getModelConstraints } from '@/lib/ModelConstraints';
import { AudioInput } from './AudioInput';

interface EngineLibraryModalProps {
  isOpen: boolean;
  onClose: () => void;
  currentModelId: string;
  onSelect: (model: ModelInfo) => void;
  initialCategory?: ModelCapability | 'all';
  // Generation parameters
  quantity?: number;
  onQuantityChange?: (quantity: number) => void;
  duration?: string;
  onDurationChange?: (d: string) => void;
  // Audio support for avatar models
  audioFile?: File | null;
  onAudioChange?: (file: File | null) => void;
}

const CATEGORIES = [
  { id: 'all' as const, label: 'All Uses', icon: Sparkles },
  { id: 'text-to-image' as ModelCapability, label: 'Image Generation', icon: ImageIcon },
  { id: 'text-to-video' as ModelCapability, label: 'Text to Video', icon: Video },
  { id: 'image-to-video' as ModelCapability, label: 'Animation (I2V)', icon: Film },
  { id: 'avatar' as ModelCapability, label: 'Character & Avatar', icon: User },
];

export function EngineLibraryModal({
  isOpen,
  onClose,
  currentModelId,
  onSelect,
  initialCategory = 'all',
  quantity = 1,
  onQuantityChange,
  duration,
  onDurationChange,
  audioFile,
  onAudioChange,
}: EngineLibraryModalProps) {
  const [favorites, setFavorites] = useState<string[]>(() => {
    // Load favorites from local storage
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('vibeboard_model_favorites');
      return saved ? JSON.parse(saved) : [];
    }
    return [];
  });

  const toggleFavorite = (e: React.MouseEvent, modelId: string) => {
    e.stopPropagation();
    setFavorites(prev => {
      const next = prev.includes(modelId) ? prev.filter(id => id !== modelId) : [...prev, modelId];
      localStorage.setItem('vibeboard_model_favorites', JSON.stringify(next));
      return next;
    });
  };

  const [selectedCategory, setSelectedCategory] = useState<ModelCapability | 'all' | 'favorites'>(
    'all'
  );
  const [selectedProviders, setSelectedProviders] = useState<string[]>([]);
  const [loraOnly, setLoraOnly] = useState(false);

  // Staged model selection - only applied when user clicks "Apply Model"
  const [stagedModelId, setStagedModelId] = useState<string>(currentModelId);

  // Update selected category and staged model when modal opens
  React.useEffect(() => {
    if (isOpen) {
      if (initialCategory) {
        setSelectedCategory(initialCategory);
      }
      // Reset staged selection to current model when modal opens
      setStagedModelId(currentModelId);
    }
  }, [isOpen, initialCategory, currentModelId]);
  const [searchQuery, setSearchQuery] = useState('');

  // Get provider counts for MAKER filter
  const providerCounts = useMemo(() => {
    const counts: Record<string, number> = {};
    ALL_MODELS.forEach(model => {
      counts[model.provider] = (counts[model.provider] || 0) + 1;
    });
    return counts;
  }, []);

  const toggleProvider = (provider: string) => {
    setSelectedProviders(prev =>
      prev.includes(provider) ? prev.filter(p => p !== provider) : [...prev, provider]
    );
  };

  const filteredModels = useMemo(() => {
    return ALL_MODELS.filter(model => {
      let matchesCategory = false;

      // Handle "All" - show all models
      if (selectedCategory === 'all') {
        matchesCategory = true;
      } else if (selectedCategory === 'favorites') {
        matchesCategory = favorites.includes(model.id);
      } else {
        matchesCategory = model.capability === selectedCategory;
      }

      // Filter by selected providers (if any)
      const matchesProvider =
        selectedProviders.length === 0 || selectedProviders.includes(model.provider);

      // Filter by LoRA capability
      const matchesLoRA = !loraOnly || getModelConstraints(model.id).supportsLoRA;

      const matchesSearch =
        model.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        model.provider.toLowerCase().includes(searchQuery.toLowerCase());
      return matchesCategory && matchesProvider && matchesLoRA && matchesSearch;
    });
  }, [selectedCategory, searchQuery, favorites, selectedProviders, loraOnly]);

  // Count models that support LoRA
  const loraModelCount = useMemo(() => {
    return ALL_MODELS.filter(model => getModelConstraints(model.id).supportsLoRA).length;
  }, []);

  // Show all categories always
  const displayedCategories = CATEGORIES;

  // Check if current model is an Avatar model (needs audio)
  const isAvatarModel = useMemo(() => {
    // Not used for logic anymore, but kept if needed
    const model = ALL_MODELS.find(m => m.id === currentModelId);
    return model?.capability === 'avatar';
  }, [currentModelId]);

  const isVideoModel = useMemo(() => {
    const model = ALL_MODELS.find(m => m.id === currentModelId);
    return model?.type === 'video';
  }, [currentModelId]);

  const supportedDurations = useMemo(() => {
    const model = ALL_MODELS.find(m => m.id === currentModelId);
    return model?.supportedDurations || ['5s', '10s'];
  }, [currentModelId]);

  // Group by Capability if 'all' is selected, or just list
  // Actually, simple grid is better for now.

  const handleSelect = (model: ModelInfo) => {
    // Stage the selection - don't apply yet
    setStagedModelId(model.id);
  };

  const handleApply = () => {
    const model = ALL_MODELS.find(m => m.id === stagedModelId);
    if (model) {
      onSelect(model);
    }
    onClose();
  };

  // Get staged model info for footer display
  const stagedModel = useMemo(() => {
    return ALL_MODELS.find(m => m.id === stagedModelId);
  }, [stagedModelId]);

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="absolute inset-0 bg-black/80 backdrop-blur-sm"
          />

          {/* Content */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            className="relative z-10 flex h-[80vh] w-full max-w-5xl flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#0A0A0A] shadow-2xl md:flex-row"
            onClick={e => e.stopPropagation()}
          >
            {/* Sidebar */}
            <div className="flex w-64 flex-col overflow-y-auto border-r border-white/5 bg-black/40 p-4">
              <div className="mb-6 flex items-center gap-2 px-2">
                <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-blue-500/20">
                  <Sparkles className="h-5 w-5 text-blue-400" />
                </div>
                <h2 className="text-lg font-bold text-white">Models</h2>
              </div>

              {/* Audio Source Section - Always visible per design */}
              <div className="mb-4">
                {onAudioChange && (
                  <AudioInput
                    file={audioFile}
                    onAudioChange={onAudioChange}
                    className="border border-white/10 bg-white/5"
                  />
                )}
              </div>

              {/* Quantity & Duration Row - Grid for fixed layout */}
              <div className="mb-4 grid grid-cols-2 gap-2 px-2">
                {/* Quantity */}
                {onQuantityChange && (
                  <div className="w-full">
                    <label className="mb-2 block text-[10px] font-semibold tracking-wider text-gray-500 uppercase">
                      Quantity
                    </label>
                    <select
                      value={quantity}
                      onChange={e => onQuantityChange(parseInt(e.target.value))}
                      className="w-full rounded-lg border border-white/10 bg-white/5 px-2 py-2 text-sm text-white focus:ring-2 focus:ring-blue-500/50 focus:outline-none"
                    >
                      {[1, 2, 3, 4].map(n => (
                        <option key={n} value={n} className="bg-[#1a1a1a]">
                          {n}
                        </option>
                      ))}
                    </select>
                  </div>
                )}

                {/* Duration (Video Only) */}
                {isVideoModel && onDurationChange && (
                  <div className="animate-in fade-in slide-in-from-left-2 w-full">
                    <label className="mb-2 block text-[10px] font-semibold tracking-wider text-gray-500 uppercase">
                      Duration
                    </label>
                    <select
                      value={duration}
                      onChange={e => onDurationChange(e.target.value)}
                      className="w-full appearance-none rounded-lg border border-white/10 bg-white/5 px-2 py-2 text-sm text-white focus:ring-2 focus:ring-blue-500/50 focus:outline-none"
                    >
                      {supportedDurations.map((d: string) => (
                        <option key={d} value={d} className="bg-[#1a1a1a]">
                          {d}
                        </option>
                      ))}
                    </select>
                  </div>
                )}
              </div>

              {/* Favorites */}
              <button
                onClick={() => setSelectedCategory('favorites')}
                className={clsx(
                  'mb-2 flex w-full items-center gap-3 rounded-lg px-3 py-2 text-left text-sm transition-all',
                  selectedCategory === 'favorites'
                    ? 'bg-yellow-500 text-white shadow-lg shadow-yellow-500/20'
                    : 'text-gray-400 hover:bg-white/5 hover:text-white'
                )}
              >
                <Crown
                  className={clsx(
                    'h-4 w-4',
                    selectedCategory === 'favorites' ? 'fill-current text-white' : 'text-gray-500'
                  )}
                />
                <span>My Favorites</span>
                <span className="ml-auto text-xs opacity-60">{favorites.length}</span>
              </button>

              {/* USE CASE Section */}
              <div className="mb-4">
                <p className="mb-2 px-3 text-[10px] font-semibold tracking-wider text-gray-500 uppercase">
                  Use Case
                </p>
                <div className="space-y-1">
                  {displayedCategories.map(cat => (
                    <button
                      key={cat.id}
                      onClick={() => setSelectedCategory(cat.id)}
                      className={clsx(
                        'flex w-full items-center gap-3 rounded-lg px-3 py-2 text-left text-sm transition-all',
                        selectedCategory === cat.id
                          ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'
                          : 'text-gray-400 hover:bg-white/5 hover:text-white'
                      )}
                    >
                      <cat.icon
                        className={clsx(
                          'h-4 w-4',
                          selectedCategory === cat.id ? 'text-white' : 'text-gray-500'
                        )}
                      />
                      <span>{cat.label}</span>
                    </button>
                  ))}
                </div>
              </div>

              {/* LoRA Capability Filter */}
              <button
                onClick={() => setLoraOnly(!loraOnly)}
                className={clsx(
                  'mb-2 flex w-full items-center gap-3 rounded-lg px-3 py-2 text-left text-sm transition-all',
                  loraOnly
                    ? 'bg-purple-500 text-white shadow-lg shadow-purple-500/20'
                    : 'text-gray-400 hover:bg-white/5 hover:text-white'
                )}
              >
                <Wand2 className={clsx('h-4 w-4', loraOnly ? 'text-white' : 'text-gray-500')} />
                <span>LoRA Support</span>
                <span className="ml-auto text-xs opacity-60">{loraModelCount}</span>
                {loraOnly && <Check className="h-3 w-3 text-white" />}
              </button>

              <div className="my-3 border-t border-white/10" />

              {/* MAKER Section */}
              <div className="mb-4">
                <p className="mb-2 px-3 text-[10px] font-semibold tracking-wider text-gray-500 uppercase">
                  Maker
                </p>
                <div className="space-y-1">
                  {Object.entries(providerCounts)
                    .sort((a, b) => b[1] - a[1])
                    .map(([provider, count]) => {
                      const providerDef = PROVIDER_DEFINITIONS[provider];
                      const isSelected = selectedProviders.includes(provider);
                      return (
                        <button
                          key={provider}
                          onClick={() => toggleProvider(provider)}
                          className={clsx(
                            'flex w-full items-center gap-2 rounded-lg px-3 py-1.5 text-left text-sm transition-all',
                            isSelected
                              ? 'bg-white/10 text-white'
                              : 'text-gray-400 hover:bg-white/5 hover:text-white'
                          )}
                        >
                          {providerDef?.icon && (
                            <providerDef.icon className={clsx('h-3.5 w-3.5', providerDef.color)} />
                          )}
                          <span className="flex-1 truncate">{providerDef?.name || provider}</span>
                          <span className="text-xs opacity-60">{count}</span>
                          {isSelected && <Check className="h-3 w-3 text-blue-400" />}
                        </button>
                      );
                    })}
                </div>
              </div>

              <div className="mt-auto border-t border-white/5 pt-4">
                <div className="rounded-lg border border-blue-500/20 bg-blue-500/10 px-3 py-2">
                  <p className="mb-1 text-xs font-medium text-blue-300">Showing</p>
                  <p className="text-xl font-bold text-blue-100">
                    {filteredModels.length}{' '}
                    <span className="text-sm font-normal text-blue-300">
                      of {ALL_MODELS.length}
                    </span>
                  </p>
                </div>
              </div>
            </div>

            {/* Main Content */}
            <div className="flex flex-1 flex-col bg-gradient-to-br from-[#0A0A0A] to-[#111111]">
              {/* Header */}
              <div className="flex h-16 items-center justify-between gap-4 border-b border-white/5 px-6">
                <div className="relative max-w-md flex-1">
                  <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-400" />
                  <input
                    type="text"
                    placeholder="Search models..."
                    value={searchQuery}
                    onChange={e => setSearchQuery(e.target.value)}
                    className="w-full rounded-full border border-white/10 bg-white/5 py-2 pr-4 pl-10 text-sm text-white placeholder-gray-500 transition-all focus:ring-2 focus:ring-blue-500/50 focus:outline-none"
                  />
                </div>
                <button
                  onClick={onClose}
                  className="rounded-full p-2 text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                >
                  <X className="h-5 w-5" />
                </button>
              </div>

              {/* Grid */}
              <div className="flex-1 overflow-y-auto p-6 pb-24">
                <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
                  {filteredModels.map(model => {
                    const providerDef = PROVIDER_DEFINITIONS[model.provider];
                    const isSelected = stagedModelId === model.id;

                    return (
                      <div
                        key={model.id}
                        onClick={() => handleSelect(model)}
                        className={clsx(
                          'group relative flex cursor-pointer flex-col overflow-hidden rounded-xl border p-4 transition-all',
                          isSelected
                            ? 'border-blue-500 bg-blue-500/10 shadow-lg shadow-blue-500/10'
                            : 'border-white/5 bg-white/5 hover:border-white/20 hover:bg-white/10 hover:shadow-xl'
                        )}
                      >
                        <button
                          onClick={e => toggleFavorite(e, model.id)}
                          className={clsx(
                            'absolute top-2 right-2 z-20 rounded-full p-1.5 opacity-0 transition-all group-hover:opacity-100',
                            favorites.includes(model.id)
                              ? 'bg-black/20 text-yellow-400 opacity-100'
                              : 'text-gray-500 hover:bg-white/10 hover:text-yellow-400'
                          )}
                        >
                          <Crown
                            className={clsx(
                              'h-4 w-4',
                              favorites.includes(model.id) && 'fill-current'
                            )}
                          />
                        </button>

                        {/* Provider Pill */}
                        <div className="mb-3 flex items-center justify-between">
                          <div
                            className={clsx(
                              'flex items-center gap-1.5 rounded border border-white/5 px-2 py-1 text-xs font-medium',
                              providerDef?.bgColor || 'bg-gray-800'
                            )}
                          >
                            {providerDef?.icon && (
                              <providerDef.icon className={clsx('h-3 w-3', providerDef.color)} />
                            )}
                            <span className={clsx(providerDef?.color || 'text-gray-300')}>
                              {providerDef?.name || model.provider}
                            </span>
                          </div>
                          {isSelected && (
                            <div className="flex h-5 w-5 items-center justify-center rounded-full bg-blue-500">
                              <Check className="h-3 w-3 text-white" />
                            </div>
                          )}
                        </div>

                        <h3 className="mb-1 text-base font-bold text-white transition-colors group-hover:text-blue-400">
                          {model.name}
                        </h3>
                        {model.bestFor && (
                          <span className="mb-2 inline-block rounded bg-cyan-500/20 px-1.5 py-0.5 text-[10px] font-medium text-cyan-300">
                            Best for: {model.bestFor}
                          </span>
                        )}
                        <p className="mb-4 text-xs text-gray-400">
                          {model.desc || 'No description available.'}
                        </p>

                        <div className="mt-auto flex items-center justify-between border-t border-white/5 pt-3">
                          <div className="flex flex-wrap items-center gap-2">
                            <span
                              className={clsx(
                                'rounded px-1.5 py-0.5 text-[10px] font-semibold tracking-wider uppercase',
                                model.type === 'video'
                                  ? 'bg-purple-500/20 text-purple-300'
                                  : 'bg-emerald-500/20 text-emerald-300'
                              )}
                            >
                              {model.type === 'video' ? 'Video' : 'Image'}
                            </span>
                            {model.capability === 'avatar' && (
                              <span className="rounded bg-pink-500/20 px-1.5 py-0.5 text-[10px] font-semibold tracking-wider text-pink-300 uppercase">
                                Avatar
                              </span>
                            )}
                            {getModelConstraints(model.id).supportsLoRA && (
                              <span className="flex items-center gap-1 rounded bg-amber-500/20 px-1.5 py-0.5 text-[10px] font-semibold tracking-wider text-amber-300 uppercase">
                                <Wand2 className="h-2.5 w-2.5" />
                                LoRA
                              </span>
                            )}
                          </div>
                          <span className="text-xs font-medium text-emerald-400">
                            {getModelPriceString(model.id)}
                          </span>
                        </div>

                        {/* Hover Effect Gradient */}
                        <div className="pointer-events-none absolute inset-0 bg-gradient-to-br from-blue-500/0 via-blue-500/0 to-blue-500/5 opacity-0 transition-opacity group-hover:opacity-100" />
                      </div>
                    );
                  })}
                </div>
                {filteredModels.length === 0 && (
                  <div className="flex h-64 flex-col items-center justify-center text-gray-500">
                    <Search className="mb-2 h-8 w-8 opacity-20" />
                    <p>No models found matching "{searchQuery}"</p>
                  </div>
                )}
              </div>

              {/* Footer */}
              <div className="absolute right-0 bottom-0 left-64 flex items-center justify-between border-t border-white/10 bg-black/90 px-6 py-4 backdrop-blur-sm">
                <div className="flex items-center gap-3 text-sm text-gray-400">
                  {stagedModel ? (
                    <>
                      <span className="font-medium text-white">{stagedModel.name}</span>
                      <span className="text-gray-600"></span>
                      <span className="text-emerald-400">{getModelPriceString(stagedModel.id)}</span>
                    </>
                  ) : (
                    <span>No model selected</span>
                  )}
                </div>
                <div className="flex items-center gap-3">
                  <button
                    onClick={onClose}
                    className="px-4 py-2 text-sm font-medium text-gray-400 transition-colors hover:text-white"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleApply}
                    disabled={!stagedModel}
                    className="flex items-center gap-2 rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-blue-500 disabled:cursor-not-allowed disabled:opacity-50"
                  >
                    <Check className="h-4 w-4" />
                    Apply Model
                  </button>
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="frontend/src/components/layout/Sidebar.tsx">
'use client';

import Link from 'next/link';
import { usePathname, useParams } from 'next/navigation';
import { LayoutGrid, Wand2, Clapperboard, Settings, FileText, Paintbrush, Film, MessageSquare, Aperture } from 'lucide-react';
import { motion } from 'framer-motion';
import { clsx } from 'clsx';

import { useSession } from '@/context/SessionContext';
import { Plus, Folder, ChevronDown, ChevronRight, Trash2, ChevronLeft } from 'lucide-react';
import { useState } from 'react';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';
import { SpendingWidget } from '@/components/sidebar/SpendingWidget';
import { useSidebarStore } from '@/lib/sidebarStore';
import { useEngineConfigStore } from '@/lib/engineConfigStore';

export function Sidebar() {
  const pathname = usePathname();
  const params = useParams();
  const projectId = params.id as string;
  const { sessions, selectedSessionId, selectSession, createSession, deleteSession } = useSession();
  const [isSessionsExpanded, setIsSessionsExpanded] = useState(true);
  const [isCreatingSession, setIsCreatingSession] = useState(false);
  const [newSessionName, setNewSessionName] = useState('');
  const { isCollapsed, toggleSidebar } = useSidebarStore();
  const { currentModelId, currentDuration, isVideo } = useEngineConfigStore();

  if (!projectId) return null;

  const handleCreateSession = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newSessionName.trim()) return;
    await createSession(newSessionName);
    setNewSessionName('');
    setIsCreatingSession(false);
  };

  const navItems = [
    { name: 'Elements', href: `/projects/${projectId}/elements`, icon: LayoutGrid },
    { name: 'Generate', href: `/projects/${projectId}/generate`, icon: Wand2 },
    { name: 'Roto & Paint', href: `/projects/${projectId}/process`, icon: Paintbrush },
    { name: 'Story Editor', href: `/projects/${projectId}/story-editor`, icon: FileText },
    { name: 'Storyboard', href: `/projects/${projectId}/storyboard`, icon: Clapperboard },
    { name: 'Timeline', href: `/projects/${projectId}/timeline`, icon: Film },
    { name: 'Dailies', href: `/projects/${projectId}/dailies`, icon: MessageSquare },
    { name: 'Viewfinder', href: `/projects/${projectId}/viewfinder`, icon: Aperture },
    { name: 'Training', href: `/projects/${projectId}/train`, icon: Wand2 },
  ];

  return (
    <aside
      className={clsx(
        'fixed top-0 left-0 z-50 flex h-screen flex-col border-r border-white/10 bg-black/90 text-white backdrop-blur-xl transition-all duration-300 ease-in-out',
        isCollapsed ? 'w-20' : 'w-64'
      )}
    >
      <div
        className={clsx(
          'flex items-center p-6',
          isCollapsed ? 'justify-center' : 'justify-between'
        )}
      >
        {!isCollapsed && (
          <Link href="/" className="block overflow-hidden whitespace-nowrap">
            <h1 className="bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-2xl font-bold tracking-tighter text-transparent">
              VibeBoard
            </h1>
          </Link>
        )}
        <button
          onClick={toggleSidebar}
          className="text-gray-500 transition-colors hover:text-white"
        >
          {isCollapsed ? <ChevronRight className="h-5 w-5" /> : <ChevronLeft className="h-5 w-5" />}
        </button>
      </div>

      {!isCollapsed && (
        <div className="mb-6 overflow-hidden px-4">
          <div className="mb-2 flex items-center justify-between px-2">
            <button
              onClick={() => setIsSessionsExpanded(!isSessionsExpanded)}
              className="flex items-center gap-1 text-xs font-bold tracking-wider text-gray-500 uppercase transition-colors hover:text-white"
            >
              {isSessionsExpanded ? (
                <ChevronDown className="h-3 w-3" />
              ) : (
                <ChevronRight className="h-3 w-3" />
              )}
              Sessions
            </button>
            <button
              onClick={() => setIsCreatingSession(true)}
              className="text-gray-500 transition-colors hover:text-white"
            >
              <Plus className="h-3 w-3" />
            </button>
          </div>

          {isSessionsExpanded && (
            <div className="space-y-1">
              <button
                onClick={() => selectSession(null)}
                className={clsx(
                  'flex w-full items-center gap-2 rounded-lg px-3 py-2 text-left text-sm font-medium transition-colors',
                  selectedSessionId === null
                    ? 'bg-blue-600/20 text-blue-400'
                    : 'text-gray-400 hover:bg-white/5 hover:text-white'
                )}
              >
                <Folder className="h-4 w-4 flex-shrink-0" />
                <span className="truncate">All Sessions</span>
              </button>

              {isCreatingSession && (
                <form onSubmit={handleCreateSession} className="px-1 py-1">
                  <input
                    autoFocus
                    type="text"
                    value={newSessionName}
                    onChange={e => setNewSessionName(e.target.value)}
                    placeholder="Name..."
                    className="w-full rounded border border-blue-500/50 bg-black/30 px-2 py-1 text-xs text-white focus:outline-none"
                    onBlur={() => !newSessionName && setIsCreatingSession(false)}
                  />
                </form>
              )}

              {sessions.map(session => (
                <div
                  key={session.id}
                  onClick={() => selectSession(session.id)}
                  className={clsx(
                    'group flex w-full cursor-pointer items-center justify-between rounded-lg px-3 py-2 text-left text-sm font-medium transition-colors',
                    selectedSessionId === session.id
                      ? 'bg-blue-600/20 text-blue-400'
                      : 'text-gray-400 hover:bg-white/5 hover:text-white'
                  )}
                >
                  <div className="flex items-center gap-2 overflow-hidden">
                    <span className="truncate">{session.name}</span>
                    {session._count?.generations ? (
                      <span className="flex-shrink-0 text-xs opacity-50">
                        {session._count.generations}
                      </span>
                    ) : null}
                  </div>
                  <Tooltip content="Delete Session" side="right">
                    <button
                      onClick={e => {
                        e.stopPropagation();
                        if (
                          confirm(
                            'Are you sure you want to delete this session? This will delete all generations, elements, and scenes within it.'
                          )
                        ) {
                          deleteSession(session.id);
                        }
                      }}
                      className="rounded p-1 opacity-0 transition-all group-hover:opacity-100 hover:bg-red-500/20 hover:text-red-400"
                    >
                      <Trash2 className="h-3 w-3" />
                    </button>
                  </Tooltip>
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      <nav className="flex-1 space-y-2 px-4">
        {navItems.map(item => {
          const isActive = pathname.startsWith(item.href);
          return (
            <Link
              key={item.href}
              href={item.href}
              title={isCollapsed ? item.name : undefined}
              className={clsx(
                'group relative flex items-center gap-3 rounded-xl py-3 transition-colors',
                isCollapsed ? 'justify-center px-2' : 'px-4',
                isActive ? 'text-white' : 'text-gray-400 hover:text-white'
              )}
            >
              {isActive && (
                <motion.div
                  layoutId="activeNav"
                  className="absolute inset-0 rounded-xl bg-white/10"
                  initial={false}
                  transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                />
              )}
              <item.icon className="relative z-10 h-5 w-5 flex-shrink-0" />
              {!isCollapsed && (
                <span className="relative z-10 overflow-hidden font-medium whitespace-nowrap">
                  {item.name}
                </span>
              )}
            </Link>
          );
        })}
      </nav>

      {/* Spending Widget */}
      <div className={clsx('px-4 pb-2', isCollapsed && 'px-2')}>
        <SpendingWidget
          collapsed={isCollapsed}
          currentModelId={currentModelId ?? undefined}
          currentDuration={currentDuration ?? undefined}
          isVideo={isVideo}
        />
      </div>

      <div className="border-t border-white/10 p-4">
        <button
          className={clsx(
            'flex w-full items-center gap-3 rounded-xl text-gray-400 transition-colors hover:bg-white/5 hover:text-white',
            isCollapsed ? 'justify-center px-2 py-3' : 'px-4 py-3'
          )}
          title={isCollapsed ? 'Settings' : undefined}
        >
          <Settings className="h-5 w-5 flex-shrink-0" />
          {!isCollapsed && <span className="font-medium">Settings</span>}
        </button>
      </div>
    </aside>
  );
}
</file>

<file path="frontend/src/components/storyboard/StyleSelectorModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
'use client';

import { useState, useRef, useEffect } from 'react';
import {
  X,
  Upload,
  Check,
  ChevronRight,
  Search,
  Ratio,
  Plus,
  ChevronDown,
  Settings2,
  Sliders,
  Dice5,
  FileJson,
  FolderOpen,
  Library,
  Database,
  Lightbulb,
  Lock,
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import { useDropzone } from 'react-dropzone';
import { ParameterManager } from '../generations/ParameterManager';
import { CreateStyleModal, CustomStyle } from './CreateStyleModal';
import { LoRAManager } from '../loras/LoRAManager';

import { CinematicTagsModal } from './CinematicTagsModal';
import { DataBackupModal } from '../settings/DataBackupModal';
import { NegativePromptManager } from '../prompts/NegativePromptManager';
import { ALL_CATEGORIES, CinematicTag, CATEGORY_MAP } from '@/data/CinematicTags';

export interface StyleConfig {
  preset: any;
  referenceImage: string | File | null;
  inspiration: string;
  aspectRatio: string;
  camera?: {
    type?: string;
    angle?: string;
  };
  lighting?: {
    type?: string;
  };
  location?: {
    type?: string;
  };
  strength?: number;
  loras?: {
    id: string;
    name: string;
    strength: number;
    triggerWord?: string;
    triggerWords?: string[];
    baseModel?: string;
  }[];
  sampler?: { id: string; name: string; value: string };
  scheduler?: { id: string; name: string; value: string };
  guidanceScale?: number;
  steps?: number;
  seed?: number;
  negativePrompt?: string;
  workflow?: { name: string; file: File | null };
  motionVideo?: string | File | null;
  // Lighting Lock feature
  lightingLock?: {
    enabled: boolean;
    imageUrl?: string;
    imageFile?: File;
    strength: number; // 0.1-0.5, default 0.25
  };
}

interface StyleSelectorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onApply: (config: StyleConfig) => void;
  initialAspectRatio?: string;
  projectId: string;
}

const STYLE_PRESETS = [
  {
    id: 'film_noir',
    name: 'Film Noir',
    image: '/presets/film_noir.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
    promptSuffix:
      ', high contrast black and white, dramatic shadows, dutch angle, 1940s film grain, mystery, crime thriller atmosphere',
  },
  {
    id: 'cinematic',
    name: 'Cinematic',
    image: '/presets/cinematic.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
    promptSuffix:
      ', cinematic lighting, shallow depth of field, anamorphic lens, color graded, 8k resolution, highly detailed',
  },
  {
    id: 'vintage',
    name: 'Vintage',
    image: '/presets/vintage.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
    promptSuffix:
      ', vintage 1970s aesthetic, film grain, faded colors, retro fashion, polaroid style, nostalgic',
  },
  {
    id: 'anime',
    name: 'Anime',
    image: '/presets/anime.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
    promptSuffix:
      ', anime style, cel shaded, vibrant colors, expressive characters, studio ghibli inspired, detailed background',
  },
  {
    id: '3d_cartoon',
    name: '3D Cartoon',
    image: '/presets/3d_cartoon.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
    promptSuffix:
      ', 3d render, pixar style, cute, soft lighting, ambient occlusion, clay material, character design',
  },
  {
    id: 'colored',
    name: 'Colored',
    image: '/presets/colored.png',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
    promptSuffix:
      ', vibrant color palette, saturated, neon lights, colorful, rainbow, psychedelic, vivid',
  },
  {
    id: 'dreamy',
    name: 'Dreamy',
    image: '/presets/dreamy.png',
    video:
      'https://storage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
    promptSuffix:
      ', dreamy atmosphere, soft focus, pastel colors, ethereal, fantasy, magical, glowing',
  },
  {
    id: 'hand_drawn',
    name: 'Hand Drawn',
    image: 'https://picsum.photos/seed/hand/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4',
    promptSuffix:
      ', hand drawn, pencil sketch, charcoal, rough lines, artistic, illustration, sketchbook style',
  },
  {
    id: '2d_novel',
    name: '2D Novel',
    image: 'https://picsum.photos/seed/novel/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
    promptSuffix:
      ', visual novel style, 2d character art, clean lines, flat colors, anime portrait, dialogue scene',
  },
  {
    id: 'scribble',
    name: 'Scribble',
    image: 'https://picsum.photos/seed/scribble/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
    promptSuffix:
      ', scribble art, messy lines, doodle style, marker pen, childish, abstract, chaotic',
  },
  {
    id: 'storyboard',
    name: 'Storyboard',
    image: 'https://picsum.photos/seed/storyboard/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
    promptSuffix:
      ', storyboard sketch, black and white, rough composition, arrows, camera movement indicators, pre-visualization',
  },
  {
    id: 'low_key',
    name: 'Low Key',
    image: 'https://picsum.photos/seed/lowkey/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
    promptSuffix:
      ', low key lighting, dark background, rim light, silhouette, moody, mystery, noir',
  },
  {
    id: 'indie',
    name: 'Indie',
    image: 'https://picsum.photos/seed/indie/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
    promptSuffix:
      ', indie movie aesthetic, a24 style, natural lighting, raw, emotional, handheld camera, mumblecore',
  },
  {
    id: 'y2k',
    name: 'Y2K',
    image: 'https://picsum.photos/seed/y2k/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
    promptSuffix:
      ', y2k aesthetic, year 2000, futuristic, chrome, glossy, matrix style, cyber, techno',
  },
  {
    id: 'pop',
    name: 'Pop Art',
    image: 'https://picsum.photos/seed/pop/200',
    video:
      'https://storage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
    promptSuffix:
      ', pop art, comic book style, halftones, bold outlines, roy lichtenstein, vibrant, retro',
  },
  {
    id: 'grunge',
    name: 'Grunge',
    image: 'https://picsum.photos/seed/grunge/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4',
    promptSuffix: ', grunge aesthetic, dirty, distressed, texture, 90s rock, dark, edgy, urban',
  },
  {
    id: 'boost',
    name: 'Boost',
    image: 'https://picsum.photos/seed/boost/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
    promptSuffix:
      ', high quality, 4k, detailed, sharp focus, masterpiece, trending on artstation, award winning',
  },
  {
    id: 'cyberpunk',
    name: 'Cyberpunk',
    image: 'https://picsum.photos/seed/cyberpunk/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
    promptSuffix:
      ', cyberpunk, neon lights, futuristic city, rain, holographic, blade runner inspired, dystopian',
  },
  {
    id: 'vaporwave',
    name: 'Vaporwave',
    image: 'https://picsum.photos/seed/vaporwave/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
    promptSuffix:
      ', vaporwave aesthetic, pink and blue, 80s retro, glitch art, greek statues, palm trees, sunset grid',
  },
  {
    id: 'documentary',
    name: 'Documentary',
    image: 'https://picsum.photos/seed/documentary/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
    promptSuffix:
      ', documentary style, realistic, natural lighting, handheld footage, intimate, observational',
  },
  {
    id: 'horror',
    name: 'Horror',
    image: 'https://picsum.photos/seed/horror/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
    promptSuffix:
      ', horror atmosphere, dark shadows, unsettling, tension, desaturated, grainy, creepy',
  },
  {
    id: 'western',
    name: 'Western',
    image: 'https://picsum.photos/seed/western/200',
    video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
    promptSuffix:
      ', western movie, desert landscape, dusty, sepia tones, wide shots, cowboy aesthetic',
  },
  {
    id: 'noir_color',
    name: 'Neo-Noir',
    image: 'https://picsum.photos/seed/neonoir/200',
    video:
      'https://storage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
    promptSuffix:
      ', neo-noir, color noir, neon lights in darkness, rain-slicked streets, mysterious, stylized shadows',
  },
];

function PresetCard({
  preset,
  isSelected,
  onClick,
}: {
  preset: any;
  isSelected: boolean;
  onClick: () => void;
}) {
  const [isHovered, setIsHovered] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (isHovered && videoRef.current) {
      videoRef.current.currentTime = 0;
      videoRef.current.play().catch(() => {});
    } else if (!isHovered && videoRef.current) {
      videoRef.current.pause();
      videoRef.current.currentTime = 0;
    }
  }, [isHovered]);

  return (
    <button
      onClick={onClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      className="group relative aspect-square overflow-hidden rounded-lg border border-white/10 transition-all hover:border-white/30"
    >
      <div className="h-full w-full bg-white/5 transition-colors group-hover:bg-white/10">
        {isHovered ? (
          <video
            ref={videoRef}
            src={preset.video}
            className="h-full w-full object-cover"
            muted
            loop
            playsInline
          />
        ) : (
          <img src={preset.image} alt={preset.name} className="h-full w-full object-cover" />
        )}
      </div>

      <div
        className={clsx(
          'absolute inset-0 ring-2 transition-all ring-inset',
          isSelected ? 'bg-blue-500/10 ring-blue-500' : 'ring-transparent'
        )}
      />

      {isSelected && (
        <div className="absolute top-1 right-1 flex h-5 w-5 items-center justify-center rounded-full bg-blue-500">
          <Check className="h-3 w-3 text-white" />
        </div>
      )}

      <span className="absolute right-0 bottom-1 left-0 bg-black/60 py-0.5 text-center text-[10px] font-medium text-gray-300 backdrop-blur-sm">
        {preset.name}
      </span>
    </button>
  );
}

interface StyleSelectorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onApply: (config: StyleConfig) => void;
  initialAspectRatio?: string;
  projectId: string;
  config?: StyleConfig; // Added config prop for external control
  currentModelId?: string; // Current generation model ID for LoRA auto-filtering
  isAnamorphicLocked?: boolean; // When true, locks aspect ratio to 21:9
}

export function StyleSelectorModal({
  isOpen,
  onClose,
  onApply,
  initialAspectRatio,
  projectId,
  config: configProp,
  currentModelId,
  isAnamorphicLocked,
}: StyleSelectorModalProps) {
  // Basic Style State
  const [selectedCategory, setSelectedCategory] = useState('All');
  const [selectedStyle, setSelectedStyle] = useState<any>(null);
  const [selectedPreset, setSelectedPreset] = useState<any>(null); // Restored
  const [searchQuery, setSearchQuery] = useState(''); // Restored
  const [referenceImage, setReferenceImage] = useState<string | File | null>(null);

  // Internal Configuration State
  const [config, setConfig] = useState<StyleConfig>({
    preset: null,
    referenceImage: null,
    inspiration: '',
    aspectRatio: initialAspectRatio || '16:9',
    strength: 80,
    guidanceScale: 7.5,
    steps: 30,
    seed: undefined,
    loras: [],
    motionVideo: null,
    negativePrompt: '',
  });

  // Advanced Parameters State (helpers if needed, but we rely on config)
  const [selectedLoRAs, setSelectedLoRAs] = useState<
    { id: string; name: string; strength: number }[]
  >([]);

  // Sync state with incoming config prop
  useEffect(() => {
    if (isOpen && configProp) {
      setConfig(prev => ({
        ...prev,
        ...configProp,
        // Ensure defaults if missing in prop
        strength: configProp.strength !== undefined ? configProp.strength : prev.strength,
        steps: configProp.steps || prev.steps,
        guidanceScale: configProp.guidanceScale || prev.guidanceScale,
        loras: configProp.loras || prev.loras,
        negativePrompt:
          configProp.negativePrompt !== undefined ? configProp.negativePrompt : prev.negativePrompt,
        aspectRatio: configProp.aspectRatio || prev.aspectRatio,
      }));

      // Sync helper states if they exist and are used separately (selectedLoRAs seems used in my previous edit, but maybe in original too?)
      // Original code didn't show selectedLoRAs usage. But I might need to check if it's used.
      // Based on my Previous Edit, I added `selectedLoRAs`.
      // If the rest of the file uses `config.loras`, I should ensure that's what is used.
      // If I see `selectedLoRAs` being used in the file, I should keep it.
      // But I broke the file because `config` was missing.
      // I'll assume `config` is the source of truth.
    }
  }, [isOpen, configProp]);

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [customPresets, setCustomPresets] = useState<any[]>([]);
  const [activePopover, setActivePopover] = useState<string | null>(null);
  const [expandedSections, setExpandedSections] = useState<string[]>(['loras']);
  const [activeManager, setActiveManager] = useState<
    'lora' | 'sampler' | 'scheduler' | 'tags' | 'negative' | null
  >(null);
  const [initialTagCategory, setInitialTagCategory] = useState<string | undefined>(undefined);
  const [isBackupModalOpen, setIsBackupModalOpen] = useState(false);

  const toggleSection = (section: string) => {
    setExpandedSections(prev =>
      prev.includes(section) ? prev.filter(s => s !== section) : [...prev, section]
    );
  };

  const handleAddTag = (tag: CinematicTag, categoryId: string) => {
    const prefix = config.inspiration ? `${config.inspiration}, ` : '';
    // Use the tag's prompt directly - it already includes the proper formatting
    setConfig({ ...config, inspiration: prefix + tag.prompt });
    // Keep the panel open so users can add multiple tags
  };

  const openTagsPanel = (categoryId?: string) => {
    setInitialTagCategory(categoryId);
    setActiveManager(activeManager === 'tags' ? null : 'tags');
  };

  const handleApply = () => {
    onApply(config);
    onClose();
  };

  const handleCreateStyle = (style: CustomStyle) => {
    const suffix = style.tags.length > 0 ? `, ${style.tags.join(', ')}` : '';
    const newPreset = {
      id: style.id,
      name: style.name,
      image: style.image,
      video: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
      inspiration: style.tags.join(', '),
      promptSuffix: suffix,
    };
    setCustomPresets([...customPresets, newPreset]);
    setConfig(prev => ({
      ...prev,
      preset: newPreset.id,
      inspiration: newPreset.inspiration,
    }));
  };

  const handleToggleLoRA = (lora: any) => {
    const currentLoras = config.loras || [];
    const exists = currentLoras.find(l => l.id === lora.id);

    if (exists) {
      setConfig({
        ...config,
        loras: currentLoras.filter(l => l.id !== lora.id),
      });
    } else {
      setConfig({
        ...config,
        loras: [
          ...currentLoras,
          {
            id: lora.id,
            name: lora.name,
            strength: lora.strength || 1.0,
            triggerWord: lora.triggerWord,
            triggerWords: lora.triggerWords || (lora.triggerWord ? [lora.triggerWord] : []),
            baseModel: lora.baseModel || 'Unknown',
          },
        ],
      });
    }
  };

  const handleLoRAStrengthChange = (loraId: string, strength: number) => {
    setConfig(prev => ({
      ...prev,
      loras: prev.loras?.map(l => (l.id === loraId ? { ...l, strength } : l)),
    }));
  };

  const handleSelectSampler = (sampler: any) => {
    setConfig(prev => ({ ...prev, sampler: sampler || undefined }));
  };

  const handleSelectScheduler = (scheduler: any) => {
    setConfig(prev => ({ ...prev, scheduler: scheduler || undefined }));
  };

  const generateRandomSeed = () => {
    setConfig(prev => ({ ...prev, seed: Math.floor(Math.random() * 2147483647) }));
  };

  const allPresets = [...STYLE_PRESETS, ...customPresets];
  const filteredPresets = searchQuery
    ? allPresets.filter(p => p.name.toLowerCase().includes(searchQuery.toLowerCase()))
    : allPresets;

  const onDrop = (acceptedFiles: File[]) => {
    if (acceptedFiles.length > 0) {
      setConfig({ ...config, referenceImage: acceptedFiles[0] });
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { 'image/*': [], 'video/*': [] },
    maxFiles: 1,
  });

  const previewUrl = config.referenceImage
    ? typeof config.referenceImage === 'string'
      ? config.referenceImage
      : URL.createObjectURL(config.referenceImage)
    : null;

  useEffect(() => {
    return () => {
      if (previewUrl && typeof config.referenceImage !== 'string') {
        URL.revokeObjectURL(previewUrl);
      }
    };
  }, [config.referenceImage]);

  return (
    <>
      <AnimatePresence>
        {isOpen && (
          <div
            className="scrollbar-none fixed inset-0 z-[100] flex items-center justify-center bg-black/50 p-4 backdrop-blur-sm"
            onClick={onClose}
          >
            <div
              className="scrollbar-none flex items-stretch gap-4 overflow-hidden"
              style={{ height: 'min(800px, calc(100vh - 2rem))', maxWidth: 'calc(100vw - 2rem)' }}
              onClick={e => e.stopPropagation()}
            >
              <motion.div
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                className="scrollbar-none relative flex h-full flex-shrink-0 flex-col overflow-hidden rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl"
                style={{ width: '780px', maxWidth: '900px' }}
              >
                {/* Header */}
                <div className="flex items-center justify-between border-b border-white/10 p-4">
                  <h2 className="text-lg font-bold text-white">Style & Parameters</h2>
                  <button
                    onClick={onClose}
                    className="rounded-full p-1 text-gray-400 hover:bg-white/10 hover:text-white"
                  >
                    <X className="h-5 w-5" />
                  </button>
                </div>

                {/* 3-Column Content */}
                <div className="scrollbar-none flex min-h-0 flex-1 overflow-y-auto">
                  {/* LEFT COLUMN - Style Presets */}
                  <div className="scrollbar-none flex w-[280px] flex-col border-r border-white/10">
                    <div className="border-b border-white/5 p-3">
                      <div className="relative">
                        <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 text-gray-500" />
                        <input
                          type="text"
                          placeholder="Search styles..."
                          value={searchQuery}
                          onChange={e => setSearchQuery(e.target.value)}
                          className="w-full rounded-lg border border-white/10 bg-black/30 py-2 pr-3 pl-9 text-sm text-white placeholder-gray-500 focus:border-white/30 focus:outline-none"
                        />
                      </div>
                    </div>

                    <div className="scrollbar-none flex-1 overflow-y-auto p-3">
                      <div className="grid grid-cols-3 gap-2">
                        {filteredPresets.map(preset => (
                          <PresetCard
                            key={preset.id}
                            preset={preset}
                            isSelected={config.preset === preset.id}
                            onClick={() => {
                              setConfig({
                                ...config,
                                preset: preset.id,
                                inspiration: preset.inspiration || config.inspiration,
                              });
                            }}
                          />
                        ))}
                      </div>
                    </div>

                    <div className="border-t border-white/5 p-3">
                      <button
                        onClick={() => setIsCreateModalOpen(true)}
                        className="flex w-full items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 py-2 text-xs text-gray-400 transition-colors hover:border-blue-500/50 hover:bg-blue-500/10 hover:text-blue-400"
                      >
                        <Plus className="h-4 w-4" />
                        Create New Style
                      </button>
                      <button
                        onClick={() => setIsBackupModalOpen(true)}
                        className="mt-2 flex w-full items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 py-2 text-xs text-gray-400 transition-colors hover:border-green-500/50 hover:bg-green-500/10 hover:text-green-400"
                      >
                        <Database className="h-4 w-4" />
                        Data Management
                      </button>
                    </div>
                  </div>

                  {/* MIDDLE COLUMN - Reference & Advanced Settings */}
                  <div className="scrollbar-none flex w-[270px] flex-col overflow-y-auto border-r border-white/10">
                    <div className="space-y-4 p-4">
                      {/* Reference Image */}
                      <div>
                        <span className="mb-2 block text-xs font-bold tracking-wider text-gray-400 uppercase">
                          Reference Image (Structure/Character)
                        </span>
                        <div
                          {...getRootProps()}
                          className={clsx(
                            'relative flex aspect-video w-full cursor-pointer flex-col items-center justify-center overflow-hidden rounded-xl border-2 border-dashed transition-colors',
                            isDragActive
                              ? 'border-blue-500 bg-blue-500/10'
                              : 'border-white/20 bg-white/5 hover:bg-white/10'
                          )}
                        >
                          <input {...getInputProps()} />
                          {previewUrl ? (
                            <>
                              {(
                                config.referenceImage instanceof File
                                  ? config.referenceImage.type.startsWith('video')
                                  : false
                              ) ? (
                                <video
                                  src={previewUrl}
                                  className="absolute inset-0 h-full w-full object-cover"
                                  autoPlay
                                  muted
                                  loop
                                />
                              ) : (
                                <img
                                  src={previewUrl}
                                  className="absolute inset-0 h-full w-full object-cover"
                                  alt="Reference"
                                />
                              )}
                              <div className="absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 transition-opacity hover:opacity-100">
                                <Upload className="h-6 w-6 text-white" />
                              </div>
                              <button
                                onClick={e => {
                                  e.stopPropagation();
                                  setConfig({ ...config, referenceImage: null });
                                }}
                                className="absolute top-2 right-2 rounded bg-black/60 p-1 text-white transition-colors hover:bg-red-500"
                              >
                                <X className="h-3 w-3" />
                              </button>
                            </>
                          ) : (
                            <div className="text-center">
                              <Upload className="mx-auto mb-2 h-8 w-8 text-gray-400" />
                              <p className="text-xs text-gray-400">Drop image or click to upload</p>
                            </div>
                          )}
                        </div>
                      </div>

                      {/* Motion/Pose Video (New) */}
                      <div>
                        <span className="mb-2 block text-xs font-bold tracking-wider text-gray-400 uppercase">
                          Motion / Pose Video
                        </span>
                        <div className="relative flex aspect-video w-full flex-col items-center justify-center overflow-hidden rounded-xl border-2 border-dashed border-white/20 bg-white/5 transition-colors hover:bg-white/10">
                          {config.motionVideo ? (
                            <>
                              <video
                                src={
                                  typeof config.motionVideo === 'string'
                                    ? config.motionVideo
                                    : URL.createObjectURL(config.motionVideo)
                                }
                                className="absolute inset-0 h-full w-full object-cover"
                                autoPlay
                                muted
                                loop
                              />
                              <div className="absolute inset-0 z-10 flex cursor-pointer items-center justify-center bg-black/50 opacity-0 transition-opacity hover:opacity-100">
                                <label className="cursor-pointer">
                                  <Upload className="h-6 w-6 text-white" />
                                  <input
                                    type="file"
                                    accept="video/*"
                                    className="hidden"
                                    onChange={e => {
                                      const file = e.target.files?.[0];
                                      if (file) setConfig({ ...config, motionVideo: file });
                                    }}
                                  />
                                </label>
                              </div>
                              <button
                                onClick={() => setConfig({ ...config, motionVideo: null })}
                                className="absolute top-2 right-2 z-20 rounded bg-black/60 p-1 text-white transition-colors hover:bg-red-500"
                              >
                                <X className="h-3 w-3" />
                              </button>
                            </>
                          ) : (
                            <label className="flex h-full w-full cursor-pointer flex-col items-center justify-center">
                              <Upload className="mx-auto mb-2 h-8 w-8 text-gray-400" />
                              <p className="text-xs text-gray-400">Upload Motion Video</p>
                              <input
                                type="file"
                                accept="video/*"
                                className="hidden"
                                onChange={e => {
                                  const file = e.target.files?.[0];
                                  if (file) setConfig({ ...config, motionVideo: file });
                                }}
                              />
                            </label>
                          )}
                        </div>
                      </div>

                      {/* Advanced Settings Accordion */}
                      <div className="overflow-hidden rounded-lg border border-white/10">
                        <button
                          onClick={() => toggleSection('loras')}
                          className="flex w-full items-center justify-between bg-white/5 p-3 transition-colors hover:bg-white/10"
                        >
                          <span className="flex items-center gap-2 text-xs font-bold text-gray-300">
                            <Settings2 className="h-3.5 w-3.5" />
                            LoRAs & Checkpoints
                          </span>
                          <ChevronDown
                            className={clsx(
                              'h-4 w-4 text-gray-400 transition-transform',
                              expandedSections.includes('loras') && 'rotate-180'
                            )}
                          />
                        </button>

                        {expandedSections.includes('loras') && (
                          <div className="space-y-3 border-t border-white/5 p-3">
                            {config.loras && config.loras.length > 0 && (
                              <div className="space-y-2">
                                <span className="text-[10px] font-bold text-gray-500 uppercase">
                                  LoRA Strengths
                                </span>
                                {config.loras.map(lora => (
                                  <div
                                    key={lora.id}
                                    className="rounded-lg border border-white/5 bg-black/20 p-2"
                                  >
                                    <div className="mb-1 flex items-center justify-between">
                                      <span className="flex-1 truncate text-xs text-gray-300">
                                        {lora.name}
                                      </span>
                                      <div className="flex items-center gap-2">
                                        <span className="w-8 text-right text-[10px] text-gray-500">
                                          {lora.strength.toFixed(1)}
                                        </span>
                                        <button
                                          onClick={() => handleToggleLoRA(lora)}
                                          className="text-gray-500 hover:text-red-400"
                                        >
                                          <X className="h-3 w-3" />
                                        </button>
                                      </div>
                                    </div>
                                    <input
                                      type="range"
                                      min="0"
                                      max="2"
                                      step="0.1"
                                      value={lora.strength}
                                      onChange={e =>
                                        handleLoRAStrengthChange(
                                          lora.id,
                                          parseFloat(e.target.value)
                                        )
                                      }
                                      className="h-1 w-full accent-blue-500"
                                    />
                                  </div>
                                ))}
                              </div>
                            )}

                            <button
                              onClick={() =>
                                setActiveManager(activeManager === 'lora' ? null : 'lora')
                              }
                              className={clsx(
                                'w-full rounded-lg border border-dashed py-2 text-xs transition-colors',
                                activeManager === 'lora'
                                  ? 'border-blue-500/50 bg-blue-500/10 text-blue-400'
                                  : 'border-white/20 text-gray-400 hover:bg-white/5 hover:text-white'
                              )}
                            >
                              {activeManager === 'lora' ? 'Close Manager' : '+ Add LoRAs'}
                            </button>
                          </div>
                        )}
                      </div>

                      {/* Sampler & Scheduler Accordion */}
                      <div className="overflow-hidden rounded-lg border border-white/10">
                        <button
                          onClick={() => toggleSection('sampler-scheduler')}
                          className="flex w-full items-center justify-between bg-white/5 p-3 transition-colors hover:bg-white/10"
                        >
                          <span className="flex items-center gap-2 text-xs font-bold text-gray-300">
                            <Sliders className="h-3.5 w-3.5" />
                            Sampler & Scheduler
                          </span>
                          <ChevronDown
                            className={clsx(
                              'h-4 w-4 text-gray-400 transition-transform',
                              expandedSections.includes('sampler-scheduler') && 'rotate-180'
                            )}
                          />
                        </button>

                        {expandedSections.includes('sampler-scheduler') && (
                          <div className="border-t border-white/5 p-3">
                            <div className="grid grid-cols-2 gap-2">
                              {/* Sampler */}
                              <div>
                                <span className="mb-1 block text-[10px] font-bold text-gray-500 uppercase">
                                  Sampler
                                </span>
                                <button
                                  onClick={() =>
                                    setActiveManager(activeManager === 'sampler' ? null : 'sampler')
                                  }
                                  className={clsx(
                                    'w-full truncate rounded border px-2 py-1.5 text-left text-xs transition-colors',
                                    activeManager === 'sampler'
                                      ? 'border-blue-500/50 bg-blue-500/10 text-blue-400'
                                      : 'border-white/10 bg-white/5 text-gray-300 hover:bg-white/10'
                                  )}
                                >
                                  {config.sampler?.name || 'DPM++ SDE Kar...'}
                                </button>
                              </div>

                              {/* Scheduler */}
                              <div>
                                <span className="mb-1 block text-[10px] font-bold text-gray-500 uppercase">
                                  Scheduler
                                </span>
                                <button
                                  onClick={() =>
                                    setActiveManager(
                                      activeManager === 'scheduler' ? null : 'scheduler'
                                    )
                                  }
                                  className={clsx(
                                    'w-full truncate rounded border px-2 py-1.5 text-left text-xs transition-colors',
                                    activeManager === 'scheduler'
                                      ? 'border-blue-500/50 bg-blue-500/10 text-blue-400'
                                      : 'border-white/10 bg-white/5 text-gray-300 hover:bg-white/10'
                                  )}
                                >
                                  {config.scheduler?.name || 'Karras'}
                                </button>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>

                      {/* Workflow Accordion */}
                      <div className="overflow-hidden rounded-lg border border-white/10">
                        <button
                          onClick={() => toggleSection('workflow')}
                          className="flex w-full items-center justify-between bg-white/5 p-3 transition-colors hover:bg-white/10"
                        >
                          <span className="flex items-center gap-2 text-xs font-bold text-gray-300">
                            <Sliders className="h-3.5 w-3.5" />
                            Workflow
                          </span>
                          <ChevronDown
                            className={clsx(
                              'h-4 w-4 text-gray-400 transition-transform',
                              expandedSections.includes('workflow') && 'rotate-180'
                            )}
                          />
                        </button>

                        {expandedSections.includes('workflow') && (
                          <div className="space-y-3 border-t border-white/5 p-3">
                            {/* Workflow Upload */}
                            <div>
                              <span className="mb-2 block text-[10px] font-bold text-gray-500 uppercase">
                                Custom Workflow (JSON)
                              </span>
                              {config.workflow?.name ? (
                                <div className="flex items-center gap-2 rounded-lg border border-green-500/30 bg-green-500/10 p-2">
                                  <FileJson className="h-4 w-4 text-green-400" />
                                  <span className="flex-1 truncate text-xs text-green-300">
                                    {config.workflow.name}
                                  </span>
                                  <button
                                    onClick={() =>
                                      setConfig(prev => ({ ...prev, workflow: undefined }))
                                    }
                                    className="text-gray-400 hover:text-red-400"
                                  >
                                    <X className="h-3 w-3" />
                                  </button>
                                </div>
                              ) : (
                                <label className="flex cursor-pointer items-center justify-center gap-2 rounded-lg border border-dashed border-white/20 p-3 transition-colors hover:border-purple-500/50 hover:bg-purple-500/10">
                                  <FolderOpen className="h-4 w-4 text-gray-400" />
                                  <span className="text-xs text-gray-400">
                                    Upload ComfyUI/Workflow JSON
                                  </span>
                                  <input
                                    type="file"
                                    accept=".json"
                                    className="hidden"
                                    onChange={e => {
                                      const file = e.target.files?.[0];
                                      if (file) {
                                        setConfig(prev => ({
                                          ...prev,
                                          workflow: { name: file.name, file },
                                        }));
                                      }
                                    }}
                                  />
                                </label>
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </div>

                  {/* RIGHT COLUMN - Quick Tags & Parameters */}
                  <div className="scrollbar-none @container flex w-[230px] flex-shrink-0 flex-col overflow-y-auto">
                    <div className="space-y-4 p-4">
                      {/* Quick Add Tags */}
                      <div>
                        <button
                          onClick={() => openTagsPanel()}
                          className={clsx(
                            'flex w-full items-center justify-between rounded-lg border px-3 py-2 text-sm font-medium transition-colors',
                            activeManager === 'tags'
                              ? 'border-blue-500/50 bg-blue-500/10 text-blue-400'
                              : 'border-white/10 bg-white/5 text-gray-300 hover:bg-white/10 hover:text-white'
                          )}
                        >
                          <span className="flex items-center gap-2">
                            <span></span> Add Cinematic Tags
                          </span>
                          <ChevronRight className="h-4 w-4 opacity-50" />
                        </button>
                      </div>

                      {/* Cinematic Inspiration - moved here so users can see selected tags */}
                      <div>
                        <span className="mb-2 block text-xs font-bold tracking-wider text-gray-400 uppercase">
                          Cinematic Inspiration
                        </span>
                        <textarea
                          value={config.inspiration}
                          onChange={e => setConfig({ ...config, inspiration: e.target.value })}
                          placeholder="E.g., 'Retro, gritty, eclectic, stylish, noir...'"
                          className="h-20 w-full resize-none rounded-lg border border-white/10 bg-black/30 p-2 text-xs text-white placeholder-gray-500 focus:border-white/30 focus:outline-none"
                        />
                      </div>

                      {/* Reference Strength */}
                      <div>
                        <div className="mb-2 flex items-center justify-between">
                          <span className="text-xs font-bold tracking-wider text-gray-400 uppercase">
                            Reference Strength
                          </span>
                          <span className="text-xs text-gray-400">{config.strength}%</span>
                        </div>
                        <input
                          type="range"
                          min="0"
                          max="100"
                          value={config.strength || 80}
                          onChange={e =>
                            setConfig({ ...config, strength: parseInt(e.target.value) })
                          }
                          className="w-full cursor-pointer accent-blue-500"
                        />
                      </div>

                      {/* CFG Scale */}
                      <div>
                        <div className="mb-2 flex items-center justify-between">
                          <span className="text-xs font-bold tracking-wider text-gray-400 uppercase">
                            CFG Scale
                          </span>
                          <span className="text-xs text-gray-400">
                            {config.guidanceScale?.toFixed(1) || '3.5'}
                          </span>
                        </div>
                        <input
                          type="range"
                          min="1"
                          max="20"
                          step="0.1"
                          value={config.guidanceScale || 3.5}
                          onChange={e =>
                            setConfig({ ...config, guidanceScale: parseFloat(e.target.value) })
                          }
                          className="w-full cursor-pointer accent-blue-500"
                        />
                      </div>

                      {/* Steps */}
                      <div>
                        <div className="mb-2 flex items-center justify-between">
                          <span className="text-xs font-bold tracking-wider text-gray-400 uppercase">
                            Steps
                          </span>
                          <span className="text-xs text-gray-400">{config.steps || 28}</span>
                        </div>
                        <input
                          type="range"
                          min="1"
                          max="50"
                          step="1"
                          value={config.steps || 28}
                          onChange={e => setConfig({ ...config, steps: parseInt(e.target.value) })}
                          className="w-full cursor-pointer accent-blue-500"
                        />
                      </div>

                      {/* Seed */}
                      <div>
                        <div className="mb-2 flex items-center justify-between">
                          <span className="text-xs font-bold tracking-wider text-gray-400 uppercase">
                            Seed
                          </span>
                          <button
                            onClick={generateRandomSeed}
                            className="flex items-center gap-1 text-xs text-gray-400 transition-colors hover:text-blue-400"
                          >
                            <Dice5 className="h-3 w-3" />
                            Random
                          </button>
                        </div>
                        <input
                          type="number"
                          value={config.seed || ''}
                          onChange={e =>
                            setConfig({
                              ...config,
                              seed: e.target.value ? parseInt(e.target.value) : undefined,
                            })
                          }
                          placeholder="Random"
                          className="w-full rounded-lg border border-white/10 bg-black/30 px-3 py-2 text-sm text-white placeholder-gray-500 focus:border-white/30 focus:outline-none"
                        />
                      </div>

                      {/* Aspect Ratio */}
                      <div>
                        <span className="mb-2 block flex items-center gap-[clamp(4px,1cqw,8px)] text-[clamp(10px,2cqw,12px)] font-bold tracking-wider text-gray-400 uppercase">
                          <Ratio className="h-[clamp(10px,2cqw,12px)] w-[clamp(10px,2cqw,12px)]" />{' '}
                          Aspect Ratio
                          {isAnamorphicLocked && (
                            <span className="ml-1 rounded bg-blue-500/20 px-1.5 py-0.5 text-[9px] text-blue-400">
                              ANAMORPHIC LOCK
                            </span>
                          )}
                        </span>
                        {isAnamorphicLocked ? (
                          // Anamorphic locked mode - only 21:9
                          <div className="flex items-center gap-2">
                            <div className="rounded-lg border border-blue-500 bg-blue-600 px-[clamp(8px,2.5cqw,14px)] py-[clamp(4px,1.2cqw,8px)] text-[clamp(10px,2cqw,12px)] font-medium whitespace-nowrap text-white">
                              21:9
                            </div>
                            <span className="text-[10px] text-blue-400/70">
                              Anamorphic glass requires 2.39:1 widescreen
                            </span>
                          </div>
                        ) : (
                          // Normal mode - all aspect ratios
                          <div className="flex flex-wrap gap-[clamp(4px,1.5cqw,8px)]">
                            {['16:9', '9:16', '1:1', '21:9', '2.35:1'].map(ratio => (
                              <button
                                key={ratio}
                                onClick={() => setConfig({ ...config, aspectRatio: ratio })}
                                className={clsx(
                                  'rounded-lg border px-[clamp(8px,2.5cqw,14px)] py-[clamp(4px,1.2cqw,8px)] text-[clamp(10px,2cqw,12px)] font-medium whitespace-nowrap transition-colors',
                                  config.aspectRatio === ratio
                                    ? 'border-blue-500 bg-blue-600 text-white'
                                    : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                                )}
                              >
                                {ratio}
                              </button>
                            ))}
                          </div>
                        )}
                      </div>

                      {/* Lighting Lock - IP-Adapter for consistent lighting */}
                      <div className="rounded-lg border border-amber-500/20 bg-amber-500/5 p-3">
                        <div className="mb-2 flex items-center justify-between">
                          <div className="flex items-center gap-2">
                            <Lightbulb className="h-4 w-4 text-amber-400" />
                            <span className="text-xs font-bold tracking-wider text-amber-300 uppercase">
                              Lighting Lock
                            </span>
                          </div>
                          <button
                            onClick={() =>
                              setConfig({
                                ...config,
                                lightingLock: config.lightingLock?.enabled
                                  ? { ...config.lightingLock, enabled: false }
                                  : { enabled: true, strength: 0.25 },
                              })
                            }
                            className={clsx(
                              'relative h-5 w-8 rounded-full transition-colors',
                              config.lightingLock?.enabled ? 'bg-amber-500' : 'bg-gray-700'
                            )}
                          >
                            <div
                              className={clsx(
                                'absolute top-0.5 h-4 w-4 rounded-full bg-white transition-all',
                                config.lightingLock?.enabled ? 'left-3.5' : 'left-0.5'
                              )}
                            />
                          </button>
                        </div>

                        <p className="mb-2 text-[10px] text-gray-500">
                          Upload a reference image to lock lighting style across all generations
                          (uses IP-Adapter at low weight)
                        </p>

                        {config.lightingLock?.enabled && (
                          <div className="space-y-2">
                            {/* Upload Zone or Preview */}
                            {config.lightingLock.imageUrl || config.lightingLock.imageFile ? (
                              <div className="relative h-20 w-full overflow-hidden rounded-lg border border-amber-500/30">
                                <img
                                  src={
                                    config.lightingLock.imageFile
                                      ? URL.createObjectURL(config.lightingLock.imageFile)
                                      : config.lightingLock.imageUrl
                                  }
                                  alt="Lighting reference"
                                  className="h-full w-full object-cover"
                                />
                                <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent" />
                                <div className="absolute bottom-1 left-2 flex items-center gap-1 text-[10px] text-amber-300">
                                  <Lock className="h-3 w-3" />
                                  <span>Lighting locked</span>
                                </div>
                                <button
                                  onClick={() =>
                                    setConfig({
                                      ...config,
                                      lightingLock: {
                                        ...config.lightingLock!,
                                        imageUrl: undefined,
                                        imageFile: undefined,
                                      },
                                    })
                                  }
                                  className="absolute top-1 right-1 rounded bg-black/50 p-1 transition-colors hover:bg-red-500/50"
                                >
                                  <X className="h-3 w-3 text-white" />
                                </button>
                              </div>
                            ) : (
                              <label className="flex h-16 w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed border-amber-500/30 bg-amber-500/5 transition-colors hover:border-amber-500/50">
                                <Upload className="mb-1 h-4 w-4 text-amber-400" />
                                <span className="text-[10px] text-amber-300">
                                  Drop lighting reference
                                </span>
                                <input
                                  type="file"
                                  accept="image/*"
                                  className="hidden"
                                  onChange={e => {
                                    const file = e.target.files?.[0];
                                    if (file) {
                                      setConfig({
                                        ...config,
                                        lightingLock: { ...config.lightingLock!, imageFile: file },
                                      });
                                    }
                                  }}
                                />
                              </label>
                            )}

                            {/* Strength Slider */}
                            <div className="flex items-center gap-2">
                              <span className="w-14 text-[10px] text-gray-500">Strength:</span>
                              <input
                                type="range"
                                min="0.1"
                                max="0.5"
                                step="0.05"
                                value={config.lightingLock.strength}
                                onChange={e =>
                                  setConfig({
                                    ...config,
                                    lightingLock: {
                                      ...config.lightingLock!,
                                      strength: parseFloat(e.target.value),
                                    },
                                  })
                                }
                                className="h-1 flex-1 cursor-pointer appearance-none rounded-full bg-gray-700 [&::-webkit-slider-thumb]:h-3 [&::-webkit-slider-thumb]:w-3 [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-amber-500"
                              />
                              <span className="w-8 text-right text-[10px] text-amber-300">
                                {(config.lightingLock.strength * 100).toFixed(0)}%
                              </span>
                            </div>
                          </div>
                        )}
                      </div>

                      {/* Negative Prompt */}
                      <div>
                        <div>
                          <div className="mb-2 flex items-center justify-between">
                            <span className="block text-xs font-bold tracking-wider text-gray-400 uppercase">
                              Negative Prompt
                            </span>
                            <button
                              onClick={() =>
                                setActiveManager(activeManager === 'negative' ? null : 'negative')
                              }
                              className={clsx(
                                'flex items-center gap-1 text-[10px] font-medium transition-colors',
                                activeManager === 'negative'
                                  ? 'text-red-400'
                                  : 'text-gray-500 hover:text-white'
                              )}
                            >
                              <Library className="h-3 w-3" />
                              Library
                            </button>
                          </div>
                          <textarea
                            value={config.negativePrompt || ''}
                            onChange={e => setConfig({ ...config, negativePrompt: e.target.value })}
                            placeholder="E.g., 'blur, distortion, low quality, watermark...'"
                            className="h-16 w-full resize-none rounded-lg border border-white/10 bg-black/30 p-2 text-xs text-white placeholder-gray-500 focus:border-white/30 focus:outline-none"
                          />
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Footer */}
                <div className="flex justify-end gap-2 border-t border-white/10 bg-[#1a1a1a] p-4">
                  <button
                    onClick={onClose}
                    className="px-4 py-2 text-sm font-medium text-gray-400 transition-colors hover:text-white"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleApply}
                    className="rounded-lg bg-blue-600 px-6 py-2 text-sm font-medium text-white transition-colors hover:bg-blue-500"
                  >
                    Apply Style
                  </button>
                </div>
              </motion.div>

              {/* Side Panels for LoRA/Sampler/Scheduler */}
              <AnimatePresence>
                {activeManager === 'lora' && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    className="h-full max-h-full min-w-[400px] flex-shrink"
                  >
                    <LoRAManager
                      projectId={projectId}
                      isOpen={true}
                      onClose={() => setActiveManager(null)}
                      embedded={true}
                      selectedIds={config.loras?.map(l => l.id)}
                      onToggle={handleToggleLoRA}
                      currentModelId={currentModelId}
                    />
                  </motion.div>
                )}
                {activeManager === 'sampler' && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    className="h-full max-h-full min-w-[300px] flex-shrink"
                  >
                    <ParameterManager
                      projectId={projectId}
                      type="sampler"
                      isOpen={true}
                      onClose={() => setActiveManager(null)}
                      embedded={true}
                      selectedId={config.sampler?.id}
                      onSelect={handleSelectSampler}
                    />
                  </motion.div>
                )}
                {activeManager === 'scheduler' && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    className="h-full max-h-full min-w-[300px] flex-shrink"
                  >
                    <ParameterManager
                      projectId={projectId}
                      type="scheduler"
                      isOpen={true}
                      onClose={() => setActiveManager(null)}
                      embedded={true}
                      selectedId={config.scheduler?.id}
                      onSelect={handleSelectScheduler}
                    />
                  </motion.div>
                )}
                {activeManager === 'tags' && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    className="h-full max-h-full min-w-[400px] flex-shrink"
                  >
                    <CinematicTagsModal
                      isOpen={true}
                      onClose={() => setActiveManager(null)}
                      onSelectTag={handleAddTag}
                      initialCategory={initialTagCategory}
                      embedded={true}
                    />
                  </motion.div>
                )}
                {activeManager === 'negative' && (
                  <motion.div
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -20 }}
                    className="h-full max-h-full min-w-[350px] flex-shrink"
                  >
                    <NegativePromptManager
                      projectId={projectId}
                      isOpen={true}
                      onClose={() => setActiveManager(null)}
                      currentPrompt={config.negativePrompt}
                      onSelect={prompt => setConfig({ ...config, negativePrompt: prompt })}
                      embedded={true}
                    />
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        )}
      </AnimatePresence>

      <DataBackupModal
        isOpen={isBackupModalOpen}
        onClose={() => setIsBackupModalOpen(false)}
        projectId={projectId}
      />

      {/* Create Style Modal */}
      <CreateStyleModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onSave={handleCreateStyle}
      />
    </>
  );
}
</file>

<file path="frontend/src/components/generations/GenerationCard.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Generation, Element } from '@/lib/store';
import { analyzeGeneration, refineGeneration } from '@/lib/api';
import {
  Heart,
  Download,
  Trash2,
  X,
  Play,
  Loader2,
  Sparkles,
  Check,
  Maximize2,
  ZoomIn,
  FilePlus,
  Wand2,
  AlertTriangle,
  Lightbulb,
  Paintbrush,
  Film,
  ThumbsUp,
  ThumbsDown,
  Copy,
  GitFork,
  Clock,
  Zap,
  Expand,
  Layers,
  Sun,
  Eye,
  Clapperboard,
  Send,
} from 'lucide-react';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { clsx } from 'clsx';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { useDraggable } from '@dnd-kit/core';
import { Tooltip, TooltipProvider } from '@/components/ui/Tooltip';
import { CSS } from '@dnd-kit/utilities';
import {
  getModelConstraints,
  getConstraintViolations,
  getModelTips,
  ModelConstraints,
} from '@/lib/ModelConstraints';

interface GenerationCardProps {
  generation: Generation;
  elements?: Element[]; // Pass elements for lookup
  onUpdate: (id: string, updates: Partial<Generation>) => void;
  onDelete: (id: string) => void;
  onIterate: (prompt: string) => void;
  onUseSettings?: (generation: Generation) => void;
  onEdit?: () => void;
  onAnimate?: (imageUrl: string) => void;
  onRetake?: (videoUrl: string) => void;
  onInpaint?: (imageUrl: string, aspectRatio?: string) => void;
  onUpscale?: (imageUrl: string, model: string) => void;
  onSaveAsElement?: (url: string, type: 'image' | 'video') => void;
  onEnhanceVideo?: (generationId: string, mode: 'full' | 'audio-only' | 'smooth-only') => void;
  onReshoot?: (imageUrl: string, instruction: string) => Promise<void>;
  isSelected?: boolean;
  onToggleSelection?: (e: React.MouseEvent) => void;
  onFindSimilarComposition?: (generationId: string) => void;
  onFindSimilarLighting?: (generationId: string) => void;
  onFindSimilarVisual?: (generationId: string) => void;  // CLIP vector-based visual similarity
}

// Upscale options
const UPSCALE_OPTIONS: Array<{ id: string; name: string; description: string }> = [
  { id: 'fal-ai/clarity-upscaler', name: 'Clarity 2x', description: 'Sharp, detailed upscale' },
  { id: 'fal-ai/creative-upscaler', name: 'Clarity 4x', description: 'Maximum quality upscale' },
  { id: 'fal-ai/aura-sr', name: 'Aura SR', description: 'Fast AI upscaling' },
];

// Enhance video options
const ENHANCE_ITEMS: Array<{
  mode: 'full' | 'audio-only' | 'smooth-only';
  emoji: string;
  title: string;
  description: string;
}> = [
  {
    mode: 'audio-only',
    emoji: '',
    title: 'Add Audio Only',
    description: 'MMAudio (no speed change)',
  },
  {
    mode: 'smooth-only',
    emoji: '',
    title: 'Smooth Only',
    description: 'RIFE interpolation (24fps)',
  },
  { mode: 'full', emoji: '', title: 'Full Enhancement', description: 'Smooth + Audio' },
];

export function GenerationCard({
  generation,
  elements,
  onUpdate,
  onDelete,
  onIterate,
  onUseSettings,
  onEdit,
  onAnimate,
  onRetake,
  onInpaint,
  onUpscale,
  onSaveAsElement,
  onEnhanceVideo,
  onReshoot,
  isSelected,
  onToggleSelection,
  onFindSimilarComposition,
  onFindSimilarLighting,
  onFindSimilarVisual,
}: GenerationCardProps) {
  const router = useRouter();
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: generation.id,
    data: {
      type: 'generation',
      generation,
    },
  });

  const style = transform
    ? {
        transform: CSS.Translate.toString(transform),
        opacity: isDragging ? 0 : 1, // Hide original card while dragging
        zIndex: isDragging ? 100 : undefined,
      }
    : undefined;

  const [isHovered, setIsHovered] = useState(false);
  const [showPopup, setShowPopup] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const videoContainerRef = useRef<HTMLDivElement>(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [scrubPosition, setScrubPosition] = useState(0); // 0-1 position for scrub indicator
  const [editedPrompt, setEditedPrompt] = useState(generation.inputPrompt);
  const [isEditing, setIsEditing] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showUpscaleMenu, setShowUpscaleMenu] = useState(false);
  const [showEnhanceMenu, setShowEnhanceMenu] = useState(false);
  const [showReshootMenu, setShowReshootMenu] = useState(false);
  const [reshootInstruction, setReshootInstruction] = useState('');
  const [isReshooting, setIsReshooting] = useState(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [isRefining, setIsRefining] = useState(false);
  const [isRestoring, setIsRestoring] = useState(false);

  const handleRestoreSettings = async () => {
    if (!onUseSettings) return;
    setIsRestoring(true);
    // Small delay for visual feedback
    await new Promise(resolve => setTimeout(resolve, 500));
    onUseSettings(generation);
    setIsRestoring(false);
    setShowPopup(false);
  };

  // Copy Recipe: Format all generation settings as shareable JSON
  const handleCopyRecipe = async () => {
    const recipe = {
      // Core prompt
      prompt: generation.inputPrompt,
      negativePrompt: generation.usedLoras?.negativePrompt || null,

      // Model settings
      model: generation.usedLoras?.model || 'unknown',
      provider: generation.usedLoras?.provider || 'unknown',

      // Generation parameters
      aspectRatio: generation.aspectRatio,
      seed: generation.usedLoras?.seed || 'random',
      steps: generation.usedLoras?.steps || null,
      guidanceScale: generation.usedLoras?.guidanceScale || null,
      strength: generation.usedLoras?.strength || null,

      // Sampler/Scheduler
      sampler:
        typeof generation.usedLoras?.sampler === 'object'
          ? (generation.usedLoras.sampler as any).value ||
            (generation.usedLoras.sampler as any).name
          : generation.usedLoras?.sampler || null,
      scheduler:
        typeof generation.usedLoras?.scheduler === 'object'
          ? (generation.usedLoras.scheduler as any).value ||
            (generation.usedLoras.scheduler as any).name
          : generation.usedLoras?.scheduler || null,

      // LoRAs
      loras:
        generation.usedLoras?.loras?.map((lora: any) => ({
          id: lora.id,
          name: lora.name,
          path: lora.path,
          strength: lora.strength,
          triggerWord: lora.triggerWord,
        })) || [],

      // Reference images (IDs only for privacy)
      referenceStrengths: generation.usedLoras?.referenceStrengths || {},

      // Metadata
      _vibeboardRecipe: true,
      _version: '1.0',
      _createdAt: generation.createdAt,
    };

    try {
      await navigator.clipboard.writeText(JSON.stringify(recipe, null, 2));
      toast.success('Recipe copied to clipboard!', {
        description: 'Paste into any text editor or share with others',
        duration: 3000,
      });
    } catch (err) {
      console.error('Failed to copy recipe:', err);
      toast.error('Failed to copy recipe');
    }
  };

  // Feedback State for Analysis
  const [showAnalysisInput, setShowAnalysisInput] = useState(false);
  const [analysisFeedback, setAnalysisFeedback] = useState('');

  // AI Critique Feedback State
  const [critiqueFeedbackGiven, setCritiqueFeedbackGiven] = useState<
    'positive' | 'negative' | null
  >(null);
  const [showCritiqueCorrection, setShowCritiqueCorrection] = useState(false);
  const [critiqueCorrection, setCritiqueCorrection] = useState('');
  const [isSubmittingFeedback, setIsSubmittingFeedback] = useState(false);

  const handleSmartRefine = async () => {
    setIsRefining(true);
    try {
      console.log('Triggering Smart Refine for', generation.id);
      const result = await refineGeneration(generation.projectId, generation.id, '');
      if (result.success && result.refinedPrompt) {
        setEditedPrompt(result.refinedPrompt);
        console.log('Smart Refine success:', result);
      }
      setIsEditing(true); // Open edit mode with refined prompt (or old one if moved too fast)
    } catch (error) {
      console.error('Smart Refine failed', error);
      setIsEditing(true);
    } finally {
      setIsRefining(false);
    }
  };

  const confirmAnalyze = async () => {
    setIsAnalyzing(true);
    setShowAnalysisInput(false);
    // Reset feedback state for new analysis
    setCritiqueFeedbackGiven(null);
    setShowCritiqueCorrection(false);
    setCritiqueCorrection('');
    try {
      const analysis = await analyzeGeneration(
        generation.projectId,
        generation.id,
        analysisFeedback
      );
      // Update local state via onUpdate to show the new analysis immediately
      onUpdate(generation.id, {
        aiAnalysis: JSON.stringify(analysis),
        rating: analysis.rating,
      });
      toast.success(`Analysis complete: ${analysis.rating}/5 stars`, {
        duration: 3000,
      });
    } catch (error: any) {
      console.error('Analysis failed', error);
      toast.error(error.message || 'Analysis failed');
    } finally {
      setIsAnalyzing(false);
      setAnalysisFeedback('');
    }
  };

  const handleAnalyzeClick = () => {
    // Show input dialog first
    setShowAnalysisInput(true);
  };

  const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

  const handleCritiqueFeedback = async (isHelpful: boolean) => {
    if (isHelpful) {
      setCritiqueFeedbackGiven('positive');
      // Submit positive feedback
      try {
        const res = await fetch(`${apiUrl}/api/process/feedback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            context: 'generation-analysis',
            isHelpful: true,
            aiReasoning: JSON.stringify({
              advice: analysis?.advice || '',
              flaws: analysis?.flaws || [],
              rating: analysis?.rating,
            }),
            imageDescription: generation.inputPrompt,
          }),
        });
        if (!res.ok) throw new Error('Failed to submit feedback');
        const data = await res.json();
        toast.success(data.message || 'Thank you for the feedback!');
      } catch (e) {
        console.error('Failed to submit feedback:', e);
        toast.error('Failed to submit feedback');
        setCritiqueFeedbackGiven(null); // Reset on error
      }
    } else {
      setCritiqueFeedbackGiven('negative');
      setShowCritiqueCorrection(true);
    }
  };

  const submitCritiqueCorrection = async () => {
    if (!critiqueCorrection.trim()) {
      setShowCritiqueCorrection(false);
      setCritiqueFeedbackGiven(null);
      return;
    }

    setIsSubmittingFeedback(true);
    try {
      const res = await fetch(`${apiUrl}/api/process/feedback`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          context: 'generation-analysis',
          isHelpful: false,
          aiReasoning: JSON.stringify({
            advice: analysis?.advice || '',
            flaws: analysis?.flaws || [],
            rating: analysis?.rating,
          }),
          userCorrection: critiqueCorrection,
          imageDescription: generation.inputPrompt,
        }),
      });
      if (!res.ok) throw new Error('Failed to submit correction');
      const data = await res.json();
      toast.success(data.message || 'We will learn from this correction!');
      setShowCritiqueCorrection(false);
      setCritiqueCorrection('');
    } catch (e) {
      console.error('Failed to submit correction:', e);
      toast.error('Failed to submit correction');
    } finally {
      setIsSubmittingFeedback(false);
    }
  };

  const analysis =
    typeof generation.aiAnalysis === 'string'
      ? JSON.parse(generation.aiAnalysis)
      : generation.aiAnalysis;

  // Parse failure reason and provide actionable advice with model-specific context
  const getFailureAdvice = (
    reason: string | undefined,
    modelId?: string,
    usedLoras?: any
  ): {
    category: string;
    advice: string;
    icon: string;
    modelTips?: string[];
    constraintViolations?: string[];
  } => {
    if (!reason)
      return {
        category: 'Unknown Error',
        advice: 'Try generating again with the same settings.',
        icon: '',
      };

    const lowerReason = reason.toLowerCase();
    let modelTips: string[] = [];
    let constraintViolations: string[] = [];

    // Get model constraints if we have a model ID
    if (modelId) {
      const constraints = getModelConstraints(modelId);
      modelTips = getModelTips(modelId);

      // Check for constraint violations based on settings
      const loraCount = usedLoras?.loras?.length || 0;
      const referenceCount = usedLoras?.referenceCount || 0;

      constraintViolations = getConstraintViolations(modelId, {
        loraCount,
        referenceCount,
        hasNegativePrompt: !!usedLoras?.negativePrompt,
        hasCFG: usedLoras?.guidanceScale !== undefined,
      });

      // LoRA-specific errors with model context
      if (
        lowerReason.includes('lora') ||
        lowerReason.includes('adapter') ||
        lowerReason.includes('weight')
      ) {
        if (!constraints.supportsLoRA) {
          return {
            category: 'LoRA Not Supported',
            advice: `This model (${modelId.split('/').pop()}) does not support LoRAs. Remove all LoRAs and try again, or switch to a model like Flux Dev or SD 3.5 that supports LoRAs.`,
            icon: '',
            modelTips,
            constraintViolations: [`Model doesn't support LoRAs - you have ${loraCount} active`],
          };
        }
        if (constraints.maxLoRAs && loraCount > constraints.maxLoRAs) {
          return {
            category: 'Too Many LoRAs',
            advice: `This model supports maximum ${constraints.maxLoRAs} LoRAs, but you have ${loraCount}. Remove ${loraCount - constraints.maxLoRAs} LoRA(s) or reduce their strengths.`,
            icon: '',
            modelTips,
            constraintViolations: [`Max ${constraints.maxLoRAs} LoRAs, you have ${loraCount}`],
          };
        }
        return {
          category: 'LoRA Error',
          advice:
            'There was an issue loading one of your LoRAs. Try disabling some LoRAs, reducing their strength, or check if the LoRA is compatible with this model.',
          icon: '',
          modelTips,
        };
      }

      // Reference/IP-Adapter errors
      if (
        lowerReason.includes('reference') ||
        lowerReason.includes('ip-adapter') ||
        lowerReason.includes('image input') ||
        lowerReason.includes('control image')
      ) {
        if (constraints.maxReferences !== undefined) {
          if (referenceCount > constraints.maxReferences) {
            return {
              category: 'Too Many References',
              advice: `This model accepts maximum ${constraints.maxReferences} reference image(s), but you provided ${referenceCount}. Remove extra references.`,
              icon: '',
              modelTips,
              constraintViolations: [
                `Max ${constraints.maxReferences} references, you have ${referenceCount}`,
              ],
            };
          }
          if (constraints.minReferences && referenceCount < constraints.minReferences) {
            return {
              category: 'Missing Reference',
              advice: `This model requires at least ${constraints.minReferences} reference image(s). Add a character or pose reference to continue.`,
              icon: '',
              modelTips,
              constraintViolations: [
                `Requires ${constraints.minReferences} reference(s), you have ${referenceCount}`,
              ],
            };
          }
        }
        if (
          !constraints.supportsIPAdapter &&
          (lowerReason.includes('ip-adapter') || lowerReason.includes('face'))
        ) {
          return {
            category: 'IP-Adapter Not Supported',
            advice:
              'This model does not support IP-Adapter/face references. Try Flux Dev, SD 3.5, or a model with built-in character consistency like Flux Kontext.',
            icon: '',
            modelTips,
          };
        }
      }

      // NSFW with model-specific advice
      if (
        lowerReason.includes('nsfw') ||
        lowerReason.includes('safety') ||
        lowerReason.includes('content policy') ||
        lowerReason.includes('blocked') ||
        lowerReason.includes('inappropriate')
      ) {
        const nsfwStrength = constraints.nsfwStrength || 'moderate';
        let modelAdvice = '';

        if (nsfwStrength === 'strict') {
          modelAdvice =
            'This model has a STRICT content filter. Consider switching to Flux Dev, SD 3.5, or a local ComfyUI model for more permissive content.';
        } else if (nsfwStrength === 'moderate') {
          modelAdvice =
            'Try using more neutral language. Avoid suggestive poses or explicit descriptions. Some keywords may trigger the filter unexpectedly.';
        } else {
          modelAdvice =
            'Even permissive models have some limits. Check your prompt for prohibited terms.';
        }

        return {
          category: 'Content Policy',
          advice: modelAdvice,
          icon: '',
          modelTips:
            nsfwStrength === 'strict'
              ? ['This model has strict content filtering', ...modelTips]
              : modelTips,
        };
      }
    }

    // Rate limiting / Quota
    if (
      lowerReason.includes('rate limit') ||
      lowerReason.includes('quota') ||
      lowerReason.includes('too many requests') ||
      lowerReason.includes('429')
    ) {
      return {
        category: 'Rate Limited',
        advice:
          'Wait 1-2 minutes before trying again. High-demand models like Kling and Luma have stricter rate limits. Consider switching to a faster model like Flux Schnell temporarily.',
        icon: '',
        modelTips,
      };
    }

    // Timeout
    if (
      lowerReason.includes('timeout') ||
      lowerReason.includes('timed out') ||
      lowerReason.includes('deadline')
    ) {
      return {
        category: 'Timeout',
        advice:
          'The generation took too long. Try: reducing inference steps (25-30), using a smaller resolution, switching to a faster model (Flux Schnell, LTX-Video), or simplifying your prompt.',
        icon: '',
        modelTips,
      };
    }

    // Model not found / Invalid
    if (
      lowerReason.includes('model not found') ||
      lowerReason.includes('invalid model') ||
      lowerReason.includes('not available') ||
      lowerReason.includes('deprecated')
    ) {
      return {
        category: 'Model Unavailable',
        advice:
          'This model may be temporarily unavailable, deprecated, or renamed. Select a different model from the engine selector. Check if the provider is experiencing issues.',
        icon: '',
        modelTips,
      };
    }

    // Memory / GPU
    if (
      lowerReason.includes('memory') ||
      lowerReason.includes('gpu') ||
      lowerReason.includes('cuda') ||
      lowerReason.includes('out of memory') ||
      lowerReason.includes('oom')
    ) {
      return {
        category: 'Out of Memory',
        advice:
          'The server ran out of GPU memory. Try: smaller resolution (720p instead of 1080p), fewer inference steps (25-30), fewer LoRAs, or a less demanding model. For video, try shorter duration (3-5 seconds).',
        icon: '',
        modelTips,
      };
    }

    // Network / Connection
    if (
      lowerReason.includes('network') ||
      lowerReason.includes('connection') ||
      lowerReason.includes('fetch') ||
      lowerReason.includes('econnrefused') ||
      lowerReason.includes('socket')
    ) {
      return {
        category: 'Network Error',
        advice:
          'Connection issue with the AI provider. Check your internet connection, wait a moment, and try again. The provider may be experiencing temporary issues.',
        icon: '',
        modelTips,
      };
    }

    // Invalid aspect ratio
    if (
      lowerReason.includes('aspect ratio') ||
      lowerReason.includes('resolution') ||
      lowerReason.includes('size') ||
      lowerReason.includes('dimension')
    ) {
      return {
        category: 'Invalid Resolution',
        advice:
          'The aspect ratio or resolution is not supported by this model. Try standard ratios like 16:9, 9:16, 4:3, or 1:1. Some models have specific resolution requirements.',
        icon: '',
        modelTips,
      };
    }

    // Invalid input / parameters
    if (
      lowerReason.includes('invalid') ||
      lowerReason.includes('parameter') ||
      lowerReason.includes('validation')
    ) {
      return {
        category: 'Invalid Settings',
        advice:
          'One of your generation settings is invalid. Check: seed (use -1 for random), CFG scale (typically 3-7), steps (25-50), and ensure all required fields are filled.',
        icon: '',
        modelTips,
      };
    }

    // Generic server error
    if (
      lowerReason.includes('500') ||
      lowerReason.includes('server error') ||
      lowerReason.includes('internal') ||
      lowerReason.includes('503') ||
      lowerReason.includes('502')
    ) {
      return {
        category: 'Server Error',
        advice:
          'The AI provider encountered an internal error. This is usually temporary. Wait 30 seconds and try again. If it persists, try a different provider or model.',
        icon: '',
        modelTips,
      };
    }

    // Authentication
    if (
      lowerReason.includes('auth') ||
      lowerReason.includes('api key') ||
      lowerReason.includes('unauthorized') ||
      lowerReason.includes('401') ||
      lowerReason.includes('403')
    ) {
      return {
        category: 'Authentication Error',
        advice:
          'API key issue with this provider. Check that your API key is valid and has sufficient credits. Contact support if the issue persists.',
        icon: '',
        modelTips,
      };
    }

    // Prompt too long
    if (
      lowerReason.includes('prompt') &&
      (lowerReason.includes('long') ||
        lowerReason.includes('length') ||
        lowerReason.includes('token'))
    ) {
      return {
        category: 'Prompt Too Long',
        advice:
          'Your prompt exceeds the maximum length. Shorten your prompt by removing redundant details, combining similar concepts, or using more concise language.',
        icon: '',
        modelTips,
      };
    }

    // Default with model context
    return {
      category: 'Generation Failed',
      advice:
        'Try generating again. If the issue persists, try a different model, simplify your prompt, or reduce the number of references/LoRAs.',
      icon: '',
      modelTips,
      constraintViolations,
    };
  };

  // Get model ID from usedLoras if available
  const modelId = generation.usedLoras?.model;
  const failureInfo =
    generation.status === 'failed'
      ? getFailureAdvice(generation.failureReason, modelId, generation.usedLoras)
      : null;

  // Proxy Placeholder: Estimate generation time based on model
  const getEstimatedTime = (
    model?: string
  ): { label: string; isVideo: boolean; isSlow: boolean } => {
    if (!model) return { label: '~30s', isVideo: false, isSlow: false };

    const lowerModel = model.toLowerCase();

    // Premium video models - 1-5 minutes
    if (lowerModel.includes('kling') || lowerModel.includes('veo') || lowerModel.includes('luma')) {
      return { label: '2-5 min', isVideo: true, isSlow: true };
    }
    if (
      lowerModel.includes('wan') ||
      lowerModel.includes('minimax') ||
      lowerModel.includes('ltx')
    ) {
      return { label: '1-3 min', isVideo: true, isSlow: true };
    }

    // Image models
    if (lowerModel.includes('flux')) {
      return { label: '~15s', isVideo: false, isSlow: false };
    }
    if (lowerModel.includes('sd') || lowerModel.includes('stable')) {
      return { label: '~10s', isVideo: false, isSlow: false };
    }

    // Default
    return { label: '~30s', isVideo: false, isSlow: false };
  };

  const estimatedTime = getEstimatedTime(modelId);
  const elapsedSeconds = Math.floor((Date.now() - new Date(generation.createdAt).getTime()) / 1000);
  const elapsedDisplay =
    elapsedSeconds < 60
      ? `${elapsedSeconds}s`
      : `${Math.floor(elapsedSeconds / 60)}m ${elapsedSeconds % 60}s`;

  // Reset edited prompt when popup opens/closes or generation changes
  useEffect(() => {
    setEditedPrompt(generation.inputPrompt);
    setIsEditing(false);
  }, [generation.inputPrompt, showPopup]);

  const [showStatus, setShowStatus] = useState(() => {
    if (generation.status !== 'succeeded') return true;
    // Only show if created in the last 10 seconds
    return Date.now() - new Date(generation.createdAt).getTime() < 10000;
  });

  useEffect(() => {
    if (generation.status === 'succeeded') {
      const timer = setTimeout(() => setShowStatus(false), 5000);
      return () => clearTimeout(timer);
    } else {
      setShowStatus(true);
    }
  }, [generation.status]);

  const output = generation.outputs?.[0];
  const isVideo = output?.type === 'video';
  const rawUrl = output?.url;
  const mediaUrl =
    rawUrl && typeof rawUrl === 'string'
      ? rawUrl.startsWith('http') || rawUrl.startsWith('data:')
        ? rawUrl
        : `http://localhost:3001${rawUrl}`
      : undefined;

  // Hover-Scrub: Move mouse horizontally to scrub through video frames
  const handleVideoScrub = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!isVideo || !videoRef.current || !videoContainerRef.current) return;

    const rect = videoContainerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percentage = Math.max(0, Math.min(1, x / rect.width));

    // Update scrub indicator position
    setScrubPosition(percentage);

    // Seek video to corresponding time
    if (videoRef.current.duration && !isNaN(videoRef.current.duration)) {
      videoRef.current.currentTime = percentage * videoRef.current.duration;
    }
  };

  // Reset video on mouse leave
  useEffect(() => {
    if (isVideo && videoRef.current) {
      if (!isHovered) {
        videoRef.current.currentTime = 0;
        setScrubPosition(0);
      }
    }
  }, [isHovered, isVideo]);

  const handleDownload = async (e: React.MouseEvent) => {
    e.stopPropagation();
    if (mediaUrl) {
      try {
        // Fetch the file and download it properly
        const response = await fetch(mediaUrl);
        if (!response.ok) throw new Error('Network response was not ok');

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `generation-${generation.id}.${isVideo ? 'mp4' : 'png'}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);

        // Optional: success toast could go here
      } catch (error) {
        console.error('Download failed:', error);
        // Fallback to direct link
        const a = document.createElement('a');
        a.href = mediaUrl;
        a.download = `generation-${generation.id}.${isVideo ? 'mp4' : 'png'}`;
        a.target = '_blank'; // Safety fallback
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // TODO: Add toast.error("Download failed") here when toast provider is available
      }
    }
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowDeleteConfirm(true);
  };

  const confirmDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    onDelete(generation.id);
    setShowDeleteConfirm(false);
  };

  const toggleFavorite = (e: React.MouseEvent) => {
    e.stopPropagation();
    onUpdate(generation.id, { isFavorite: !generation.isFavorite });
  };

  const handleIterate = () => {
    onIterate(editedPrompt);
    setShowPopup(false);
  };

  const handleUpdatePrompt = () => {
    onUpdate(generation.id, { inputPrompt: editedPrompt });
    setIsEditing(false);
  };

  const handleUpscale = (e: React.MouseEvent, model: string) => {
    e.stopPropagation();
    if (mediaUrl && onUpscale) {
      onUpscale(mediaUrl, model);
    }
    setShowUpscaleMenu(false);
  };

  return (
    <TooltipProvider>
    <>
      <div
        ref={setNodeRef}
        style={style}
        {...listeners}
        {...attributes}
        className={clsx(
          'group @container relative cursor-pointer touch-none rounded-xl border bg-white/5 transition-all',
          isSelected
            ? 'border-blue-500 ring-1 ring-blue-500'
            : 'border-white/10 hover:border-blue-500/50'
        )}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        onClick={e => {
          if (onToggleSelection && (e.ctrlKey || e.metaKey || isSelected)) {
            e.stopPropagation();
            onToggleSelection(e);
          } else if (generation.status === 'succeeded' || generation.status === 'failed') {
            setShowPopup(true);
          }
        }}
      >
        <div
          className="@container relative overflow-hidden rounded-t-xl bg-black/50"
          style={{ aspectRatio: generation.aspectRatio?.replace(':', '/') || '16/9' }}
        >
          {/* FULL WIDTH TOOLBAR: Inside image container with container-relative sizing */}
          <div
            className={clsx(
              'absolute z-20 flex items-center justify-between transition-opacity duration-200',
              'top-[clamp(6px,2cqh,12px)] right-[clamp(6px,2cqw,12px)] left-[clamp(6px,2cqw,12px)]',
              isHovered || isSelected || generation.isFavorite || showUpscaleMenu || showEnhanceMenu || showReshootMenu
                ? 'opacity-100'
                : 'opacity-0'
            )}
          >
            {/* LEFT: Selection Checkbox + Favorite Heart */}
            <div className="flex items-center gap-[clamp(4px,1.2cqw,8px)]">
              {onToggleSelection && (
                <div
                  onClick={e => {
                    e.stopPropagation();
                    onToggleSelection(e);
                  }}
                  className={clsx(
                    'flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] cursor-pointer items-center justify-center rounded border-2 backdrop-blur-sm transition-colors',
                    isSelected
                      ? 'border-blue-500 bg-blue-500'
                      : 'border-white/60 bg-black/40 hover:border-white hover:bg-black/60'
                  )}
                >
                  {isSelected && <Check className="h-[60%] w-[60%] text-white" />}
                </div>
              )}
              {generation.status === 'succeeded' && (
                <button
                  onClick={toggleFavorite}
                  className={clsx(
                    'flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded backdrop-blur-sm transition-colors',
                    generation.isFavorite ? 'bg-red-500/80' : 'bg-black/40 hover:bg-red-500/50'
                  )}
                >
                  <Heart
                    className={clsx(
                      'h-[60%] w-[60%]',
                      generation.isFavorite ? 'fill-white text-white' : 'text-white'
                    )}
                  />
                </button>
              )}
            </div>

            {/* RIGHT: Action Buttons */}
            <div className="flex items-center gap-[clamp(4px,1.2cqw,8px)]">
              {/* Fullscreen (Success only) */}
              {generation.status === 'succeeded' && (
                <Tooltip content="Fullscreen" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      setShowPopup(true);
                      setIsFullscreen(true);
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-white/20"
                    aria-label="View fullscreen"
                  >
                    <Maximize2 className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Upscale (Success + Image only) - Radix Portal Dropdown */}
              {generation.status === 'succeeded' && !isVideo && onUpscale && (
                <DropdownMenu.Root open={showUpscaleMenu} onOpenChange={setShowUpscaleMenu}>
                  <Tooltip content="Upscale" side="top">
                    <DropdownMenu.Trigger asChild>
                      <button
                        onClick={e => e.stopPropagation()}
                        onPointerDown={e => e.stopPropagation()}
                        className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-green-600/80 backdrop-blur-sm transition-colors hover:bg-green-500"
                        aria-label="Upscale image"
                      >
                        <ZoomIn className="h-[60%] w-[60%] text-white" />
                      </button>
                    </DropdownMenu.Trigger>
                  </Tooltip>

                  <AnimatePresence>
                    {showUpscaleMenu && (
                      <DropdownMenu.Portal forceMount>
                        <DropdownMenu.Content
                          asChild
                          side="top"
                          align="end"
                          sideOffset={6}
                          onClick={e => e.stopPropagation()}
                        >
                          <motion.div
                            initial={{ opacity: 0, y: -5 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -5 }}
                            className="z-[9999] w-44 overflow-hidden rounded-lg border border-white/20 bg-[#1a1a1a] shadow-xl"
                          >
                            {UPSCALE_OPTIONS.map((option, idx) => (
                              <DropdownMenu.Item key={option.id} asChild>
                                <button
                                  onClick={e => handleUpscale(e, option.id)}
                                  className={clsx(
                                    'w-full px-3 py-2 text-left transition-colors outline-none hover:bg-green-500/20',
                                    idx < UPSCALE_OPTIONS.length - 1 && 'border-b border-white/5'
                                  )}
                                >
                                  <div className="text-sm font-medium text-white">
                                    {option.name}
                                  </div>
                                  <div className="text-[10px] text-gray-500">
                                    {option.description}
                                  </div>
                                </button>
                              </DropdownMenu.Item>
                            ))}
                          </motion.div>
                        </DropdownMenu.Content>
                      </DropdownMenu.Portal>
                    )}
                  </AnimatePresence>
                </DropdownMenu.Root>
              )}

              {/* AI Reshoot (Success + Image only) - Qwen Image Edit */}
              {generation.status === 'succeeded' && !isVideo && onReshoot && (
                <DropdownMenu.Root open={showReshootMenu} onOpenChange={setShowReshootMenu}>
                  <Tooltip content="AI Reshoot - Fix expression, gaze, pose" side="top">
                    <DropdownMenu.Trigger asChild>
                      <button
                        onClick={e => e.stopPropagation()}
                        onPointerDown={e => e.stopPropagation()}
                        className={clsx(
                          'flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded backdrop-blur-sm transition-colors',
                          isReshooting
                            ? 'bg-amber-500/80 animate-pulse'
                            : 'bg-amber-600/80 hover:bg-amber-500'
                        )}
                        aria-label="AI Reshoot"
                        disabled={isReshooting}
                      >
                        {isReshooting ? (
                          <Loader2 className="h-[60%] w-[60%] text-white animate-spin" />
                        ) : (
                          <Clapperboard className="h-[60%] w-[60%] text-white" />
                        )}
                      </button>
                    </DropdownMenu.Trigger>
                  </Tooltip>

                  <AnimatePresence>
                    {showReshootMenu && (
                      <DropdownMenu.Portal forceMount>
                        <DropdownMenu.Content
                          asChild
                          side="top"
                          align="end"
                          sideOffset={6}
                          onClick={e => e.stopPropagation()}
                        >
                          <motion.div
                            initial={{ opacity: 0, y: -5 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -5 }}
                            className="z-[9999] w-64 overflow-hidden rounded-lg border border-white/20 bg-[#1a1a1a] p-3 shadow-xl"
                          >
                            <div className="mb-2 flex items-center gap-2">
                              <Clapperboard className="h-4 w-4 text-amber-400" />
                              <span className="text-sm font-medium text-white">AI Reshoot</span>
                            </div>
                            <p className="mb-2 text-[10px] text-gray-400">
                              Fix expressions, gaze, or pose without regenerating the entire image.
                            </p>

                            {/* Quick presets */}
                            <div className="mb-2 flex flex-wrap gap-1">
                              {[
                                'Look at camera',
                                'Smile',
                                'Close mouth',
                                'Turn head left',
                                'Eyes open',
                              ].map(preset => (
                                <button
                                  key={preset}
                                  onClick={() => setReshootInstruction(preset)}
                                  className={clsx(
                                    'rounded border px-1.5 py-0.5 text-[9px] transition-all',
                                    reshootInstruction === preset
                                      ? 'border-amber-500/50 bg-amber-500/20 text-amber-300'
                                      : 'border-white/10 bg-white/5 text-gray-400 hover:border-white/20'
                                  )}
                                >
                                  {preset}
                                </button>
                              ))}
                            </div>

                            {/* Custom instruction input */}
                            <div className="flex gap-2">
                              <input
                                type="text"
                                value={reshootInstruction}
                                onChange={e => setReshootInstruction(e.target.value)}
                                onKeyDown={e => {
                                  if (e.key === 'Enter' && reshootInstruction.trim() && mediaUrl) {
                                    e.preventDefault();
                                    setIsReshooting(true);
                                    onReshoot(mediaUrl, reshootInstruction.trim())
                                      .then(() => {
                                        toast.success('Reshoot complete!');
                                        setReshootInstruction('');
                                        setShowReshootMenu(false);
                                      })
                                      .catch(err => toast.error(err.message || 'Reshoot failed'))
                                      .finally(() => setIsReshooting(false));
                                  }
                                }}
                                placeholder="e.g., Make character smile..."
                                className="flex-1 rounded border border-white/10 bg-black/50 px-2 py-1.5 text-xs text-white placeholder-gray-500 outline-none focus:border-amber-500/50"
                              />
                              <button
                                onClick={() => {
                                  if (reshootInstruction.trim() && mediaUrl) {
                                    setIsReshooting(true);
                                    onReshoot(mediaUrl, reshootInstruction.trim())
                                      .then(() => {
                                        toast.success('Reshoot complete!');
                                        setReshootInstruction('');
                                        setShowReshootMenu(false);
                                      })
                                      .catch(err => toast.error(err.message || 'Reshoot failed'))
                                      .finally(() => setIsReshooting(false));
                                  }
                                }}
                                disabled={!reshootInstruction.trim() || isReshooting}
                                className={clsx(
                                  'rounded px-2 py-1.5 transition-all',
                                  reshootInstruction.trim() && !isReshooting
                                    ? 'bg-amber-500 text-white hover:bg-amber-400'
                                    : 'bg-gray-700 text-gray-500 cursor-not-allowed'
                                )}
                              >
                                {isReshooting ? (
                                  <Loader2 className="h-3.5 w-3.5 animate-spin" />
                                ) : (
                                  <Send className="h-3.5 w-3.5" />
                                )}
                              </button>
                            </div>
                          </motion.div>
                        </DropdownMenu.Content>
                      </DropdownMenu.Portal>
                    )}
                  </AnimatePresence>
                </DropdownMenu.Root>
              )}

              {/* Animate (Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && onAnimate && (
                <Tooltip content="Animate" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      if (mediaUrl) onAnimate(mediaUrl);
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-purple-600/80 backdrop-blur-sm transition-colors hover:bg-purple-500"
                    aria-label="Animate image"
                  >
                    <Play className="h-[60%] w-[60%] fill-current text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Find Similar Composition (Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && onFindSimilarComposition && (
                <Tooltip content="Find Similar Composition" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      onFindSimilarComposition(generation.id);
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-purple-500/50"
                    aria-label="Find images with similar framing and composition"
                  >
                    <Layers className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Find Similar Lighting (Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && onFindSimilarLighting && (
                <Tooltip content="Find Similar Lighting" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      onFindSimilarLighting(generation.id);
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-amber-500/50"
                    aria-label="Find images with similar lighting setup"
                  >
                    <Sun className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Find Similar Visual (CLIP Vector - Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && onFindSimilarVisual && (
                <Tooltip content="Find Similar (AI Vision)" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      onFindSimilarVisual(generation.id);
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-cyan-500/50"
                    aria-label="Find visually similar images using AI"
                  >
                    <Eye className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Enhance Video Menu (Success + Video only) - Radix Portal Dropdown */}
              {generation.status === 'succeeded' && isVideo && onEnhanceVideo && (
                <DropdownMenu.Root open={showEnhanceMenu} onOpenChange={setShowEnhanceMenu}>
                  <Tooltip content="Enhance video" side="top">
                    <DropdownMenu.Trigger asChild>
                      <button
                        onClick={e => e.stopPropagation()}
                        onPointerDown={e => e.stopPropagation()}
                        className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-gradient-to-r from-purple-600/80 to-pink-600/80 backdrop-blur-sm transition-colors hover:from-purple-500 hover:to-pink-500 focus:ring-2 focus:ring-purple-400 focus:outline-none"
                        aria-label="Enhance video options"
                      >
                        <Wand2 className="h-[60%] w-[60%] text-white" />
                      </button>
                    </DropdownMenu.Trigger>
                  </Tooltip>

                  <AnimatePresence>
                    {showEnhanceMenu && (
                      <DropdownMenu.Portal forceMount>
                        <DropdownMenu.Content
                          asChild
                          side="top"
                          align="end"
                          sideOffset={8}
                          onClick={e => e.stopPropagation()}
                        >
                          <motion.div
                            initial={{ opacity: 0, y: 5 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: 5 }}
                            className="z-[9999] min-w-[180px] overflow-hidden rounded-lg border border-gray-700 bg-gray-900 shadow-xl"
                          >
                            {ENHANCE_ITEMS.map((item, idx) => (
                              <DropdownMenu.Item key={item.mode} asChild>
                                <button
                                  onClick={e => {
                                    e.stopPropagation();
                                    onEnhanceVideo(generation.id, item.mode);
                                    setShowEnhanceMenu(false);
                                  }}
                                  className={clsx(
                                    'flex w-full items-center gap-2 px-3 py-2 text-left text-sm text-white outline-none hover:bg-purple-600/50',
                                    idx < ENHANCE_ITEMS.length - 1 && 'border-b border-gray-700'
                                  )}
                                >
                                  <span className="text-lg">{item.emoji}</span>
                                  <div>
                                    <div className="font-medium">{item.title}</div>
                                    <div className="text-xs text-gray-400">{item.description}</div>
                                  </div>
                                </button>
                              </DropdownMenu.Item>
                            ))}
                          </motion.div>
                        </DropdownMenu.Content>
                      </DropdownMenu.Portal>
                    )}
                  </AnimatePresence>
                </DropdownMenu.Root>
              )}

              {/* Roto & Paint (Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && mediaUrl && (
                <Tooltip content="Roto & Paint" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      // Encode the URL for safe passing via query params
                      const encodedUrl = encodeURIComponent(mediaUrl);
                      router.push(
                        `/projects/${generation.projectId}/process?url=${encodedUrl}&tool=eraser`
                      );
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-orange-600/80 backdrop-blur-sm transition-colors hover:bg-orange-500"
                    aria-label="Edit in Roto & Paint"
                  >
                    <Paintbrush className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Set Extension / Outpaint (Success + Image only) */}
              {generation.status === 'succeeded' && !isVideo && mediaUrl && (
                <Tooltip content="Set Extension" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      const encodedUrl = encodeURIComponent(mediaUrl);
                      router.push(
                        `/projects/${generation.projectId}/process?url=${encodedUrl}&tool=extend`
                      );
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-teal-600/80 backdrop-blur-sm transition-colors hover:bg-teal-500"
                    aria-label="Extend image (Infinite Canvas)"
                  >
                    <Expand className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Rotoscope (Success + Video only) */}
              {generation.status === 'succeeded' && isVideo && mediaUrl && (
                <Tooltip content="Rotoscope" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      const encodedUrl = encodeURIComponent(mediaUrl);
                      router.push(
                        `/projects/${generation.projectId}/process?video=${encodedUrl}&tool=rotoscope`
                      );
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-cyan-600/80 backdrop-blur-sm transition-colors hover:bg-cyan-500"
                    aria-label="Edit in Rotoscope"
                  >
                    <Film className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Save as Element (Success only) */}
              {generation.status === 'succeeded' && onSaveAsElement && (
                <Tooltip content="Save as Element" side="top">
                  <button
                    onClick={e => {
                      e.stopPropagation();
                      if (mediaUrl) onSaveAsElement(mediaUrl, isVideo ? 'video' : 'image');
                    }}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-blue-500/50"
                    aria-label="Save as Element"
                  >
                    <FilePlus className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Download (Success only) */}
              {generation.status === 'succeeded' && (
                <Tooltip content="Download" side="top">
                  <button
                    onClick={handleDownload}
                    className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-white/20"
                    aria-label="Download media"
                  >
                    <Download className="h-[60%] w-[60%] text-white" />
                  </button>
                </Tooltip>
              )}

              {/* Delete (ALWAYS VISIBLE) */}
              <Tooltip content="Delete" side="top">
                <button
                  onClick={handleDelete}
                  className="flex h-[clamp(24px,8cqw,36px)] w-[clamp(24px,8cqw,36px)] items-center justify-center rounded bg-black/50 backdrop-blur-sm transition-colors hover:bg-red-500/50"
                  aria-label="Delete generation"
                >
                  <Trash2 className="h-[60%] w-[60%] text-red-400" />
                </button>
              </Tooltip>
            </div>
          </div>

          {/* Media content */}
          {generation.status === 'succeeded' && mediaUrl ? (
            isVideo ? (
              <div
                ref={videoContainerRef}
                className="relative h-full w-full"
                onMouseMove={handleVideoScrub}
              >
                <video
                  ref={videoRef}
                  src={mediaUrl}
                  className="h-full w-full object-cover"
                  muted
                  loop
                  playsInline
                  preload="metadata"
                  onContextMenu={e => e.stopPropagation()}
                  onPointerDown={e => {
                    // Stop propagation for right click (button 2) to prevent dnd-kit from grabbing it
                    if (e.button === 2) {
                      e.stopPropagation();
                    }
                  }}
                />
                {/* Hover-Scrub Indicator */}
                {isHovered && (
                  <>
                    {/* Scrub position line */}
                    <div
                      className="pointer-events-none absolute top-0 bottom-0 z-10 w-0.5 bg-white/80 transition-transform duration-75"
                      style={{ left: `${scrubPosition * 100}%` }}
                    />
                    {/* Progress bar at bottom */}
                    <div className="pointer-events-none absolute right-0 bottom-0 left-0 z-10 h-1 bg-black/50">
                      <div
                        className="h-full bg-blue-500 transition-all duration-75"
                        style={{ width: `${scrubPosition * 100}%` }}
                      />
                    </div>
                    {/* Film strip icon indicator */}
                    <div className="pointer-events-none absolute right-2 bottom-2 z-10 flex items-center gap-1 rounded bg-black/60 px-1.5 py-0.5 text-[10px] text-white/70 backdrop-blur-sm">
                      <Film className="h-3 w-3" />
                      <span>Scrub</span>
                    </div>
                  </>
                )}
              </div>
            ) : (
              <img
                src={mediaUrl}
                className="h-full w-full object-cover"
                loading="lazy"
                onContextMenu={e => e.stopPropagation()}
                onPointerDown={e => {
                  // Stop propagation for right click (button 2) to prevent dnd-kit from grabbing it
                  if (e.button === 2) {
                    e.stopPropagation();
                  }
                }}
              />
            )
          ) : (
            <div className="absolute inset-0 flex items-center justify-center">
              {generation.status === 'queued' || generation.status === 'running' ? (
                /* Proxy Placeholder - Enhanced loading state */
                <div className="absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-zinc-900 via-zinc-800/50 to-zinc-900">
                  {/* Animated background effect for slow video models */}
                  {estimatedTime.isSlow && (
                    <div className="pointer-events-none absolute inset-0 overflow-hidden">
                      <div className="absolute inset-0 animate-pulse bg-gradient-to-r from-transparent via-blue-500/5 to-transparent" />
                      <div
                        className="absolute inset-y-0 w-1/3 bg-gradient-to-r from-transparent via-white/3 to-transparent"
                        style={{
                          animation: 'shimmer 2s infinite',
                          left: '-33%',
                        }}
                      />
                    </div>
                  )}

                  {/* Main spinner */}
                  <div className="relative">
                    <Loader2
                      className={clsx(
                        'animate-spin',
                        estimatedTime.isSlow ? 'h-10 w-10 text-purple-400' : 'h-8 w-8 text-blue-500'
                      )}
                    />
                    {estimatedTime.isVideo && (
                      <Film className="absolute -right-1 -bottom-1 h-4 w-4 text-purple-300" />
                    )}
                  </div>

                  {/* Status and time info */}
                  <div className="mt-3 flex flex-col items-center gap-1">
                    <span className="text-xs font-medium text-white/80 capitalize">
                      {generation.status === 'queued' ? 'In Queue' : 'Generating'}
                    </span>

                    {/* Model name badge */}
                    {modelId && (
                      <span className="max-w-[120px] truncate text-[10px] text-gray-500">
                        {modelId.split('/').pop()?.split('-').slice(0, 2).join('-')}
                      </span>
                    )}

                    {/* Time display */}
                    <div className="mt-1 flex items-center gap-1.5">
                      <Clock className="h-3 w-3 text-gray-500" />
                      <span className="text-[10px] text-gray-400">
                        {elapsedDisplay} / {estimatedTime.label}
                      </span>
                    </div>

                    {/* Slow model warning */}
                    {estimatedTime.isSlow && elapsedSeconds > 60 && (
                      <div className="mt-1 flex items-center gap-1 text-[9px] text-amber-400/70">
                        <Zap className="h-2.5 w-2.5" />
                        <span>Premium model - please wait</span>
                      </div>
                    )}
                  </div>
                </div>
              ) : (
                <div className="flex flex-col items-center gap-2 px-4 text-center">
                  <span className="font-medium text-red-500">Failed</span>
                  {generation.failureReason && (
                    <span className="line-clamp-3 text-[10px] leading-tight text-red-400/80">
                      {generation.failureReason}
                    </span>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Status Badge */}
          <AnimatePresence>
            {showStatus && generation.status !== 'failed' && generation.status !== 'succeeded' && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className="pointer-events-none absolute bottom-2 left-2 z-10 rounded bg-black/60 px-2 py-1 text-xs text-white capitalize backdrop-blur-md"
              >
                {generation.status}
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        <div className="p-3">
          <p className="line-clamp-2 text-sm text-gray-300">{generation.inputPrompt}</p>
          <div className="mt-2 text-xs text-gray-500">
            {new Date(generation.createdAt).toLocaleTimeString()}
          </div>
        </div>

        {/* Delete Confirmation */}
        {showDeleteConfirm && (
          <div
            className="absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/90 p-4 text-center"
            onClick={e => e.stopPropagation()}
          >
            <p className="mb-3 text-sm font-medium text-white">Delete this generation?</p>
            <div className="flex gap-2">
              <button
                onClick={e => {
                  e.stopPropagation();
                  setShowDeleteConfirm(false);
                }}
                className="rounded bg-white/10 px-3 py-1 text-xs text-white hover:bg-white/20"
              >
                Cancel
              </button>
              <button
                onClick={confirmDelete}
                className="rounded bg-red-600 px-3 py-1 text-xs text-white hover:bg-red-500"
              >
                Delete
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Popup Modal */}
      <AnimatePresence>
        {showPopup && (
          <div
            className="fixed inset-0 z-[100] flex items-center justify-center bg-black/90 p-4 backdrop-blur-md"
            onClick={() => {
              setShowPopup(false);
              setIsFullscreen(false);
            }}
          >
            {(() => {
              // Determine if vertical layout is needed
              const isVertical = generation.aspectRatio
                ? generation.aspectRatio.includes(':')
                  ? parseInt(generation.aspectRatio.split(':')[1]) >
                    parseInt(generation.aspectRatio.split(':')[0])
                  : generation.aspectRatio.startsWith('portrait') ||
                    generation.aspectRatio === '9:16'
                : false;

              return (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  className={`relative flex w-full overflow-hidden rounded-2xl border border-white/10 bg-black shadow-2xl ${
                    isVertical ? 'h-[85vh] max-w-7xl flex-row' : 'max-h-[90vh] max-w-5xl flex-col'
                  }`}
                  onClick={e => e.stopPropagation()}
                >
                  {/* Top buttons row */}
                  <div className="absolute top-4 right-4 z-10 flex items-center gap-2">
                    <Tooltip content={isFullscreen ? 'Exit fullscreen' : 'Fullscreen'} side="top">
                      <button
                        onClick={() => setIsFullscreen(!isFullscreen)}
                        className="rounded-full bg-black/50 p-2 text-white transition-colors hover:bg-white/20"
                      >
                        <Maximize2 className="h-5 w-5" />
                      </button>
                    </Tooltip>
                    <Tooltip content="Close" side="top">
                      <button
                        onClick={() => {
                          setShowPopup(false);
                          setIsFullscreen(false);
                        }}
                        className="rounded-full bg-black/50 p-2 text-white transition-colors hover:bg-white/20"
                      >
                        <X className="h-6 w-6" />
                      </button>
                    </Tooltip>
                  </div>

                  {/* Fullscreen mode - just show the image/video */}
                  {isFullscreen ? (
                    <div
                      className="flex h-full w-full items-center justify-center bg-black"
                      onClick={() => setIsFullscreen(false)}
                    >
                      {isVideo ? (
                        <video
                          src={mediaUrl}
                          controls
                          autoPlay
                          className="max-h-full max-w-full object-contain"
                        />
                      ) : (
                        <img src={mediaUrl} className="max-h-full max-w-full object-contain" />
                      )}
                    </div>
                  ) : (
                    <>
                      <div
                        className={`flex items-center justify-center overflow-hidden bg-black ${
                          isVertical ? 'h-full w-2/3' : 'w-full flex-1'
                        }`}
                      >
                        {generation.status === 'failed' ? (
                          <div className="flex flex-col items-center justify-center p-8 text-center">
                            <div className="mb-4 text-6xl">{failureInfo?.icon}</div>
                            <h3 className="mb-2 text-xl font-bold text-red-400">
                              {failureInfo?.category}
                            </h3>
                            <p className="max-w-md text-sm text-gray-400">{failureInfo?.advice}</p>
                          </div>
                        ) : isVideo ? (
                          <video
                            src={mediaUrl}
                            controls
                            autoPlay
                            className="h-full w-full object-contain"
                          />
                        ) : (
                          <img src={mediaUrl} className="h-full w-full object-contain" />
                        )}
                      </div>

                      <div
                        className={`border-white/10 bg-[#1a1a1a] ${
                          isVertical
                            ? 'h-full w-1/3 overflow-y-auto border-l p-6'
                            : 'w-full border-t p-6'
                        }`}
                      >
                        {/* Failed Generation Details Panel */}
                        {generation.status === 'failed' ? (
                          <div>
                            <div className="mb-4 flex items-center justify-between">
                              <h3 className="text-lg font-bold text-white">What Went Wrong</h3>
                              <div className="flex gap-3">
                                {/* Copy Recipe Button */}
                                <Tooltip content="Copy recipe as JSON" side="top">
                                  <button
                                    onClick={handleCopyRecipe}
                                    className="flex items-center gap-1.5 text-sm font-medium text-gray-400 transition-colors hover:text-white"
                                  >
                                    <Copy className="h-3.5 w-3.5" />
                                    Copy
                                  </button>
                                </Tooltip>
                                {/* Fork Recipe Button */}
                                {onUseSettings && (
                                  <Tooltip content="Fork this recipe - load settings and retry" side="top">
                                    <button
                                      onClick={handleRestoreSettings}
                                      className={clsx(
                                        'flex items-center gap-1.5 text-sm font-medium transition-all duration-200',
                                        isRestoring
                                          ? 'scale-105 text-green-400'
                                          : 'text-purple-400 hover:text-purple-300'
                                      )}
                                    >
                                      {isRestoring ? (
                                        <>
                                          <Check className="h-3.5 w-3.5" />
                                          Forked!
                                        </>
                                      ) : (
                                        <>
                                          <GitFork className="h-3.5 w-3.5" />
                                          Fork & Retry
                                        </>
                                      )}
                                    </button>
                                  </Tooltip>
                                )}
                              </div>
                            </div>

                            {/* Raw Error Message */}
                            <div className="mb-4 rounded-lg border border-red-500/20 bg-red-500/10 p-3">
                              <span className="mb-1 block text-xs font-medium text-red-400">
                                Error Details
                              </span>
                              <p className="font-mono text-sm break-words text-gray-300">
                                {generation.failureReason || 'No error details available'}
                              </p>
                            </div>

                            {/* Prompt Used */}
                            <div className="mb-4">
                              <span className="mb-1 block text-xs text-gray-500">Prompt Used</span>
                              <p className="text-sm text-gray-400">{generation.inputPrompt}</p>
                            </div>

                            {/* Constraint Violations */}
                            {failureInfo?.constraintViolations &&
                              failureInfo.constraintViolations.length > 0 && (
                                <div className="mb-4 rounded-lg border border-yellow-500/20 bg-yellow-500/10 p-3">
                                  <div className="mb-2 flex items-center gap-2">
                                    <AlertTriangle className="h-4 w-4 text-yellow-400" />
                                    <span className="text-sm font-medium text-yellow-300">
                                      Model Constraints Violated
                                    </span>
                                  </div>
                                  <ul className="list-inside list-disc space-y-1 text-sm text-gray-300">
                                    {failureInfo.constraintViolations.map((v, i) => (
                                      <li key={i}>{v}</li>
                                    ))}
                                  </ul>
                                </div>
                              )}

                            {/* Quick Fix Suggestions */}
                            <div className="rounded-lg border border-blue-500/20 bg-blue-500/10 p-3">
                              <div className="mb-2 flex items-center gap-2">
                                <Lightbulb className="h-4 w-4 text-blue-400" />
                                <span className="text-sm font-medium text-blue-300">
                                  Suggested Fix
                                </span>
                              </div>
                              <p className="text-sm text-gray-300">{failureInfo?.advice}</p>
                            </div>

                            {/* Model Tips */}
                            {failureInfo?.modelTips && failureInfo.modelTips.length > 0 && (
                              <div className="mt-4 rounded-lg border border-purple-500/20 bg-purple-500/10 p-3">
                                <div className="mb-2 flex items-center gap-2">
                                  <Sparkles className="h-4 w-4 text-purple-400" />
                                  <span className="text-sm font-medium text-purple-300">
                                    Model Notes
                                  </span>
                                </div>
                                <ul className="list-inside list-disc space-y-1 text-xs text-gray-400">
                                  {failureInfo.modelTips.map((tip, i) => (
                                    <li key={i}>{tip}</li>
                                  ))}
                                </ul>
                              </div>
                            )}

                            {/* Generation Metadata for Failed */}
                            <div className="mt-6 border-t border-white/10 pt-4">
                              <h4 className="mb-3 text-xs font-semibold tracking-wider text-gray-500 uppercase">
                                Settings Used
                              </h4>
                              <div className="grid grid-cols-2 gap-4 text-xs">
                                <div>
                                  <span className="mb-1 block text-gray-500">Provider</span>
                                  <span className="text-white capitalize">
                                    {generation.usedLoras?.provider || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Model</span>
                                  <span className="break-all text-white">
                                    {generation.usedLoras?.model || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Resolution</span>
                                  <span className="text-white">
                                    {generation.aspectRatio || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Created</span>
                                  <span className="text-white">
                                    {new Date(generation.createdAt).toLocaleString()}
                                  </span>
                                </div>
                              </div>
                            </div>
                          </div>
                        ) : (
                          /* Successful Generation Details Panel */
                          <>
                            <div className="mb-4 flex items-center justify-between">
                              <h3 className="text-lg font-bold text-white">Generation Details</h3>
                              <div className="flex gap-3">
                                {/* Copy Recipe Button */}
                                <Tooltip content="Copy recipe as JSON" side="top">
                                  <button
                                    onClick={handleCopyRecipe}
                                    className="flex items-center gap-1.5 text-sm font-medium text-gray-400 transition-colors hover:text-white"
                                  >
                                    <Copy className="h-3.5 w-3.5" />
                                    Copy
                                  </button>
                                </Tooltip>
                                {/* Fork Recipe Button */}
                                {onUseSettings && (
                                  <Tooltip content="Fork this recipe - load exact settings into generator" side="top">
                                    <button
                                      onClick={handleRestoreSettings}
                                      className={clsx(
                                        'flex items-center gap-1.5 text-sm font-medium transition-all duration-200',
                                        isRestoring
                                          ? 'scale-105 text-green-400'
                                          : 'text-purple-400 hover:text-purple-300'
                                      )}
                                    >
                                      {isRestoring ? (
                                        <>
                                          <Check className="h-3.5 w-3.5" />
                                          Forked!
                                        </>
                                      ) : (
                                        <>
                                          <GitFork className="h-3.5 w-3.5" />
                                          Fork Recipe
                                        </>
                                      )}
                                    </button>
                                  </Tooltip>
                                )}
                                <button
                                  onClick={() => setIsEditing(!isEditing)}
                                  className="text-sm font-medium text-blue-400 hover:text-blue-300"
                                >
                                  {isEditing ? 'Cancel Edit' : 'Iterate Prompt'}
                                </button>
                              </div>
                            </div>

                            {isEditing ? (
                              <div className="space-y-4">
                                <textarea
                                  value={editedPrompt}
                                  onChange={e => setEditedPrompt(e.target.value)}
                                  className="h-32 w-full resize-none rounded-lg border border-white/10 bg-black/50 p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none"
                                  placeholder="Edit your prompt..."
                                />
                                <div className="flex justify-end gap-3">
                                  <button
                                    onClick={handleUpdatePrompt}
                                    className="rounded-lg bg-white/10 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-white/20"
                                  >
                                    Update Current
                                  </button>

                                  <button
                                    onClick={handleIterate}
                                    className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white shadow-lg shadow-blue-600/20 transition-colors hover:bg-blue-500"
                                  >
                                    Generate New
                                  </button>
                                </div>
                              </div>
                            ) : (
                              <div>
                                <p className="mb-4 text-gray-400">{generation.inputPrompt}</p>
                                {generation.usedLoras?.negativePrompt && (
                                  <div className="mb-4 border-t border-white/5 pt-3">
                                    <span className="mb-1 block text-xs text-gray-500">
                                      Negative Prompt
                                    </span>
                                    <p className="font-mono text-[10px] break-words text-gray-400 italic">
                                      {generation.usedLoras.negativePrompt}
                                    </p>
                                  </div>
                                )}
                                <button
                                  onClick={handleSmartRefine}
                                  disabled={isRefining}
                                  className="flex w-full items-center justify-center gap-2 rounded-lg border border-purple-500/30 bg-purple-600/20 py-2 text-sm font-medium text-purple-300 transition-colors hover:bg-purple-600/30 disabled:opacity-50"
                                >
                                  {isRefining ? (
                                    <Loader2 className="h-4 w-4 animate-spin" />
                                  ) : (
                                    <Sparkles className="h-4 w-4" />
                                  )}
                                  Smart Refine (Vision)
                                </button>

                                {/* Analyze Failure Button */}
                                {!analysis &&
                                  generation.status === 'succeeded' &&
                                  !showAnalysisInput && (
                                    <button
                                      onClick={handleAnalyzeClick}
                                      disabled={isAnalyzing}
                                      className="mt-2 flex w-full items-center justify-center gap-2 rounded-lg border border-red-500/30 bg-red-500/10 py-2 text-sm font-medium text-red-300 transition-colors hover:bg-red-500/20"
                                    >
                                      {isAnalyzing ? (
                                        <Loader2 className="h-4 w-4 animate-spin" />
                                      ) : (
                                        <AlertTriangle className="h-4 w-4" />
                                      )}
                                      Analyze Failure
                                    </button>
                                  )}

                                {/* Analysis Feedback Input */}
                                {showAnalysisInput && (
                                  <div className="animate-in fade-in slide-in-from-top-2 mt-2 rounded-lg border border-red-500/20 bg-red-900/10 p-3 duration-200">
                                    <p className="mb-2 text-xs font-medium text-red-200">
                                      What seems to be wrong? (Optional)
                                    </p>
                                    <textarea
                                      value={analysisFeedback}
                                      onChange={e => setAnalysisFeedback(e.target.value)}
                                      className="mb-2 h-20 w-full resize-none rounded border border-white/10 bg-black/40 p-2 text-xs text-white placeholder:text-white/20 focus:border-red-500/50 focus:outline-none"
                                      placeholder="E.g. The eyes are asymmetrical..."
                                      autoFocus
                                    />
                                    <div className="flex justify-end gap-2">
                                      <button
                                        onClick={() => setShowAnalysisInput(false)}
                                        className="px-3 py-1.5 text-xs text-gray-400 transition-colors hover:text-white"
                                      >
                                        Cancel
                                      </button>
                                      <button
                                        onClick={confirmAnalyze}
                                        className="flex items-center gap-1.5 rounded bg-red-600 px-3 py-1.5 text-xs font-medium text-white transition-colors hover:bg-red-500"
                                      >
                                        {isAnalyzing && (
                                          <Loader2 className="h-3 w-3 animate-spin" />
                                        )}
                                        Start Analysis
                                      </button>
                                    </div>
                                  </div>
                                )}

                                {/* Analysis Results Display */}
                                {analysis && (
                                  <div className="mt-4 rounded-lg border border-red-500/20 bg-red-500/5 p-3">
                                    <div className="mb-2 flex items-start justify-between">
                                      <h4 className="flex items-center gap-2 text-sm font-semibold text-red-200">
                                        <Lightbulb className="h-4 w-4" />
                                        AI Critique ({analysis.rating}/5)
                                      </h4>
                                    </div>

                                    <div className="space-y-3 text-xs">
                                      <div>
                                        <span className="block font-medium text-red-400">
                                          Flaws:
                                        </span>
                                        <ul className="list-inside list-disc pl-1 text-gray-300">
                                          {analysis.flaws?.map((flaw: string, i: number) => (
                                            <li key={i}>{flaw}</li>
                                          ))}
                                        </ul>
                                      </div>

                                      <div>
                                        <span className="block font-medium text-green-400">
                                          Good:
                                        </span>
                                        <p className="text-gray-300">
                                          {analysis.positiveTraits?.join(', ')}
                                        </p>
                                      </div>

                                      <div className="border-t border-white/5 pt-2">
                                        <span className="block font-medium text-blue-300">
                                          Advice:
                                        </span>
                                        <p className="text-gray-300 italic">"{analysis.advice}"</p>
                                      </div>

                                      {/* Feedback Buttons */}
                                      <div className="mt-3 border-t border-white/10 pt-3">
                                        {critiqueFeedbackGiven ? (
                                          <div className="flex items-center gap-2 text-xs text-gray-400">
                                            {critiqueFeedbackGiven === 'positive' ? (
                                              <>
                                                <ThumbsUp className="h-3 w-3 text-green-400" />
                                                Thanks for the feedback!
                                              </>
                                            ) : (
                                              <>
                                                <ThumbsDown className="h-3 w-3 text-red-400" />
                                                We'll learn from this!
                                              </>
                                            )}
                                          </div>
                                        ) : (
                                          <div className="flex items-center gap-3">
                                            <span className="text-xs text-gray-500">
                                              Was this helpful?
                                            </span>
                                            <Tooltip content="Yes, this was helpful" side="top">
                                              <button
                                                onClick={() => handleCritiqueFeedback(true)}
                                                className="rounded bg-green-500/10 p-1.5 text-green-400 transition-colors hover:bg-green-500/30"
                                              >
                                                <ThumbsUp className="h-3.5 w-3.5" />
                                              </button>
                                            </Tooltip>
                                            <Tooltip content="No, this was wrong" side="top">
                                              <button
                                                onClick={() => handleCritiqueFeedback(false)}
                                                className="rounded bg-red-500/10 p-1.5 text-red-400 transition-colors hover:bg-red-500/30"
                                              >
                                                <ThumbsDown className="h-3.5 w-3.5" />
                                              </button>
                                            </Tooltip>
                                          </div>
                                        )}

                                        {/* Correction Input */}
                                        {showCritiqueCorrection && (
                                          <div className="animate-in fade-in slide-in-from-top-2 mt-3 duration-200">
                                            <textarea
                                              value={critiqueCorrection}
                                              onChange={e => setCritiqueCorrection(e.target.value)}
                                              className="h-16 w-full resize-none rounded border border-white/10 bg-black/50 p-2 text-xs text-white placeholder:text-gray-500 focus:border-red-500/50 focus:outline-none"
                                              placeholder="What was wrong with this analysis?"
                                              autoFocus
                                            />
                                            <div className="mt-2 flex gap-2">
                                              <button
                                                onClick={() => {
                                                  setShowCritiqueCorrection(false);
                                                  setCritiqueFeedbackGiven(null);
                                                }}
                                                className="px-2 py-1 text-xs text-gray-400 transition-colors hover:text-white"
                                              >
                                                Cancel
                                              </button>
                                              <button
                                                onClick={submitCritiqueCorrection}
                                                disabled={isSubmittingFeedback}
                                                className="flex items-center gap-1 rounded bg-red-600 px-3 py-1 text-xs font-medium text-white transition-colors hover:bg-red-500 disabled:opacity-50"
                                              >
                                                {isSubmittingFeedback && (
                                                  <Loader2 className="h-3 w-3 animate-spin" />
                                                )}
                                                Submit
                                              </button>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    </div>
                                  </div>
                                )}
                              </div>
                            )}

                            {/* Generation Metadata */}
                            <div className="mt-6 border-t border-white/10 pt-4">
                              <h4 className="mb-3 text-xs font-semibold tracking-wider text-gray-500 uppercase">
                                Generation Details
                              </h4>
                              <div
                                className={`grid gap-4 text-xs ${isVertical ? 'grid-cols-2' : 'grid-cols-2 md:grid-cols-4'}`}
                              >
                                <div>
                                  <span className="mb-1 block text-gray-500">Provider</span>
                                  <span className="text-white capitalize">
                                    {generation.usedLoras?.provider || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Model</span>
                                  <span className="break-all text-white">
                                    {generation.usedLoras?.model || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Resolution</span>
                                  <span className="text-white">
                                    {generation.aspectRatio || 'Unknown'}
                                  </span>
                                </div>
                                <div>
                                  <span className="mb-1 block text-gray-500">Seed</span>
                                  <span className="font-mono text-white">
                                    {generation.usedLoras?.seed || 'Random'}
                                  </span>
                                </div>

                                {generation.usedLoras?.sampler && (
                                  <div>
                                    <span className="mb-1 block text-gray-500">Sampler</span>
                                    <span className="text-white">
                                      {typeof generation.usedLoras.sampler === 'object'
                                        ? (generation.usedLoras.sampler as any).name ||
                                          (generation.usedLoras.sampler as any).value
                                        : generation.usedLoras.sampler}
                                    </span>
                                  </div>
                                )}

                                {generation.usedLoras?.scheduler && (
                                  <div>
                                    <span className="mb-1 block text-gray-500">Scheduler</span>
                                    <span className="text-white">
                                      {typeof generation.usedLoras.scheduler === 'object'
                                        ? (generation.usedLoras.scheduler as any).name ||
                                          (generation.usedLoras.scheduler as any).value
                                        : generation.usedLoras.scheduler}
                                    </span>
                                  </div>
                                )}

                                {generation.usedLoras?.steps && (
                                  <div>
                                    <span className="mb-1 block text-gray-500">Steps</span>
                                    <span className="text-white">{generation.usedLoras.steps}</span>
                                  </div>
                                )}

                                {generation.usedLoras?.guidanceScale && (
                                  <div>
                                    <span className="mb-1 block text-gray-500">CFG</span>
                                    <span className="text-white">
                                      {generation.usedLoras.guidanceScale}
                                    </span>
                                  </div>
                                )}

                                {generation.usedLoras?.strength !== undefined && (
                                  <div>
                                    <span className="mb-1 block text-gray-500">Denoise</span>
                                    <span className="text-white">
                                      {Number(generation.usedLoras.strength).toFixed(2)}
                                    </span>
                                  </div>
                                )}

                                {generation.usedLoras?.referenceStrengths &&
                                  Object.keys(generation.usedLoras.referenceStrengths).length >
                                    0 && (
                                    <div className="col-span-2">
                                      <span className="mb-1 block text-gray-500">
                                        Ref Strengths
                                      </span>
                                      <div className="flex flex-col gap-1">
                                        {Object.entries(
                                          generation.usedLoras.referenceStrengths
                                        ).map(([id, str]: [string, any]) => {
                                          const element = elements?.find(e => e.id === id);
                                          const name = element
                                            ? element.name
                                            : id.substring(0, 6) + '...';
                                          return (
                                            <div
                                              key={id}
                                              className="flex items-center justify-between rounded bg-white/5 px-2 py-0.5 text-[10px] text-gray-400"
                                            >
                                              <Tooltip content={element?.name || id} side="left">
                                                <span className="max-w-[80px] truncate">
                                                  {name}
                                                </span>
                                              </Tooltip>
                                              <span className="ml-2 text-gray-300">
                                                {Number(str).toFixed(2)}
                                              </span>
                                            </div>
                                          );
                                        })}
                                      </div>
                                    </div>
                                  )}
                              </div>

                              {generation.usedLoras?.loras &&
                                generation.usedLoras.loras.length > 0 && (
                                  <div className="mt-4 border-t border-white/5 pt-3">
                                    <span className="mb-2 block text-xs text-gray-500">
                                      Active LoRAs
                                    </span>
                                    <div className="flex flex-wrap gap-2">
                                      {generation.usedLoras.loras.map((lora: any, idx: number) => (
                                        <div
                                          key={idx}
                                          className="rounded border border-white/10 bg-white/5 px-2 py-1 text-xs text-gray-300"
                                        >
                                          {lora.name || lora.path?.split('/').pop() || lora.id}
                                          <span className="ml-1 text-gray-500">
                                            ({lora.strength})
                                          </span>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                )}
                            </div>
                          </>
                        )}
                      </div>
                    </>
                  )}
                </motion.div>
              );
            })()}
          </div>
        )}
      </AnimatePresence>
    </>
    </TooltipProvider>
  );
}
</file>

<file path="frontend/src/app/projects/[id]/generate/page.tsx">
'use client';

import React, { useState, useEffect, useRef, useMemo, Suspense } from 'react';
import dynamic from 'next/dynamic';
import { fetchAPI, resolveFileUrl } from '@/lib/api';
import { useParams } from 'next/navigation';
import { toast } from 'sonner';
import { EngineSelectorV2 } from '@/components/generations/EngineSelectorV2';
import {
  Loader2,
  Image as ImageIcon,
  Video,
  Wand2,
  Sparkles,
  Layers,
  X,
  ChevronDown,
  SlidersHorizontal,
  Users,
  Trash2,
  Copy,
  CheckSquare,
  Database,
  Music,
  FilePlus,
  Tag as TagIcon,
  Code2,
  Package,
  GitBranch,
  Lightbulb,
} from 'lucide-react';
import { Element, Generation, Scene } from '@/lib/store';
import { clsx } from 'clsx';
import { GenerationCard } from '@/components/generations/GenerationCard';
import { GenerationSearch, GenerationSortFilterState } from '@/components/generations/GenerationSearch';
import { ShotNavigator, ShotNavigatorRef } from '@/components/generations/ShotNavigator';
import { ElementReferencePicker } from '@/components/storyboard/ElementReferencePicker';
import { StyleConfig } from '@/components/storyboard/StyleSelectorModal';
import { useSession } from '@/context/SessionContext';
import {
  DndContext,
  DragOverlay,
  useSensor,
  useSensors,
  PointerSensor,
  DragStartEvent,
  DragEndEvent,
  DragOverEvent,
  pointerWithin,
  useDraggable,
} from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { snapCenterToCursor } from '@dnd-kit/modifiers';

import { Tag } from '@/components/tag-system';
import { getModelRequirements } from '@/lib/ModelConstraints';
import { ALL_MODELS, PROVIDER_DEFINITIONS } from '@/lib/ModelRegistry';
import { useEngineConfigStore } from '@/lib/engineConfigStore';
import { costTracker } from '@/lib/CostTracker';
import { usePromptWeighting } from '@/hooks/usePromptWeighting';
import { WeightHintTooltip } from '@/components/prompts/WeightHintTooltip';
import { Tooltip } from '@/components/ui/Tooltip';
import { usePromptVariablesStore, detectUnexpandedVariables } from '@/lib/promptVariablesStore';
import { DynamicRatioIcon } from '@/components/ui/DynamicRatioIcon';
import { LensPreset, LENS_EFFECTS, buildLensPrompt } from '@/data/LensPresets';
import { usePropBinStore } from '@/lib/propBinStore';
import { usePromptTreeStore } from '@/lib/promptTreeStore';
import { useLightingStore } from '@/lib/lightingStore';
import { useSessionRecoveryStore, formatTimeAgo } from '@/lib/sessionRecoveryStore';

// === DYNAMIC IMPORTS for heavy modal components (loaded on demand) ===
const PromptBuilder = dynamic(() => import('@/components/prompts/PromptBuilder').then(m => ({ default: m.PromptBuilder })), {
  loading: () => <div className="flex items-center justify-center p-8"><Loader2 className="h-6 w-6 animate-spin text-cyan-400" /></div>,
  ssr: false
});

const StyleSelectorModal = dynamic(() => import('@/components/storyboard/StyleSelectorModal').then(m => ({ default: m.StyleSelectorModal })), {
  ssr: false
});

const SaveElementModal = dynamic(() => import('@/components/generations/SaveElementModal').then(m => ({ default: m.SaveElementModal })), {
  ssr: false
});

const EditElementModal = dynamic(() => import('@/components/elements/EditElementModal').then(m => ({ default: m.EditElementModal })), {
  ssr: false
});

const VideoMaskEditor = dynamic(() => import('@/components/generations/VideoMaskEditor').then(m => ({ default: m.VideoMaskEditor })), {
  ssr: false
});

const ImageMaskEditor = dynamic(() => import('@/components/generations/ImageMaskEditor').then(m => ({ default: m.ImageMaskEditor })), {
  ssr: false
});

const AudioInputModal = dynamic(() => import('@/components/generations/AudioInputModal').then(m => ({ default: m.AudioInputModal })), {
  ssr: false
});

const DataBackupModal = dynamic(() => import('@/components/settings/DataBackupModal').then(m => ({ default: m.DataBackupModal })), {
  ssr: false
});

const TagSelectorModal = dynamic(() => import('@/components/generation/TagSelectorModal').then(m => ({ default: m.TagSelectorModal })), {
  ssr: false
});

const CompactMotionSlider = dynamic(() => import('@/components/generation/CompactMotionSlider').then(m => ({ default: m.CompactMotionSlider })), {
  ssr: false
});

const LensKitSelector = dynamic(() => import('@/components/generation/LensKitSelector').then(m => ({ default: m.LensKitSelector })), {
  ssr: false
});

const PromptVariablesPanel = dynamic(() => import('@/components/prompts/PromptVariablesPanel').then(m => ({ default: m.PromptVariablesPanel })), {
  ssr: false
});

const PropBinPanel = dynamic(() => import('@/components/prompts/PropBinPanel').then(m => ({ default: m.PropBinPanel })), {
  ssr: false
});

const PromptTreePanel = dynamic(() => import('@/components/prompts/PromptTreePanel').then(m => ({ default: m.PromptTreePanel })), {
  ssr: false
});

const LightingStage = dynamic(() => import('@/components/lighting/LightingStage').then(m => ({ default: m.LightingStage })), {
  ssr: false
});

const AcousticStudioPanel = dynamic(() => import('@/components/audio/AcousticStudioPanel').then(m => ({ default: m.AcousticStudioPanel })), {
  ssr: false
});

interface PipelineStage {
  id: string;
  type: 'motion' | 'lipsync';
  videoFile?: File | null;
  videoUrl?: string | null;
  audioFile?: File | null;
  audioUrl?: string | null;
  model?: string; // Added for script parsing
  prompt?: string; // Added for script parsing
}

// Draggable Element Thumbnail - for dragging elements into Shot Navigator frame slots
interface DraggableElementThumbnailProps {
  element: Element;
  isSelected: boolean;
  onToggle: () => void;
}

function DraggableElementThumbnail({
  element,
  isSelected,
  onToggle,
}: DraggableElementThumbnailProps) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: `element-${element.id}`,
    data: {
      type: 'element',
      element: element,
      imageUrl: element.url || element.fileUrl || element.thumbnail,
    },
  });

  const style = transform
    ? {
        transform: CSS.Translate.toString(transform),
        opacity: isDragging ? 0 : 1,
        zIndex: isDragging ? 100 : undefined,
      }
    : undefined;

  return (
    <Tooltip content={`${element.name} (drag to Shot Navigator)`} side="top">
      <button
        ref={setNodeRef}
        style={style}
        {...listeners}
        {...attributes}
        onClick={onToggle}
        className={clsx(
          'relative h-16 w-16 flex-shrink-0 cursor-grab overflow-hidden rounded-lg border-2 transition-all active:cursor-grabbing',
          isSelected
            ? 'border-blue-500 ring-1 ring-blue-500/50'
            : 'border-transparent opacity-60 hover:opacity-100'
        )}
      >
        {element.type === 'video' ? (
          <video src={element.url} className="h-full w-full object-cover" />
        ) : (
          <img
            src={element.url || element.fileUrl || element.thumbnail}
            className="h-full w-full object-cover"
          />
        )}
        {isSelected && (
          <div className="absolute inset-0 flex items-center justify-center bg-blue-500/20">
            <div className="h-1.5 w-1.5 rounded-full bg-blue-500 shadow-lg" />
          </div>
        )}
      </button>
    </Tooltip>
  );
}

export default function GeneratePage() {
  const params = useParams();

  const projectId = params.id as string;

  const [prompt, setPrompt] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generations, setGenerations] = useState<Generation[]>([]);
  const [elements, setElements] = useState<Element[]>([]);
  const [scenes, setScenes] = useState<Scene[]>([]);
  const [aspectRatio, setAspectRatio] = useState('16:9');
  const [strength, setStrength] = useState(0.75); // Default strength
  const [variations, setVariations] = useState(1); // Default variations
  const [duration, setDuration] = useState('5'); // Default video duration
  const [isFocused, setIsFocused] = useState(false); // Input focus state
  const [mode, setMode] = useState<'image' | 'video'>('image'); // Generation mode
  const [steps, setSteps] = useState(30);
  const [guidanceScale, setGuidanceScale] = useState(7.5);
  const [selectedElementIds, setSelectedElementIds] = useState<string[]>([]);
  const [selectedGenerationIds, setSelectedGenerationIds] = useState<string[]>([]); // Added missing state
  const [searchResults, setSearchResults] = useState<Generation[] | null>(null); // Semantic search results
  const [searchQuery, setSearchQuery] = useState<string>(''); // Current search query
  const [sortFilter, setSortFilter] = useState<GenerationSortFilterState>({
    sortBy: 'date',
    sortOrder: 'desc',
    filterMediaType: [],
    filterStatus: [],
    filterAspectRatio: [],
  }); // Sort & filter state
  const [referenceCreativity, setReferenceCreativity] = useState(0.6); // Default reference strength
  const [elementStrengths, setElementStrengths] = useState<Record<string, number>>({}); // Per-element strength
  const [motionScale, setMotionScale] = useState(0.5); // Motion scale for video models (0-1)
  const { selectedSessionId, sessions } = useSession();

  // Audio State for Avatar Models
  const [audioFile, setAudioFile] = useState<File | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [isAudioModalOpen, setIsAudioModalOpen] = useState(false);
  const [isStyleModalOpen, setIsStyleModalOpen] = useState(false);
  const [isElementPickerOpen, setIsElementPickerOpen] = useState(false);
  const [isBackupModalOpen, setIsBackupModalOpen] = useState(false);
  const [isSaveElementModalOpen, setIsSaveElementModalOpen] = useState(false);
  const [isBatchSaveMode, setIsBatchSaveMode] = useState(false);
  const [saveElementData, setSaveElementData] = useState<{ url: string; type: string } | null>(
    null
  );

  // Pipeline / Node Workflow State
  const [pipelineStages, setPipelineStages] = useState<PipelineStage[]>([]);

  // Legacy Wan Animation State (replaced by pipeline, but keeping if needed for standalone Animate mode)
  // const [motionVideo, setMotionVideo] = useState<File | null>(null);
  // const [motionVideoUrl, setMotionVideoUrl] = useState<string | null>(null);

  // Drag and Drop state
  const [activeDragId, setActiveDragId] = useState<string | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);
  const [isOverShotNavigator, setIsOverShotNavigator] = useState(false);

  // Shot Navigator ref for calling methods from drag handler
  const shotNavigatorRef = useRef<ShotNavigatorRef>(null);

  // Autocomplete state
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestionQuery, setSuggestionQuery] = useState('');
  const [cursorPosition, setCursorPosition] = useState(0);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [styleConfig, setStyleConfig] = useState<StyleConfig | null>(null);

  // Cost tracking - track which generation IDs we've already recorded costs for
  // We store IDs of generations that were already succeeded on first load to avoid double-counting
  const recordedCostIds = useRef<Set<string>>(new Set());
  const initialLoadComplete = useRef<boolean>(false);

  // Prompt Variables: $VariableName expansion
  const { expandPrompt, variables: promptVariables } = usePromptVariablesStore();

  // Prop Bin: #PropName expansion for object consistency
  const { expandPropReferences, props: propBinItems } = usePropBinStore();
  const [isPropBinOpen, setIsPropBinOpen] = useState(false);

  // Prompt Tree: Version control for prompts
  const { addNode: addPromptNode, getTree, activeNodeId: treeActiveNodeId } = usePromptTreeStore();
  const promptTreeNodes = getTree(projectId);

  // Hydration safety: localStorage-based stores return different values on server vs client
  const [hasMounted, setHasMounted] = useState(false);
  useEffect(() => {
    setHasMounted(true);
  }, []);
  const [isPromptTreeOpen, setIsPromptTreeOpen] = useState(false);

  // Virtual Gaffer: 3-point lighting designer
  const {
    lights,
    isEnabled: lightingEnabled,
    generatePromptModifier: getLightingModifier,
    getLightingDescription,
  } = useLightingStore();
  const [isLightingStageOpen, setIsLightingStageOpen] = useState(false);

  // Acoustic Studio: Perspective-matched audio settings
  const [isAcousticStudioOpen, setIsAcousticStudioOpen] = useState(false);

  // Prompt Weighting: Ctrl/Cmd + Arrow Up/Down to adjust weights (word:1.1)
  const { handleKeyDown: handleWeightingKeyDown, isModifierHeld } = usePromptWeighting({
    value: prompt,
    onChange: setPrompt,
  });

  // Edit Modal State
  const [selectedGeneration, setSelectedGeneration] = useState<Generation | null>(null);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isPromptBuilderOpen, setIsPromptBuilderOpen] = useState(false);
  const [isTagSelectorOpen, setIsTagSelectorOpen] = useState(false);
  const [isVariablesPanelOpen, setIsVariablesPanelOpen] = useState(false);

  // Lens Kit State
  const [selectedLens, setSelectedLens] = useState<LensPreset | null>(null);
  const [selectedLensEffects, setSelectedLensEffects] = useState<string[]>([]);
  const [isAnamorphic, setIsAnamorphic] = useState(false);

  // Engine State
  const [engineConfig, setEngineConfig] = useState<{ provider: string; model: string }>({
    provider: 'fal',
    model: 'fal-ai/flux/dev',
  });

  // Engine Stacking
  const [enableMotionStacking, setEnableMotionStacking] = useState(false);

  // Model Requirements - computed from current model
  const modelRequirements = React.useMemo(() => {
    const requirements = getModelRequirements(engineConfig.model);
    const needsImage = requirements.some(r => r.input === 'image' || r.input === 'faceReference');
    const needsAudio = requirements.some(r => r.input === 'audio');
    const needsMotionVideo = requirements.some(r => r.input === 'motionVideo');
    const currentModel = ALL_MODELS.find(m => m.id === engineConfig.model);
    const isVideo = currentModel?.type === 'video';
    return { needsImage, needsAudio, needsMotionVideo, isVideo, requirements };
  }, [engineConfig.model]);

  // Auto-update mode when model changes
  React.useEffect(() => {
    const currentModel = ALL_MODELS.find(m => m.id === engineConfig.model);
    if (currentModel) {
      setMode(currentModel.type === 'video' ? 'video' : 'image');
    }
  }, [engineConfig.model]);

  // Sync engine config to global store for SpendingWidget
  const setCurrentConfig = useEngineConfigStore(state => state.setCurrentConfig);
  React.useEffect(() => {
    const currentModel = ALL_MODELS.find(m => m.id === engineConfig.model);
    setCurrentConfig({
      modelId: engineConfig.model,
      duration: duration + 's',
      isVideo: currentModel?.type === 'video' || false,
    });
  }, [engineConfig.model, duration, setCurrentConfig]);

  const handleAddTag = (tag: string, category: string) => {
    const prefix = prompt ? `${prompt}, ` : '';
    let newTag = tag;

    // Add context to the tag based on category
    if (category === 'cameras') newTag = `shot on ${tag}`;
    else if (category === 'lenses') newTag = `${tag} lens`;
    else if (category === 'films') newTag = `${tag} film stock`;
    else if (category === 'colors') newTag = `${tag} color grading`;
    else if (category === 'lighting') newTag = `${tag} lighting`;
    else if (category === 'cameraMotions') newTag = `${tag} camera movement`;
    else if (category === 'moods') newTag = `${tag} mood`;

    setPrompt(prefix + newTag);
    // Removed setActivePopover(null) as popover is replaced by modal
  };

  const handleStyleApply = (config: StyleConfig) => {
    setStyleConfig(config);
    setAspectRatio(config.aspectRatio);

    // Append inspiration to prompt if present
    if (config.inspiration) {
      setPrompt(prev => {
        const cleanPrev = prev.trim();
        return cleanPrev ? `${cleanPrev} -- ${config.inspiration}` : config.inspiration;
      });
    }

    // Update strength if present (convert 0-100 to 0-1 and invert for API denoising strength)
    // UI: 100% = High Resemblance (Low Noise)
    // API: 0.0 = Low Noise (High Resemblance)
    if (config.strength !== undefined) {
      setStrength(1 - config.strength / 100);
    }

    setIsStyleModalOpen(false);
  };

  useEffect(() => {
    if (projectId) {
      loadGenerations();
      loadElements();
      loadScenes();

      // Check backend config
      fetchAPI('/health')
        .then(data => {
          if (data.falConfigured === false) {
            console.log('Fal.ai not configured, defaulting to ComfyUI');
            setEngineConfig(prev => ({ ...prev, provider: 'comfy' }));
          }
        })
        .catch(console.error);

      // Poll for updates
      const interval = setInterval(() => {
        loadGenerations();
      }, 5000);
      return () => clearInterval(interval);
    }
  }, [projectId, selectedSessionId]);

  // Session Recovery Store
  const {
    saveSession,
    getRecoverableSession,
    dismissRecovery,
    clearSession,
    markClean,
    recoveryDismissed,
  } = useSessionRecoveryStore();

  // Check for recoverable session on mount
  const [showRecoveryToast, setShowRecoveryToast] = useState(false);
  const [recoverableSession, setRecoverableSession] = useState<ReturnType<typeof getRecoverableSession>>(null);

  useEffect(() => {
    if (!projectId || !hasMounted) return;

    const session = getRecoverableSession(projectId);
    if (session && session.isDirty && !recoveryDismissed) {
      setRecoverableSession(session);
      setShowRecoveryToast(true);
    }
  }, [projectId, hasMounted, getRecoverableSession, recoveryDismissed]);

  // Handle session recovery
  const handleRestoreSession = () => {
    if (!recoverableSession) return;

    setPrompt(recoverableSession.prompt);
    if (recoverableSession.negativePrompt) {
      // Apply negative prompt through style config if applicable
    }
    setEngineConfig({ provider: 'fal', model: recoverableSession.modelId });
    setMode(recoverableSession.mode === 'text_to_video' ? 'video' : 'image');
    setAspectRatio(recoverableSession.aspectRatio);
    setDuration(String(recoverableSession.duration));
    setVariations(recoverableSession.variations);
    setSelectedElementIds(recoverableSession.selectedElementIds);
    if (recoverableSession.audioFileUrl) {
      setAudioUrl(recoverableSession.audioFileUrl);
    }
    if (recoverableSession.lensKit) {
      setIsAnamorphic(recoverableSession.lensKit.isAnamorphic);
    }

    markClean();
    setShowRecoveryToast(false);
    toast.success('Session restored successfully');
  };

  const handleDismissRecovery = () => {
    dismissRecovery();
    setShowRecoveryToast(false);
  };

  // Auto-save session every 500ms
  useEffect(() => {
    if (!projectId || !hasMounted) return;

    const saveInterval = setInterval(() => {
      // Only save if there's meaningful content
      const hasContent = prompt.trim().length > 0 || selectedElementIds.length > 0;
      if (!hasContent) return;

      saveSession({
        projectId,
        prompt,
        negativePrompt: styleConfig?.negativePrompt || '',
        modelId: engineConfig.model,
        mode: mode === 'video' ? 'text_to_video' : 'text_to_image',
        aspectRatio,
        duration: parseInt(duration, 10) || 5,
        variations,
        selectedElementIds,
        audioFileUrl: audioUrl,
        lensKit: selectedLens
          ? {
              lensId: selectedLens.id,
              focalMm: selectedLens.focalMm,
              isAnamorphic,
            }
          : null,
        isDirty: true,
      });
    }, 500);

    return () => clearInterval(saveInterval);
  }, [
    projectId,
    hasMounted,
    prompt,
    engineConfig.model,
    mode,
    aspectRatio,
    duration,
    variations,
    selectedElementIds,
    audioUrl,
    selectedLens,
    isAnamorphic,
    styleConfig?.negativePrompt,
    saveSession,
  ]);

  // Clear dirty flag after successful generation
  const handleGenerationSuccess = () => {
    markClean();
  };

  const loadElements = async () => {
    try {
      console.log('Loading elements...');
      const data = await fetchAPI(`/elements`); // Fetch global elements
      const mapped: Element[] = data.map((e: Record<string, unknown>) => ({
        id: e.id,
        name: e.name,
        type: e.type,
        tags: e.tags || [],
        metadata: e.metadata,
        session: e.session,
        url: (() => {
          const u = e.fileUrl as string;
          if (!u) return '';
          if (u.startsWith('http') || u.startsWith('data:')) return u;
          return `http://localhost:3001${u.startsWith('/') ? '' : '/'}${u}`;
        })(),
        projectId: e.projectId,
      }));
      setElements(mapped);
      console.log('Loaded elements:', mapped.length);
      console.log('Current Project ID:', projectId);
      console.log('First Element Project ID:', mapped[0]?.projectId);
      console.log('Filtered count:', mapped.filter(e => e.projectId === projectId).length);
    } catch (err) {
      console.error(err);
    }
  };

  const loadScenes = async () => {
    try {
      console.log('Loading scenes. Selected Session:', selectedSessionId);
      const endpoint = selectedSessionId
        ? `/projects/${projectId}/scenes?sessionId=${selectedSessionId}`
        : `/projects/${projectId}/scenes`;
      console.log('Scene endpoint:', endpoint);
      const data = await fetchAPI(endpoint);
      setScenes(data);
    } catch (err) {
      console.error('Failed to load scenes', err);
    }
  };

  const loadGenerations = async () => {
    try {
      const endpoint = selectedSessionId
        ? `/projects/${params.id}/generations?sessionId=${selectedSessionId}`
        : `/projects/${params.id}/generations`;

      const data = await fetchAPI(endpoint);

      // On first load, just record the IDs of already-succeeded generations
      // so we don't count them as new costs
      if (!initialLoadComplete.current) {
        initialLoadComplete.current = true;
        for (const gen of data as Generation[]) {
          if (gen.status === 'succeeded') {
            recordedCostIds.current.add(gen.id);
          }
        }
      } else {
        // Track costs for newly succeeded generations (after initial load)
        for (const gen of data as Generation[]) {
          if (gen.status === 'succeeded' && !recordedCostIds.current.has(gen.id)) {
            // Mark as recorded to prevent duplicate tracking
            recordedCostIds.current.add(gen.id);

            // Get model info
            const modelId = gen.falModel || gen.usedLoras?.model || gen.usedLoras?.falModel;
            const provider = gen.engine || gen.usedLoras?.provider || 'unknown';
            const modelInfo = ALL_MODELS.find(m => m.id === modelId);
            const isVideo = gen.outputs?.[0]?.type === 'video';

            // Get duration from usedLoras or default
            const durationSeconds = gen.usedLoras?.duration
              ? parseInt(String(gen.usedLoras.duration).replace('s', ''), 10)
              : isVideo
                ? 5
                : undefined;

            // Record the cost
            costTracker.recordGeneration({
              modelId: modelId || 'unknown',
              modelName: modelInfo?.name || modelId || 'Unknown Model',
              provider: provider,
              type: isVideo ? 'video' : 'image',
              quantity: gen.outputs?.length || 1,
              durationSeconds: durationSeconds,
            });
          }
        }
      }

      setGenerations(data);
    } catch (error) {
      console.error('Failed to load generations:', error);
    }
  };

  const handleGenerate = async () => {
    if (!prompt.trim()) return;
    setIsGenerating(true);
    try {
      // Expand prompt variables ($VariableName -> actual value)
      let expandedPrompt = expandPrompt(prompt);

      // Expand prop references (#PropName -> prop description)
      expandedPrompt = expandPropReferences(expandedPrompt);

      // Add Lens Kit modifiers to the prompt (using buildLensPrompt helper)
      if (selectedLens || selectedLensEffects.length > 0 || isAnamorphic) {
        const lensPrompt = buildLensPrompt(selectedLens, isAnamorphic, selectedLensEffects);
        if (lensPrompt.positive) {
          expandedPrompt = `${expandedPrompt}, ${lensPrompt.positive}`;
        }
        // Note: lensPrompt.negative can be added to negative prompt if needed
      }

      // Add Virtual Gaffer lighting modifiers
      if (lightingEnabled && lights.length > 0) {
        const lightingModifier = getLightingModifier();
        if (lightingModifier) {
          expandedPrompt = `${expandedPrompt}, ${lightingModifier}`;
        }
      }
      // Handle Source Image Upload from Style Config
      let sourceImageUrl = null;
      if (styleConfig?.referenceImage) {
        if (styleConfig.referenceImage instanceof File) {
          const formData = new FormData();
          formData.append('file', styleConfig.referenceImage);
          formData.append('name', 'Source Image');
          formData.append('type', 'image');

          try {
            const res = await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
              method: 'POST',
              body: formData,
            });
            if (res.ok) {
              const data = await res.json();
              sourceImageUrl = data.fileUrl || data.url;
            }
          } catch (e) {
            console.error('Failed to upload source image', e);
          }
        } else if (typeof styleConfig.referenceImage === 'string') {
          sourceImageUrl = styleConfig.referenceImage;
        }
      }

      // Handle Audio Upload (for Avatar models)
      let finalAudioUrl = audioUrl;
      console.log('[GeneratePage] debug - audioFile:', audioFile);
      console.log('[GeneratePage] debug - current audioUrl state:', audioUrl);

      if (audioFile) {
        console.log('[GeneratePage] Uploading audio file...');
        const formData = new FormData();
        formData.append('file', audioFile);
        formData.append('name', 'Audio Source');
        formData.append('type', 'audio');

        try {
          const res = await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
            method: 'POST',
            body: formData,
          });
          if (res.ok) {
            const data = await res.json();
            finalAudioUrl = data.fileUrl || data.url;
            console.log('[GeneratePage] Audio uploaded successfully:', finalAudioUrl);
            // Update state so we don't re-upload if retrying without changing file
            setAudioUrl(finalAudioUrl);
          } else {
            console.error('[GeneratePage] Audio upload failed with status:', res.status);
          }
        } catch (e) {
          console.error('Failed to upload audio file', e);
        }
      } else {
        console.log('[GeneratePage] No audioFile to upload.');
      }

      // Handle Pipeline Assets Upload
      // Iterate stages, upload files if needed, update stage URLs
      const updatedStages = await Promise.all(
        pipelineStages.map(async stage => {
          const updatedStage = { ...stage };

          // Upload Video (Motion Stage)
          if (stage.type === 'motion' && stage.videoFile) {
            const formData = new FormData();
            formData.append('file', stage.videoFile);
            formData.append('name', 'Pipeline Motion Video');
            formData.append('type', 'video');
            try {
              const res = await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
                method: 'POST',
                body: formData,
              });
              if (res.ok) {
                const data = await res.json();
                updatedStage.videoUrl = data.url;
              }
            } catch (e) {
              console.error('Pipeline video upload failed', e);
            }
          }

          // Upload Audio (Lip Sync Stage) - Handles Video as Audio Source too
          if (stage.type === 'lipsync' && stage.audioFile) {
            const formData = new FormData();
            formData.append('file', stage.audioFile);
            formData.append('name', 'Pipeline AudioSource');
            // Determine type based on file (audio or video)
            const isVideo = stage.audioFile.type.startsWith('video');
            formData.append('type', isVideo ? 'video' : 'audio');

            try {
              const res = await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
                method: 'POST',
                body: formData,
              });
              if (res.ok) {
                const data = await res.json();
                updatedStage.audioUrl = data.url;
              }
            } catch (e) {
              console.error('Pipeline audio upload failed', e);
            }
          }
          return updatedStage;
        })
      );

      // Construct NextStage Chain (Recursive)
      // Chain: Base -> Stage 1 -> Stage 2 ...
      let pipelineConfig: Record<string, unknown> | undefined = undefined;

      // Build from last stage backwards
      for (let i = updatedStages.length - 1; i >= 0; i--) {
        const stage = updatedStages[i];
        let stageOptions: Record<string, unknown> = {};

        if (stage.type === 'motion') {
          // One-To-All Animation
          stageOptions = {
            model: 'fal-ai/one-to-all-animation/14b',
            inputVideo: stage.videoUrl, // Driving video
            prompt: prompt, // Use same prompt or allow override? Using base prompt for now.
          };
        } else if (stage.type === 'lipsync') {
          // Sync Lips
          stageOptions = {
            model: 'fal-ai/sync-lips', // or fal-ai/video-lipsync
            audioUrl: stage.audioUrl,
            prompt: prompt,
          };
        }

        if (pipelineConfig) {
          stageOptions.nextStage = pipelineConfig;
        }
        pipelineConfig = stageOptions;
      }

      const isVideo =
        engineConfig.model?.includes('video') ||
        engineConfig.model?.includes('t2v') ||
        engineConfig.model?.includes('i2v');

      // Auto-detect @ElementName references in prompt and include them
      // This ensures elements mentioned with @ syntax are included even if not manually selected
      // Use ORIGINAL prompt (not expanded) to preserve @ElementName syntax
      // Use case-insensitive matching and normalize separators for better UX
      const normalizeForMatch = (str: string) =>
        str.toLowerCase().replace(/[\s_.-]+/g, ''); // Remove spaces, underscores, dots, hyphens

      const promptNormalized = normalizeForMatch(prompt);

      const promptElementRefs = elements.filter(e => {
        // Check both exact match and normalized match
        const nameNormalized = normalizeForMatch(e.name);
        // Look for @elementname in the normalized prompt
        return (
          promptNormalized.includes(`@${nameNormalized}`) ||
          prompt.toLowerCase().includes(`@${e.name.toLowerCase()}`)
        );
      }).map(e => e.id);

      // Debug logging for element detection
      console.log(`[GeneratePage] Element detection:`, {
        rawPrompt: prompt,
        promptContains: prompt.match(/@[\w._-]+/g) || [],
        availableElements: elements.map(e => ({ name: e.name, id: e.id })),
        detectedRefs: promptElementRefs,
        selectedElementIds,
      });

      // Merge explicitly selected + prompt-referenced elements (deduplicate)
      const allReferencedElementIds = [...new Set([...selectedElementIds, ...promptElementRefs])];

      // Determine mode:
      // If sourceImageUrl exists -> image_to_image (or image_to_video)
      // If only selectedElementIds (Reference Elements) -> text_to_image (Flux handles refs via IP-Adapter)
      // Video models usually treat input images as start frames (image_to_video)
      const mode = isVideo
        ? sourceImageUrl || allReferencedElementIds.length > 0
          ? 'image_to_video'
          : 'text_to_video'
        : sourceImageUrl
          ? 'image_to_image'
          : 'text_to_image';

      // Log merged element references being sent to backend
      console.log(`[GeneratePage] Sending to backend:`, {
        mode,
        sourceElementIds: allReferencedElementIds,
        elementCount: allReferencedElementIds.length,
      });

      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode,
          inputPrompt: expandedPrompt,
          aspectRatio,
          sourceElementIds: allReferencedElementIds,
          sourceImages: sourceImageUrl ? [sourceImageUrl] : undefined, // Pass source image
          variations: 1,
          sessionId: selectedSessionId,
          engine: engineConfig.provider,
          falModel: engineConfig.model,
          // Pass structured style data if available
          shotType: styleConfig?.camera?.type,
          cameraAngle: styleConfig?.camera?.angle,
          lighting: styleConfig?.lighting?.type,
          location: styleConfig?.location?.type,
          strength: strength, // Use the separate strength state
          loras: styleConfig?.loras, // Pass selected LoRAs
          sampler: styleConfig?.sampler, // Pass selected Sampler
          scheduler: styleConfig?.scheduler, // Pass selected Scheduler
          guidanceScale: styleConfig?.guidanceScale || guidanceScale, // Pass selected CFG Scale
          steps: styleConfig?.steps || steps, // Pass selected Steps
          duration: duration ? Number(duration) : undefined, // Pass selected Duration (convert string to number)
          negativePrompt: styleConfig?.negativePrompt, // Pass Negative Prompt
          audioUrl: finalAudioUrl, // Pass audio URL for avatar models
          referenceStrengths: elementStrengths, // Pass per-element strengths
          referenceCreativity: referenceCreativity, // Pass global creativity fallback
          motionScale: motionScale, // Motion scale for video models (dedicated state)
          // inputVideo: inputVideoUrl, // Only needed for standalone motion mode, if supported handling existed.

          // Engine Stacking (Pipeline)
          nextStage:
            engineConfig.model === 'fal-ai/vidu/q2/reference-to-video' && pipelineConfig
              ? pipelineConfig
              : undefined,
        }),
      });

      // Save prompt to Prompt Tree for version control
      addPromptNode(projectId, prompt, {
        negativePrompt: styleConfig?.negativePrompt,
        metadata: {
          model: engineConfig.model,
          aspectRatio,
          lensPreset: selectedLens?.name,
          selectedElements: selectedElementIds,
        },
      });

      setPrompt('');
      handleGenerationSuccess(); // Clear auto-save dirty flag
      loadGenerations();
    } catch (err) {
      console.error(err);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleUpdateGeneration = async (id: string, updates: Partial<Generation>) => {
    try {
      await fetchAPI(`/projects/${projectId}/generations/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(updates),
      });
      loadGenerations();
    } catch (err) {
      console.error('Failed to update generation', err);
    }
  };

  const handleDeleteGeneration = async (id: string) => {
    try {
      await fetchAPI(`/projects/${projectId}/generations/${id}`, {
        method: 'DELETE',
      });
      loadGenerations();
    } catch (err) {
      console.error('Failed to delete generation', err);
    }
  };

  // Search handlers
  const handleSearchResults = (results: any[], query: string) => {
    setSearchResults(results as Generation[]);
    setSearchQuery(query);
  };

  const handleClearSearch = () => {
    setSearchResults(null);
    setSearchQuery('');
  };

  // Helper to determine media type from generation
  const getMediaType = (gen: Generation): 'image' | 'video' => {
    const outputType = gen.outputs?.[0]?.type;
    if (outputType) return outputType;
    const url = gen.outputs?.[0]?.url || '';
    if (url.match(/\.(mp4|webm|mov|avi)$/i)) {
      return 'video';
    }
    return 'image';
  };

  // Helper to extract aspect ratio from generation
  const getAspectRatio = (gen: Generation): string => {
    return gen.aspectRatio || '16:9';
  };

  // Displayed generations - search results or all, with filtering and sorting applied
  const displayedGenerations = useMemo(() => {
    let result = searchResults !== null ? searchResults : generations;

    // Apply filters
    if (sortFilter.filterMediaType.length > 0) {
      result = result.filter(gen => sortFilter.filterMediaType.includes(getMediaType(gen)));
    }

    if (sortFilter.filterStatus.length > 0) {
      result = result.filter(gen => {
        const status = gen.status || 'succeeded';
        if (sortFilter.filterStatus.includes('succeeded') && status === 'succeeded') {
          return true;
        }
        if (sortFilter.filterStatus.includes('processing') && (status === 'running' || status === 'queued')) {
          return true;
        }
        if (sortFilter.filterStatus.includes('failed') && status === 'failed') {
          return true;
        }
        return false;
      });
    }

    if (sortFilter.filterAspectRatio.length > 0) {
      result = result.filter(gen => {
        const ar = getAspectRatio(gen);
        return sortFilter.filterAspectRatio.includes(ar);
      });
    }

    // Apply sorting
    result = [...result].sort((a, b) => {
      let comparison = 0;
      switch (sortFilter.sortBy) {
        case 'date':
          const dateA = new Date(a.createdAt || 0).getTime();
          const dateB = new Date(b.createdAt || 0).getTime();
          comparison = dateA - dateB;
          break;
        case 'name':
          const nameA = (a.inputPrompt || '').toLowerCase();
          const nameB = (b.inputPrompt || '').toLowerCase();
          comparison = nameA.localeCompare(nameB);
          break;
        case 'score':
          const scoreA = (a as any).searchScore || 0;
          const scoreB = (b as any).searchScore || 0;
          comparison = scoreA - scoreB;
          break;
      }
      return sortFilter.sortOrder === 'asc' ? comparison : -comparison;
    });

    return result;
  }, [searchResults, generations, sortFilter]);

  const handleIterateGeneration = async (newPrompt: string) => {
    if (!newPrompt.trim()) return;
    setIsGenerating(true);
    try {
      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode: 'text_to_image',
          inputPrompt: newPrompt,
          aspectRatio,
          sourceElementIds: selectedElementIds,
          variations: 1,
          sessionId: selectedSessionId,
          engine: engineConfig.provider,
          falModel: engineConfig.model,
          styleGuideId: styleConfig?.preset?.id, // Link to preset if active
          // Using current settings for iteration
          ...styleConfig,
        }),
      });
      loadGenerations();
    } catch (error) {
      console.error('Failed to iterate generation:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleUseSettings = (generation: Generation) => {
    // Restore Engine Model
    // Fallback to usedLoras if top-level fields are missing/undefined
    const engine = generation.engine || generation.usedLoras?.provider || 'fal';
    const model =
      generation.falModel || generation.usedLoras?.model || generation.usedLoras?.falModel;

    if (engine && model && typeof model === 'string') {
      setEngineConfig({
        provider: engine,
        model: model,
      });
    }

    // Restore Mode (Image/Video)
    const isVideo = generation.outputs?.[0]?.type === 'video';
    setMode(isVideo ? 'video' : 'image');

    // Restore Duration if Video
    if (isVideo && generation.usedLoras?.duration) {
      setDuration(String(generation.usedLoras.duration));
    }

    // Restore Prompt & Aspect Ratio
    if (generation.inputPrompt) setPrompt(generation.inputPrompt);
    if (generation.aspectRatio) setAspectRatio(generation.aspectRatio);

    // Restore Elements Selection
    if (generation.sourceElementIds) {
      if (Array.isArray(generation.sourceElementIds)) {
        setSelectedElementIds(generation.sourceElementIds);
      } else if (typeof generation.sourceElementIds === 'string') {
        try {
          const parsed = JSON.parse(generation.sourceElementIds);
          if (Array.isArray(parsed)) setSelectedElementIds(parsed);
        } catch (e) {
          console.error('Failed to parse sourceElementIds', e);
        }
      }
    }

    // Restore Reference Strengths
    if (generation.usedLoras?.referenceStrengths) {
      setElementStrengths(generation.usedLoras.referenceStrengths);
    }

    // Restore Main Strength (Denoising Strength for API)
    // Note: generation.usedLoras.strength is 0-1 (Denoising)
    if (generation.usedLoras?.strength !== undefined) {
      setStrength(generation.usedLoras.strength);
    }

    // Restore StyleConfig structure
    // Helper to map string/object to object for dropdowns
    const mapToObj = (
      val?: string | Record<string, unknown>
    ): { id: string; name: string; value: string } | undefined => {
      if (!val) return undefined;
      if (
        typeof val === 'object' &&
        typeof val.id === 'string' &&
        typeof val.name === 'string' &&
        typeof val.value === 'string'
      ) {
        return val as { id: string; name: string; value: string };
      }
      if (typeof val === 'string') {
        return { id: val, name: val, value: val };
      }
      return undefined;
    };

    const restoredConfig: StyleConfig = {
      loras:
        generation.usedLoras?.loras?.map((l: Record<string, unknown>) => ({
          id: (l.id as string) || '',
          name: (l.name as string) || '',
          strength: (l.strength as number) || 1.0,
        })) || [],
      steps: generation.usedLoras?.steps || 30,
      guidanceScale: generation.usedLoras?.guidanceScale || 7.5,
      negativePrompt: generation.usedLoras?.negativePrompt || '',
      // Restore Sampler/Scheduler if present
      sampler: mapToObj(generation.usedLoras?.sampler),
      scheduler: mapToObj(generation.usedLoras?.scheduler),

      // Preserve other fields empty or default since we can't fully restore them without more data
      inspiration: '',
      preset: null,
      referenceImage: null,
      aspectRatio: generation.aspectRatio || '16:9',
      strength:
        generation.usedLoras?.strength !== undefined
          ? (1 - generation.usedLoras.strength) * 100
          : undefined,
      seed: generation.usedLoras?.seed,
    };
    setStyleConfig(restoredConfig);
  };

  const handleAnimate = async (imageUrl: string) => {
    setIsGenerating(true);
    try {
      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode: 'image_to_video',
          inputPrompt: prompt || 'animate this image', // Use current prompt or default
          sourceImageUrl: imageUrl,
          variations: 1,
          sessionId: selectedSessionId,
          engine: 'fal', // Force Fal for video
          falModel: 'fal-ai/wan-i2v', // Explicitly set model
        }),
      });
      loadGenerations();
    } catch (err) {
      console.error('Animation failed:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleUpscale = async (imageUrl: string, model: string) => {
    setIsGenerating(true);
    try {
      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode: 'upscale',
          inputPrompt: `Upscaled: ${prompt || 'upscale'}`,
          sourceImageUrl: imageUrl,
          variations: 1,
          sessionId: selectedSessionId,
          engine: 'fal',
          falModel: model, // Use the selected upscale model
        }),
      });
      loadGenerations();
    } catch (err) {
      console.error('Upscale failed:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  // Enhance Video (RIFE interpolation + MMAudio)
  const handleEnhanceVideo = async (
    generationId: string,
    mode: 'full' | 'audio-only' | 'smooth-only' = 'full'
  ) => {
    setIsGenerating(true);
    try {
      const result = await fetchAPI(`/projects/${projectId}/generations/${generationId}/enhance`, {
        method: 'POST',
        body: JSON.stringify({
          skipInterpolation: mode === 'audio-only',
          skipAudio: mode === 'smooth-only',
          targetFps: 24,
          audioPrompt: prompt || 'natural ambient sound matching the video content',
        }),
      });
      console.log('Enhancement result:', result);
      loadGenerations();
    } catch (err) {
      console.error('Video enhancement failed:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  // AI Reshoot via Qwen Image Edit 2511
  const handleReshoot = async (imageUrl: string, instruction: string) => {
    setIsGenerating(true);
    const toastId = toast.loading(`AI Reshoot: "${instruction}"...`);
    try {
      const result = await fetchAPI('/qwen/reshoot', {
        method: 'POST',
        body: JSON.stringify({
          imageUrl: imageUrl.startsWith('http') ? imageUrl : `http://localhost:3001${imageUrl}`,
          instruction,
          preserveBackground: true,
        }),
      });

      if (result.outputs && result.outputs.length > 0) {
        // Create new generation with the reshoot result
        await fetchAPI(`/projects/${projectId}/generations`, {
          method: 'POST',
          body: JSON.stringify({
            inputPrompt: `[AI Reshoot] ${instruction}`,
            falModel: 'fal-ai/qwen-image-edit-2511',
            aspectRatio,
            mode: 'image',
            status: 'succeeded',
            outputs: result.outputs,
          }),
        });
        toast.success('AI Reshoot complete!', { id: toastId });
        loadGenerations();
      } else {
        toast.error('Reshoot failed - no output', { id: toastId });
      }
    } catch (err) {
      console.error('AI Reshoot failed:', err);
      toast.error('AI Reshoot failed', { id: toastId });
    } finally {
      setIsGenerating(false);
    }
  };

  // Retake / Inpainting Logic
  const [isRetakeModalOpen, setIsRetakeModalOpen] = useState(false);
  const [retakeVideoUrl, setRetakeVideoUrl] = useState<string | null>(null);

  // Image Inpainting Logic
  const [isImageInpaintModalOpen, setIsImageInpaintModalOpen] = useState(false);
  const [inpaintImageUrl, setInpaintImageUrl] = useState<string | null>(null);
  const [inpaintAspectRatio, setInpaintAspectRatio] = useState<string | null>(null);

  const handleRetake = (videoUrl: string) => {
    setRetakeVideoUrl(videoUrl);
    setIsRetakeModalOpen(true);
  };

  const handleInpaint = (imageUrl: string, aspectRatio?: string) => {
    setInpaintImageUrl(imageUrl);
    if (aspectRatio) setInpaintAspectRatio(aspectRatio);
    setIsImageInpaintModalOpen(true);
  };

  const handleSaveInpaint = async (
    maskDataUrl: string,
    inpaintPrompt: string,
    negativePrompt: string,
    strength: number,
    seed?: number
  ) => {
    console.log('handleSaveInpaint called', {
      inpaintPrompt,
      strength,
      seed,
      hasMask: !!maskDataUrl,
    });
    if (!inpaintImageUrl) {
      console.error('No inpaintImageUrl found');
      return;
    }
    setIsGenerating(true);
    try {
      // Get original image dimensions to prevent resolution loss
      const img = new Image();
      img.src = inpaintImageUrl;
      await new Promise(resolve => {
        img.onload = resolve;
      });

      const payload = {
        mode: 'image_inpainting',
        // Prioritize inpaintPrompt. If user cleared it, send empty string so backend handles it.
        // Only fallback to "inpaint this area" if inpaintPrompt is undefined (initial load)
        inputPrompt: inpaintPrompt !== undefined ? inpaintPrompt : prompt || 'inpaint this area',
        negativePrompt: negativePrompt,
        sourceImageUrl: inpaintImageUrl,
        maskUrl: maskDataUrl,
        variations: 1,
        sessionId: selectedSessionId,
        engine: 'replicate', // Use Replicate for TRUE inpainting
        strength: strength || 0.99, // High strength for inpainting
        aspectRatio: inpaintAspectRatio || '16:9',
        width: img.naturalWidth, // Pass original dimensions
        height: img.naturalHeight,
        falModel: 'black-forest-labs/flux-fill-dev', // FLUX.1 Fill - professional-grade inpainting
        seed: seed, // Pass seed for reproducibility
      };
      console.log(
        'Sending inpainting request with dimensions:',
        payload.width,
        'x',
        payload.height
      );

      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify(payload),
      });
      loadGenerations();
    } catch (err) {
      console.error('Inpainting failed:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleSaveRetake = async (maskDataUrl: string) => {
    if (!retakeVideoUrl) return;
    setIsGenerating(true);
    try {
      await fetchAPI(`/projects/${projectId}/generations`, {
        method: 'POST',
        body: JSON.stringify({
          mode: 'video_inpainting', // This mode needs to be handled in backend
          inputPrompt: prompt || 'retake this shot',
          sourceVideoUrl: retakeVideoUrl,
          maskUrl: maskDataUrl, // Pass the mask data URL (backend handles upload)
          variations: 1,
          sessionId: selectedSessionId,
          engine: 'fal',
          falModel: 'fal-ai/wan-vace-14b/inpainting', // Force VACE model
        }),
      });
      loadGenerations();
    } catch (err) {
      console.error('Retake failed:', err);
    } finally {
      setIsGenerating(false);
    }
  };

  const handlePromptChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value;
    const position = e.target.selectionStart;
    setPrompt(value);
    setCursorPosition(position);

    // Check for @ trigger
    const textBeforeCursor = value.slice(0, position);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');

    if (lastAtSymbol !== -1) {
      const query = textBeforeCursor.slice(lastAtSymbol + 1);
      // Only show suggestions if there's no space after @ (unless it's the start of a name)
      if (!query.includes(' ')) {
        setSuggestionQuery(query);
        setShowSuggestions(true);
        return;
      }
    }
    setShowSuggestions(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    // Handle prompt weighting (Ctrl/Cmd + Arrow Up/Down)
    handleWeightingKeyDown(e);

    if (e.key === 'Enter' && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      handleGenerate();
    }
  };

  const selectSuggestion = (element: Element) => {
    const textBeforeCursor = prompt.slice(0, cursorPosition);
    const textAfterCursor = prompt.slice(cursorPosition);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');

    const newPrompt =
      textBeforeCursor.slice(0, lastAtSymbol) + `@${element.name} ` + textAfterCursor;
    setPrompt(newPrompt);
    setShowSuggestions(false);

    // Add to selected elements if not already there
    if (!selectedElementIds.includes(element.id)) {
      setSelectedElementIds(prev => [...prev, element.id]);
    }

    // Reset focus
    setTimeout(() => {
      if (textareaRef.current) {
        textareaRef.current.focus({ preventScroll: true });
        const newCursorPos = lastAtSymbol + element.name.length + 2; // +2 for @ and space
        textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
      }
    }, 0);
  };

  const toggleElement = (element: Element) => {
    if (selectedElementIds.includes(element.id)) {
      setSelectedElementIds(prev => prev.filter(id => id !== element.id));
    } else {
      setSelectedElementIds(prev => [...prev, element.id]);
      // Optionally add to prompt if not present
      if (!prompt.includes(`@${element.name}`)) {
        setPrompt(prev => (prev.trim() ? `${prev} @${element.name} ` : `@${element.name} `));
      }
    }
  };

  const filteredElements = elements.filter(
    el =>
      el.projectId === projectId && el.name.toLowerCase().includes(suggestionQuery.toLowerCase())
  );

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );

  const handleDragStart = (event: DragStartEvent) => {
    setActiveDragId(event.active.id as string);
  };

  const handleDragOver = (event: DragOverEvent) => {
    const { over } = event;
    // Check if we're over any Shot Navigator droppable
    if (over) {
      const overId = String(over.id);
      const isInShotNavigator =
        overId.startsWith('shot-') ||
        overId === 'drop-end' ||
        overId === 'drop-empty' ||
        overId === 'shot-navigator-container';

      setIsOverShotNavigator(isInShotNavigator);
    } else {
      setIsOverShotNavigator(false);
    }
  };

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;
    setActiveDragId(null);
    setDragOverIndex(null);
    setIsOverShotNavigator(false);

    console.log('Drag End:', { active, over });

    // Handle element drops (from Element strip)
    if (over && active.data.current?.type === 'element') {
      const { shotId, frameType } = over.data.current || {};
      if (shotId && frameType) {
        // Get image URL directly from the element data
        let imageUrl = active.data.current.imageUrl;

        // Ensure URL is absolute
        if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
          imageUrl = `http://localhost:3001${imageUrl}`;
        }

        if (imageUrl && shotNavigatorRef.current) {
          const element = active.data.current.element;
          console.log(
            `Dropping element "${element?.name}" into ${frameType} frame of shot ${shotId}:`,
            imageUrl
          );
          await shotNavigatorRef.current.handleFrameDrop(shotId, frameType, imageUrl);
        } else {
          console.warn('No image URL found for element:', active.data.current.element?.id);
        }
      }
      return;
    }

    // Handle generation drops
    if (over && active.data.current?.type === 'generation') {
      const generationId = active.id as string;
      const generation = generations.find(g => g.id === generationId);

      // Check if dropping on a frame slot (beginning/ending)
      const { shotId, frameType } = over.data.current || {};
      if (shotId && frameType && generation) {
        // Get the image URL from the generation
        // Priority: 1) image type, 2) video thumbnail, 3) any output url
        let imageUrl: string | null = null;
        const outputs = generation.outputs;
        if (Array.isArray(outputs) && outputs.length > 0) {
          // First, try to find an image output
          const imageOutput = outputs.find((o: any) => o.type === 'image');
          if (imageOutput?.url) {
            imageUrl = imageOutput.url;
          } else {
            // Fall back to video thumbnail or first output URL
            const firstOutput = outputs[0];
            imageUrl = firstOutput?.thumbnail_url || firstOutput?.url || null;
          }
        }

        // Ensure URL is absolute
        if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('data:')) {
          imageUrl = `http://localhost:3001${imageUrl}`;
        }

        if (imageUrl && shotNavigatorRef.current) {
          console.log(`Dropping generation into ${frameType} frame of shot ${shotId}:`, imageUrl);
          // Call the ShotNavigator's handleFrameDrop method via ref
          await shotNavigatorRef.current.handleFrameDrop(shotId, frameType, imageUrl);
        } else {
          console.warn('No image URL found for generation:', generation.id, outputs);
        }
        return;
      }

      // Legacy: dropping on scene/index for old shot navigator
      const { sceneId, index } = over.data.current || {};

      console.log('Dropping generation:', { generationId, sceneId, index });

      if (sceneId && typeof index === 'number') {
        // Optimistic Update
        if (generation) {
          setScenes(prevScenes => {
            return prevScenes.map(scene => {
              if (scene.id === sceneId) {
                const newShot = {
                  id: `temp-${Date.now()}`, // Temporary ID
                  sceneId,
                  generationId,
                  index,
                  generation: generation,
                  notes: '',
                };
                const updatedShots = [...((scene.shots as unknown[]) || [])];
                updatedShots.splice(index, 0, newShot);
                // Re-index subsequent shots for local state consistency
                for (let i = index + 1; i < updatedShots.length; i++) {
                  (updatedShots[i] as Record<string, unknown>).index = i;
                }
                return { ...scene, shots: updatedShots };
              }
              return scene;
            });
          });
        }

        try {
          await fetchAPI(`/projects/${projectId}/scenes/${sceneId}/shots`, {
            method: 'POST',
            body: JSON.stringify({
              generationId,
              index,
            }),
          });
          loadScenes(); // Reload to get real IDs and confirm state
        } catch (err) {
          console.error('Failed to add shot to scene', err);
          loadScenes(); // Revert on error
        }
      } else {
        console.warn('Missing sceneId or index for drop', { sceneId, index });
      }
    }
  };

  const handleRemoveShot = async (shotId: string) => {
    // Find the scene containing the shot
    const scene = scenes.find(s =>
      (s.shots as Array<{ id: string }>)?.some(shot => shot.id === shotId)
    );
    if (!scene) return;

    // Optimistic Update
    setScenes(prevScenes =>
      prevScenes.map(s => {
        if (s.id === scene.id) {
          return {
            ...s,
            shots: (s.shots as Array<{ id: string }>)?.filter(shot => shot.id !== shotId),
          };
        }
        return s;
      })
    );

    try {
      await fetchAPI(`/projects/${projectId}/scenes/${scene.id}/shots/${shotId}`, {
        method: 'DELETE',
      });
      loadScenes();
    } catch (err) {
      console.error('Failed to remove shot', err);
      loadScenes(); // Revert on error
    }
  };

  const toggleGenerationSelection = (id: string) => {
    setSelectedGenerationIds(prev =>
      prev.includes(id) ? prev.filter(gid => gid !== id) : [...prev, id]
    );
  };

  const selectAllGenerations = () => {
    // Select only the currently displayed (filtered) generations
    setSelectedGenerationIds(displayedGenerations.map(g => g.id));
  };

  const deselectAllGenerations = () => {
    setSelectedGenerationIds([]);
  };

  const handleBatchDelete = async () => {
    if (!confirm(`Are you sure you want to delete ${selectedGenerationIds.length} generations?`))
      return;

    try {
      await Promise.all(
        selectedGenerationIds.map(id =>
          fetchAPI(`/projects/${projectId}/generations/${id}`, { method: 'DELETE' })
        )
      );
      setSelectedGenerationIds([]);
      loadGenerations();
    } catch (err) {
      console.error('Batch delete failed', err);
    }
  };

  const handleBatchMove = async (targetSessionId: string) => {
    try {
      await Promise.all(
        selectedGenerationIds.map(id =>
          fetchAPI(`/projects/${projectId}/generations/${id}`, {
            method: 'PATCH',
            body: JSON.stringify({ sessionId: targetSessionId }),
          })
        )
      );
      setSelectedGenerationIds([]);
      loadGenerations();
    } catch (err) {
      console.error('Batch move failed', err);
    }
  };

  const handleBatchCopyLinks = () => {
    const selectedGens = generations.filter(g => selectedGenerationIds.includes(g.id));
    const links = selectedGens
      .map(g => {
        const url = g.outputs?.[0]?.url;
        if (!url) return null;
        return url.startsWith('http') ? url : `http://localhost:3001${url}`;
      })
      .filter(Boolean)
      .join('\n');

    if (links) {
      navigator.clipboard.writeText(links);
      // TODO: toast.success(`Copied ${selectedGens.length} links`);
      alert(`Copied ${selectedGenerationIds.length} links to clipboard!`);
    }
  };

  const handleBatchSave = () => {
    if (!selectedGenerationIds.length) return;
    setIsBatchSaveMode(true);
    setIsSaveElementModalOpen(true);
  };

  const processBatchSave = async (commonType: string) => {
    console.log(
      `Saving ${selectedGenerationIds.length} generations as elements of type: ${commonType}`
    );

    const promises = selectedGenerationIds.map(async id => {
      const gen = generations.find(g => g.id === id);
      if (!gen || !gen.outputs?.[0]) return;

      const output = gen.outputs[0];
      const isVideo = output.type === 'video';
      const url =
        output.url.startsWith('http') || output.url.startsWith('data:')
          ? output.url
          : `http://localhost:3001${output.url}`;

      try {
        // Use from-generation endpoint if valid URL, OR download/upload if needed.
        // Since these are local URLs (usually), from-generation relies on backend downloading.
        // But backend expects external URL or local path.
        // Let's stick to the FormData upload which was working for batch, but UPDATE THE TYPE.

        const res = await fetch(url);
        const blob = await res.blob();
        const file = new File([blob], `batch-save-${id}.${isVideo ? 'mp4' : 'png'}`, {
          type: blob.type,
        });

        const formData = new FormData();
        formData.append('file', file);
        formData.append('name', gen.inputPrompt?.slice(0, 50) || 'Saved Generation');
        // Use the CUSTOM TYPE selected by user
        formData.append('type', commonType);

        await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
          method: 'POST',
          body: formData,
        });
      } catch (err) {
        console.error(`Failed to save generation ${id}`, err);
      }
    });

    await Promise.all(promises);
    loadElements();
    deselectAllGenerations();
    setIsBatchSaveMode(false);
  };

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={pointerWithin}
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
    >
      <div className="flex h-screen flex-1 flex-col overflow-hidden">
        <div className="flex flex-1 overflow-hidden">
          {/* Main Content Area */}
          <div className="relative flex flex-1 flex-col overflow-hidden">
            {/* Shot Navigator */}
            <div className="relative z-20 flex-shrink-0 border-b border-white/10 bg-black/50 backdrop-blur-sm">
              <ShotNavigator
                ref={shotNavigatorRef}
                projectId={projectId}
                scenes={scenes}
                activeDragId={activeDragId}
                isOverNavigator={isOverShotNavigator}
                onDropIndexChange={setDragOverIndex}
                onRemove={handleRemoveShot}
              />
            </div>

            <div className="flex-1 overflow-y-auto p-8 pb-32">
              <header className="mb-8">
                {/* Full-width Visual Librarian title bar with integrated search */}
                <GenerationSearch
                  projectId={projectId}
                  onSearchResults={handleSearchResults}
                  onClearSearch={handleClearSearch}
                  onSelectAll={selectAllGenerations}
                  onSortFilterChange={setSortFilter}
                />
              </header>

              <div className="grid grid-cols-1 gap-8 lg:grid-cols-3">
                {/* Results Column */}
                <div className="lg:col-span-3">
                  {/* Dynamic heading based on search state */}
                  <h2 className="mb-4 flex items-center gap-2 text-xl font-bold">
                    {searchQuery ? (
                      <>
                        <Database className="h-5 w-5 text-purple-400" />
                        Results for "{searchQuery}"
                        <span className="text-sm font-normal text-white/50">
                          ({displayedGenerations.length} found)
                        </span>
                      </>
                    ) : (
                      'Recent Generations'
                    )}
                  </h2>
                  <div
                    className="grid gap-3"
                    style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(260px, 1fr))' }}
                  >
                    {displayedGenerations.map((gen, index) => (
                      <GenerationCard
                        key={gen.id || `gen-${index}`}
                        generation={gen}
                        elements={elements} // Pass elements map
                        onUpdate={handleUpdateGeneration}
                        onDelete={handleDeleteGeneration}
                        onIterate={handleIterateGeneration}
                        onUseSettings={handleUseSettings}
                        onAnimate={handleAnimate}
                        onUpscale={handleUpscale}
                        onEdit={() => {
                          setSelectedGeneration(gen);
                          setIsEditModalOpen(true);
                        }}
                        onRetake={handleRetake}
                        onInpaint={handleInpaint}
                        onEnhanceVideo={handleEnhanceVideo}
                        onReshoot={handleReshoot}
                        isSelected={selectedGenerationIds.includes(gen.id)}
                        onToggleSelection={() => toggleGenerationSelection(gen.id)}
                        onSaveAsElement={(url, type) => {
                          setSaveElementData({ url, type });
                          setIsBatchSaveMode(false);
                          setIsSaveElementModalOpen(true);
                        }}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {/* Batch Action Toolbar */}
            {selectedGenerationIds.length > 0 && (
              <div className="animate-in slide-in-from-bottom-4 fade-in absolute bottom-32 left-1/2 z-50 flex -translate-x-1/2 items-center gap-6 rounded-xl border border-white/10 bg-[#1a1a1a] px-6 py-3 shadow-2xl duration-200">
                <span className="text-sm font-medium text-white">
                  {selectedGenerationIds.length} selected
                </span>
                <div className="h-4 w-px bg-white/10" />
                <div className="flex items-center gap-2">
                  <select
                    onChange={e => {
                      if (e.target.value) handleBatchMove(e.target.value);
                    }}
                    className="rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm text-white focus:ring-1 focus:ring-blue-500 focus:outline-none"
                    defaultValue=""
                  >
                    <option value="" disabled>
                      Move to Session...
                    </option>
                    {sessions.map(s => (
                      <option key={s.id} value={s.id}>
                        {s.name}
                      </option>
                    ))}
                  </select>
                  <Tooltip content="Copy Links for JDownloader" side="top">
                    <button
                      onClick={handleBatchCopyLinks}
                      className="flex items-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 px-3 py-1.5 text-sm font-medium text-blue-400 transition-colors hover:bg-blue-500/20"
                    >
                      <Copy className="h-4 w-4" />
                      Copy Links
                    </button>
                  </Tooltip>
                  <Tooltip content="Save selected as elements" side="top">
                    <button
                      onClick={handleBatchSave}
                      className="flex items-center gap-2 rounded-lg border border-green-500/20 bg-green-500/10 px-3 py-1.5 text-sm font-medium text-green-400 transition-colors hover:bg-green-500/20"
                    >
                      <FilePlus className="h-4 w-4" />
                      Save Elements
                    </button>
                  </Tooltip>
                  <button
                    onClick={handleBatchDelete}
                    className="flex items-center gap-2 rounded-lg border border-red-500/20 bg-red-500/10 px-3 py-1.5 text-sm font-medium text-red-500 transition-colors hover:bg-red-500/20"
                  >
                    <Trash2 className="h-4 w-4" />
                    Delete
                  </button>
                  <div className="mx-1 h-4 w-px bg-white/10" />
                  <button
                    onClick={
                      selectedGenerationIds.length === generations.length
                        ? deselectAllGenerations
                        : selectAllGenerations
                    }
                    className="flex items-center gap-2 rounded-lg border border-white/10 bg-white/5 px-3 py-1.5 text-sm font-medium text-gray-300 transition-colors hover:bg-white/10"
                  >
                    <CheckSquare className="h-4 w-4" />
                    {selectedGenerationIds.length === generations.length
                      ? 'Deselect All'
                      : 'Select All'}
                  </button>
                  <button
                    onClick={deselectAllGenerations}
                    className="ml-1 p-1.5 text-gray-400 transition-colors hover:text-white"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              </div>
            )}
            {/* Fixed Bottom Bar */}
            <div className="pointer-events-none absolute right-0 bottom-0 left-0 z-50 bg-gradient-to-t from-black via-black/95 to-transparent px-8 pt-12 pb-8">
              <div className="pointer-events-auto mx-auto w-full">
                <div className="relative flex flex-col gap-2 rounded-xl border border-white/10 bg-[#1a1a1a] p-2 shadow-2xl">
                  {/* @ Reference Suggestions Dropdown (Horizontal) - Moved here to span full width */}
                  {showSuggestions && filteredElements.length > 0 && (
                    <div className="animate-in slide-in-from-bottom-2 fade-in absolute right-0 bottom-full left-0 z-50 mb-2 rounded-xl border border-white/20 bg-[#1a1a1a] shadow-2xl duration-200">
                      <div className="flex items-center justify-between border-b border-white/10 bg-white/5 px-3 py-2">
                        <div className="flex items-center gap-2">
                          <Users className="h-3 w-3 text-blue-400" />
                          <span className="text-xs font-medium tracking-wider text-gray-300 uppercase">
                            Filtering: "{suggestionQuery}"
                          </span>
                        </div>
                        <span className="text-[10px] text-gray-500">
                          {filteredElements.length} match{filteredElements.length !== 1 ? 'es' : ''}
                        </span>
                      </div>
                      <div className="scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent flex gap-2 overflow-x-auto p-2">
                        {filteredElements.map((el, idx) => (
                          <Tooltip key={el.id || `suggestion-${idx}`} content={el.name} side="top">
                            <button
                              onMouseDown={e => {
                                e.preventDefault(); // Prevent textarea blur
                                selectSuggestion(el);
                              }}
                              className="group relative h-16 w-16 flex-shrink-0 overflow-hidden rounded-lg border border-white/10 transition-all hover:scale-105 hover:border-blue-500"
                            >
                              {el.url ? (
                                el.type === 'video' ? (
                                  <video src={el.url} className="h-full w-full object-cover" muted />
                                ) : (
                                  <img
                                    src={el.url}
                                    alt={el.name}
                                    className="h-full w-full object-cover"
                                  />
                                )
                              ) : (
                                <div className="flex h-full w-full items-center justify-center bg-white/5">
                                  <Users className="h-6 w-6 text-gray-600" />
                                </div>
                              )}
                              <div className="absolute inset-0 flex items-end bg-gradient-to-t from-black/80 to-transparent p-1 opacity-0 transition-opacity group-hover:opacity-100">
                                <span className="w-full truncate text-center text-[9px] leading-tight text-white">
                                  {el.name}
                                </span>
                              </div>
                            </button>
                          </Tooltip>
                        ))}
                      </div>
                    </div>
                  )}
                  {/* Elements Drawer */}
                  {isElementPickerOpen && (
                    <div className="animate-in slide-in-from-bottom-2 border-b border-white/5 px-2 pt-2 pb-1 duration-200">
                      <div className="mb-2 flex items-center justify-between">
                        <span className="text-xs font-medium tracking-wider text-gray-400 uppercase">
                          Reference Elements
                        </span>
                        <button
                          onClick={() => setIsElementPickerOpen(false)}
                          className="text-gray-500 hover:text-white"
                        >
                          <ChevronDown className="h-3 w-3" />
                        </button>
                      </div>
                      {elements.length === 0 ? (
                        <p className="py-2 text-xs text-gray-500 italic">
                          No elements uploaded yet.
                        </p>
                      ) : (
                        <div className="flex gap-2 overflow-x-auto pb-2">
                          {elements
                            .filter(el => el.projectId === projectId)
                            .map((el, index) => (
                              <DraggableElementThumbnail
                                key={el.id || `el-${index}`}
                                element={el}
                                isSelected={selectedElementIds.includes(el.id)}
                                onToggle={() => toggleElement(el)}
                              />
                            ))}
                        </div>
                      )}
                    </div>
                  )}

                  {/* Unified Prompt Bar - Director's Viewfinder */}
                  <div className="flex items-end gap-2">
                    <div className="group relative min-w-0 flex-1 rounded-xl bg-white/5 transition-all">
                      {/* Focus Brackets - Director's Viewfinder Corners */}
                      <div
                        className={clsx(
                          'pointer-events-none absolute top-0 left-0 h-3 w-3 border-t-2 border-l-2 transition-all duration-300',
                          isFocused ? 'h-4 w-4 border-purple-500/70' : 'border-zinc-600/50'
                        )}
                      />
                      <div
                        className={clsx(
                          'pointer-events-none absolute top-0 right-0 h-3 w-3 border-t-2 border-r-2 transition-all duration-300',
                          isFocused ? 'h-4 w-4 border-purple-500/70' : 'border-zinc-600/50'
                        )}
                      />
                      <div
                        className={clsx(
                          'pointer-events-none absolute bottom-0 left-0 h-3 w-3 border-b-2 border-l-2 transition-all duration-300',
                          isFocused ? 'h-4 w-4 border-purple-500/70' : 'border-zinc-600/50'
                        )}
                      />
                      <div
                        className={clsx(
                          'pointer-events-none absolute right-0 bottom-0 h-3 w-3 border-r-2 border-b-2 transition-all duration-300',
                          isFocused ? 'h-4 w-4 border-purple-500/70' : 'border-zinc-600/50'
                        )}
                      />

                      {/* Ghost Frame - Aspect Ratio Preview */}
                      <div className="pointer-events-none absolute inset-0 flex items-center justify-center overflow-hidden rounded-xl">
                        <div
                          className={clsx(
                            'rounded-sm border bg-white/[0.015] transition-all duration-500',
                            isFocused ? 'opacity-100' : 'opacity-40',
                            // Dynamic aspect ratio classes
                            aspectRatio === '16:9' && 'aspect-video w-full max-w-[90%]',
                            aspectRatio === '9:16' && 'aspect-[9/16] h-[85%]',
                            aspectRatio === '1:1' && 'aspect-square h-[85%]',
                            aspectRatio === '4:3' && 'aspect-[4/3] w-full max-w-[85%]',
                            aspectRatio === '3:4' && 'aspect-[3/4] h-[85%]',
                            aspectRatio === '21:9' && 'aspect-[21/9] w-full max-w-[95%]',
                            aspectRatio === '2.35:1' && 'aspect-[2.35/1] w-full max-w-[95%]',
                            // Prompt length feedback - changes border color
                            prompt.length > 500
                              ? 'border-amber-500/30'
                              : prompt.length > 300
                                ? 'border-yellow-500/20'
                                : 'border-white/10'
                          )}
                        />
                      </div>

                      <textarea
                        ref={textareaRef}
                        value={prompt}
                        onChange={handlePromptChange}
                        onKeyDown={handleKeyDown}
                        onFocus={() => setIsFocused(true)}
                        onBlur={() => setIsFocused(false)}
                        placeholder="Describe your shot... (Use @ to reference elements)"
                        className={clsx(
                          'w-full resize-none rounded-xl border-none bg-transparent px-4 py-3 text-white placeholder-gray-500 transition-all duration-200 ease-in-out focus:ring-0',
                          isFocused ? 'h-32' : 'h-10'
                        )}
                        rows={1}
                      />

                      {/* Selected Elements Display */}
                      {(selectedElementIds.length > 0 || audioFile) && (
                        <div className="scrollbar-none flex gap-2 overflow-x-auto px-4 pb-2">
                          {/* Audio Pill */}
                          {audioFile && (
                            <div className="animate-in fade-in zoom-in flex flex-shrink-0 items-center gap-1.5 rounded-full border border-purple-500/30 bg-purple-500/20 px-2 py-1 text-xs text-purple-300 duration-200">
                              <Music className="h-3 w-3" />
                              <span className="max-w-[100px] truncate">{audioFile.name}</span>
                              <button
                                onClick={() => setAudioFile(null)}
                                className="transition-colors hover:text-white"
                              >
                                <X className="h-3 w-3" />
                              </button>
                            </div>
                          )}

                          {elements
                            .filter(e => selectedElementIds.includes(e.id))
                            .map((el, idx) => (
                              <div
                                key={el.id || `selected-${idx}`}
                                className="flex shrink-0 items-center gap-1.5 rounded-full border border-blue-500/30 bg-blue-500/20 px-2 py-1 text-xs text-blue-300"
                              >
                                <span className="max-w-[100px] truncate">@{el.name}</span>
                                <button
                                  onClick={() => toggleElement(el)}
                                  className="hover:text-white"
                                >
                                  X
                                </button>
                              </div>
                            ))}
                        </div>
                      )}
                    </div>

                    <div className="relative flex h-10 shrink-0 items-center gap-2">
                      {/* Scrollable Tools Container - takes remaining space after pinned right section */}
                      <div className="scrollbar-hide flex min-w-0 flex-1 items-center gap-1.5 overflow-x-auto pr-2">
                        {/* 1. Smart Prompt (Wand) */}
                        <Tooltip content="Smart Prompt Builder" side="top">
                          <button
                            onClick={() => setIsPromptBuilderOpen(true)}
                            className="flex h-10 shrink-0 items-center gap-1.5 rounded-xl border border-purple-500/20 bg-purple-500/10 px-2.5 text-purple-400 transition-all hover:scale-105 hover:bg-purple-500/20"
                          >
                            <Wand2 className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">Wand</span>
                          </button>
                        </Tooltip>

                        {/* 2. Tag Selector */}
                        <Tooltip content="Add Tags to Prompt" side="top">
                          <button
                            onClick={() => setIsTagSelectorOpen(true)}
                            className="flex h-10 shrink-0 items-center gap-1.5 rounded-xl border border-amber-500/20 bg-amber-500/10 px-2.5 text-amber-400 transition-all hover:scale-105 hover:bg-amber-500/20"
                          >
                            <TagIcon className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">Tags</span>
                          </button>
                        </Tooltip>

                        {/* 2a. Motion Scale (Video Models Only) - Visible early for video workflows */}
                        {mode === 'video' && (
                          <CompactMotionSlider
                            value={motionScale}
                            onChange={setMotionScale}
                            engineType={
                              engineConfig.model.includes('kling')
                                ? 'kling'
                                : engineConfig.model.includes('veo')
                                  ? 'veo'
                                  : engineConfig.model.includes('wan')
                                    ? 'wan'
                                    : engineConfig.model.includes('luma')
                                      ? 'luma'
                                      : engineConfig.model.includes('ltx')
                                        ? 'ltx'
                                        : 'other'
                            }
                          />
                        )}

                        {/* 2b. Prompt Variables */}
                        <Tooltip content="Prompt Variables ($MainLook syntax)" side="top">
                          <button
                            onClick={() => setIsVariablesPanelOpen(true)}
                            className={clsx(
                              'flex h-10 shrink-0 items-center gap-1.5 rounded-xl border px-2.5 transition-all hover:scale-105',
                              hasMounted && promptVariables.length > 0
                                ? 'border-cyan-500/20 bg-cyan-500/10 text-cyan-400 hover:bg-cyan-500/20'
                                : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                            )}
                          >
                            <Code2 className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">${hasMounted ? promptVariables.length : 0}</span>
                          </button>
                        </Tooltip>

                        {/* 2c. Lens Kit - Focal Length & Anamorphic */}
                        <LensKitSelector
                          selectedLens={selectedLens}
                          selectedEffects={selectedLensEffects}
                          isAnamorphic={isAnamorphic}
                          onLensChange={setSelectedLens}
                          onEffectsChange={setSelectedLensEffects}
                          onAnamorphicChange={value => {
                            setIsAnamorphic(value);
                            // Auto-lock to 21:9 aspect ratio when anamorphic is enabled
                            if (value) {
                              setAspectRatio('21:9');
                            }
                          }}
                          onAspectRatioLock={ratio => setAspectRatio(ratio)}
                        />

                        {/* 2d. Prop Bin - Object Consistency */}
                        <Tooltip content="Prop Bin (#PropName syntax for object consistency)" side="top">
                          <button
                            onClick={() => setIsPropBinOpen(true)}
                            className={clsx(
                              'flex h-10 shrink-0 items-center gap-1.5 rounded-xl border px-2.5 transition-all hover:scale-105',
                              hasMounted && propBinItems.length > 0
                                ? 'border-amber-500/20 bg-amber-500/10 text-amber-400 hover:bg-amber-500/20'
                                : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                            )}
                          >
                            <Package className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">#{hasMounted ? propBinItems.length : 0}</span>
                          </button>
                        </Tooltip>

                        {/* 2e. Prompt Tree - Version Control */}
                        <Tooltip content="Prompt Tree (Version Control for Prompts)" side="top">
                          <button
                            onClick={() => setIsPromptTreeOpen(true)}
                            className={clsx(
                              'flex h-10 shrink-0 items-center gap-1.5 rounded-xl border px-2.5 transition-all hover:scale-105',
                              hasMounted && promptTreeNodes.length > 0
                                ? 'border-purple-500/20 bg-purple-500/10 text-purple-400 hover:bg-purple-500/20'
                                : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                            )}
                          >
                            <GitBranch className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">{hasMounted ? promptTreeNodes.length : 0}</span>
                          </button>
                        </Tooltip>

                        {/* 3. Style & Aspect Ratio - with Dynamic Icon */}
                        <button
                          onClick={() => setIsStyleModalOpen(true)}
                          className="group flex h-10 shrink-0 items-center gap-2 rounded-xl border border-white/5 bg-black/20 px-3 text-gray-400 transition-all hover:bg-white/5 hover:text-white"
                        >
                          <SlidersHorizontal className="h-4 w-4" />
                          <span className="whitespace-nowrap text-xs font-medium">Style</span>
                          <div className="mx-1 h-4 w-px bg-white/10" />
                          {/* Dynamic Ratio Icon - morphs to show actual aspect ratio */}
                          <DynamicRatioIcon
                            ratio={aspectRatio}
                            size="sm"
                            className="text-gray-400 transition-colors group-hover:text-white"
                          />
                          <span className="whitespace-nowrap font-mono text-[10px] text-gray-500">{aspectRatio}</span>
                        </button>

                        {/* Virtual Gaffer: 3-Point Lighting Designer */}
                        <Tooltip
                          content={
                            lightingEnabled
                              ? getLightingDescription()
                              : 'Virtual Gaffer - Lighting Designer'
                          }
                          side="top"
                        >
                          <button
                            onClick={() => setIsLightingStageOpen(true)}
                            className={clsx(
                              'flex h-10 shrink-0 items-center gap-2 rounded-xl border px-3 transition-all',
                              lightingEnabled && lights.length > 0
                                ? 'border-amber-500/30 bg-amber-500/20 text-amber-300'
                                : 'border-white/5 bg-black/20 text-gray-400 hover:bg-white/5 hover:text-white'
                            )}
                          >
                            <Lightbulb className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">Light</span>
                            {lightingEnabled && lights.length > 0 && (
                              <span className="ml-1 whitespace-nowrap text-[10px] text-amber-400">{lights.length}</span>
                            )}
                          </button>
                        </Tooltip>

                        {/* Acoustic Studio Button */}
                        <Tooltip content="Acoustic Studio - Perspective-Matched Audio" side="top">
                          <button
                            onClick={() => setIsAcousticStudioOpen(true)}
                            className={clsx(
                              'flex h-10 shrink-0 items-center gap-1.5 rounded-xl border px-2.5 transition-all hover:scale-105',
                              isAcousticStudioOpen
                                ? 'border-cyan-500/30 bg-cyan-500/20 text-cyan-300'
                                : 'border-white/10 bg-white/5 text-gray-400 hover:bg-white/10'
                            )}
                          >
                            <Music className="h-4 w-4" />
                            <span className="whitespace-nowrap text-xs font-medium">Sound</span>
                          </button>
                        </Tooltip>

                        {/* 3. Reference Elements (Users) */}
                        <button
                          onClick={() => setIsElementPickerOpen(!isElementPickerOpen)}
                          className={clsx(
                            'relative flex h-10 shrink-0 items-center gap-1.5 rounded-xl border px-2.5 transition-all',
                            isElementPickerOpen
                              ? 'border-blue-500/50 bg-blue-500/20 text-blue-300'
                              : 'border-white/5 bg-black/20 text-gray-400 hover:bg-white/5 hover:text-white'
                          )}
                        >
                          <Users className="h-4 w-4" />
                          <span className="whitespace-nowrap text-xs font-medium">Refs</span>
                          {selectedElementIds.length > 0 && (
                            <span className="flex h-4 w-4 items-center justify-center rounded-full bg-blue-600 text-[10px] text-white">
                              {selectedElementIds.length}
                            </span>
                          )}
                        </button>

                      </div>

                      {/* Pinned Right Section - Model Selector & Generate Button */}
                      <div className="flex shrink-0 items-center gap-2 border-l border-white/10 pl-2">
                        {/* 6. Model Selector Pill */}
                        <div className="min-w-[120px] max-w-[180px]">
                          <EngineSelectorV2
                            selectedProvider={engineConfig.provider}
                            selectedModel={engineConfig.model}
                            onSelect={(provider, model) => setEngineConfig({ provider, model })}
                            mode={mode}
                            variant="compact"
                            quantity={variations}
                            onQuantityChange={setVariations}
                            duration={duration}
                            onDurationChange={setDuration}
                            audioFile={audioFile}
                            onAudioChange={setAudioFile}
                          />
                        </div>

                      {/* Pipeline Node Workflow (Vidu Q2 Only) */}
                      {engineConfig.model === 'fal-ai/vidu/q2/reference-to-video' && (
                        <div className="absolute right-0 bottom-full z-50 mb-2 flex w-72 flex-col gap-3 rounded-xl border border-white/10 bg-[#1a1a1a] p-3 shadow-xl">
                          <div className="flex items-center justify-between text-xs font-semibold text-gray-300">
                            <div className="flex items-center gap-2">
                              <Layers className="h-4 w-4 text-blue-400" />
                              <span>Generation Pipeline</span>
                            </div>
                          </div>

                          {/* Base Stage (Implicit Vidu) */}
                          <div className="flex items-center gap-2 rounded-lg border border-blue-500/20 bg-blue-500/10 p-2 text-xs text-blue-200">
                            <span className="font-bold">1. Base:</span> Vidu Q2 (Reference-to-Video)
                          </div>

                          {/* Dynamic Stages */}
                          {pipelineStages.map((stage, idx) => (
                            <div
                              key={stage.id}
                              className="animate-in slide-in-from-left-2 fade-in relative rounded-lg border border-white/10 bg-white/5 p-3"
                            >
                              <div className="absolute top-2 right-2">
                                <button
                                  onClick={() =>
                                    setPipelineStages(prev => prev.filter(s => s.id !== stage.id))
                                  }
                                  className="text-gray-500 hover:text-red-400"
                                >
                                  <Trash2 className="h-3 w-3" />
                                </button>
                              </div>
                              <div className="mb-2 text-xs font-bold text-gray-300">
                                {idx + 2}.{' '}
                                {stage.type === 'motion'
                                  ? 'Motion (One-To-All)'
                                  : 'Lip Sync (SyncLabs)'}
                              </div>

                              {stage.type === 'motion' && (
                                <div className="flex flex-col gap-2">
                                  <label className="text-[10px] text-gray-400 uppercase">
                                    Driving Video
                                  </label>
                                  <div className="flex items-center gap-2">
                                    <button
                                      onClick={() =>
                                        document.getElementById(`stage-video-${stage.id}`)?.click()
                                      }
                                      className={clsx(
                                        'flex w-full items-center justify-center gap-2 rounded-lg border border-dashed px-3 py-2 transition-all',
                                        stage.videoFile
                                          ? 'border-green-500/50 bg-green-500/10 text-green-400'
                                          : 'border-white/20 bg-white/5 text-gray-400 hover:border-white/40'
                                      )}
                                    >
                                      <Video className="h-3 w-3" />
                                      <span className="max-w-[150px] truncate text-xs">
                                        {stage.videoFile ? stage.videoFile.name : 'Upload Video'}
                                      </span>
                                    </button>
                                    <input
                                      id={`stage-video-${stage.id}`}
                                      type="file"
                                      accept="video/mp4,video/quicktime,video/webm"
                                      className="hidden"
                                      onChange={e => {
                                        if (e.target.files?.[0]) {
                                          const file = e.target.files[0];
                                          setPipelineStages(prev =>
                                            prev.map(s =>
                                              s.id === stage.id ? { ...s, videoFile: file } : s
                                            )
                                          );
                                        }
                                      }}
                                    />
                                  </div>
                                </div>
                              )}

                              {stage.type === 'lipsync' && (
                                <div className="flex flex-col gap-2">
                                  <label className="text-[10px] text-gray-400 uppercase">
                                    Driving Audio or Video
                                  </label>
                                  <div className="flex items-center gap-2">
                                    <button
                                      onClick={() =>
                                        document.getElementById(`stage-audio-${stage.id}`)?.click()
                                      }
                                      className={clsx(
                                        'flex w-full items-center justify-center gap-2 rounded-lg border border-dashed px-3 py-2 transition-all',
                                        stage.audioFile
                                          ? 'border-purple-500/50 bg-purple-500/10 text-purple-400'
                                          : 'border-white/20 bg-white/5 text-gray-400 hover:border-white/40'
                                      )}
                                    >
                                      <Music className="h-3 w-3" />
                                      <span className="max-w-[150px] truncate text-xs">
                                        {stage.audioFile
                                          ? stage.audioFile.name
                                          : 'Upload Audio/Video'}
                                      </span>
                                    </button>
                                    <input
                                      id={`stage-audio-${stage.id}`}
                                      type="file"
                                      accept="audio/*,video/*"
                                      className="hidden"
                                      onChange={e => {
                                        if (e.target.files?.[0]) {
                                          const file = e.target.files[0];
                                          setPipelineStages(prev =>
                                            prev.map(s =>
                                              s.id === stage.id ? { ...s, audioFile: file } : s
                                            )
                                          );
                                        }
                                      }}
                                    />
                                  </div>
                                </div>
                              )}

                              <div className="absolute top-1/2 -left-1.5 -mt-1 h-px w-3 bg-white/20" />
                            </div>
                          ))}

                          <div className="mt-2 flex gap-2">
                            <Tooltip content="Add One-To-All Motion Stage" side="top">
                              <button
                                onClick={() =>
                                  setPipelineStages(prev => [
                                    ...prev,
                                    { id: Date.now().toString(), type: 'motion' },
                                  ])
                                }
                                className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-white/10 bg-white/5 py-1.5 text-xs text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                              >
                                <Video className="h-3 w-3" /> + Motion
                              </button>
                            </Tooltip>
                            <Tooltip content="Add SyncLabs Lip Sync Stage" side="top">
                              <button
                                onClick={() =>
                                  setPipelineStages(prev => [
                                    ...prev,
                                    { id: Date.now().toString(), type: 'lipsync' },
                                  ])
                                }
                                className="flex flex-1 items-center justify-center gap-1 rounded-lg border border-white/10 bg-white/5 py-1.5 text-xs text-gray-400 transition-colors hover:bg-white/10 hover:text-white"
                              >
                                <Music className="h-3 w-3" /> + Lip Sync
                              </button>
                            </Tooltip>
                          </div>
                        </div>
                      )}

                        {/* 5. Generate Button */}
                        <button
                          onClick={handleGenerate}
                          disabled={isGenerating || !prompt?.trim()}
                          className="flex h-10 shrink-0 items-center gap-2 rounded-xl bg-blue-600 px-3 font-medium text-white shadow-lg shadow-blue-500/20 transition-all hover:scale-105 hover:bg-blue-500 active:scale-95 disabled:opacity-50 disabled:grayscale"
                        >
                          {isGenerating ? (
                            <>
                              <Loader2 className="h-4 w-4 animate-spin" />
                              <span className="hidden lg:inline">Generating...</span>
                            </>
                          ) : (
                            <>
                              <Sparkles className="h-4 w-4" />
                              <span className="hidden lg:inline">Generate</span>
                            </>
                          )}
                        </button>
                      </div>
                    </div>
                  </div>

                  {/* Prompt Builder Modal */}
                  {isPromptBuilderOpen && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-4 backdrop-blur-sm">
                      <div className="relative max-h-[90vh] w-full max-w-2xl overflow-y-auto rounded-2xl border border-white/10 bg-[#1a1a1a] shadow-2xl">
                        <button
                          onClick={() => setIsPromptBuilderOpen(false)}
                          className="absolute top-4 right-4 z-10 text-gray-400 hover:text-white"
                        >
                          <X className="h-5 w-5" />
                        </button>

                        <PromptBuilder
                          initialPrompt={prompt}
                          modelId={engineConfig.model}
                          generationType={mode}
                          elements={elements.map(e => ({
                            id: e.id,
                            name: e.name,
                            type: (e.type === 'image' ? 'style' : e.type) as
                              | 'character'
                              | 'prop'
                              | 'location'
                              | 'style',
                            description: e.name,
                            imageUrl: resolveFileUrl(e.url || e.fileUrl || e.thumbnail),
                            consistencyWeight: elementStrengths[e.id] || 0.8,
                          }))}
                          selectedElementIds={selectedElementIds}
                          initialLoRAs={styleConfig?.loras?.map(l => ({
                            id: l.id,
                            name: l.name,
                            triggerWords: l.triggerWords || (l.triggerWord ? [l.triggerWord] : []),
                            type: 'style' as const,
                            baseModel: l.baseModel || 'Unknown',
                            recommendedStrength: l.strength || 0.8,
                            useCount: 0,
                          }))}
                          initialImages={
                            styleConfig?.referenceImage &&
                            typeof styleConfig.referenceImage === 'string'
                              ? [resolveFileUrl(styleConfig.referenceImage)]
                              : []
                          }
                          props={propBinItems
                            .filter(p => prompt.toLowerCase().includes(`#${p.name.toLowerCase()}`))
                            .map(p => ({
                              id: p.id,
                              name: p.name,
                              description: p.description,
                              referenceImageUrl: p.referenceImageUrl ? resolveFileUrl(p.referenceImageUrl) : undefined,
                              category: p.category,
                            }))}
                          lightingPrompt={lightingEnabled ? getLightingModifier() : ''}
                          onPromptChange={(newPrompt, _negativePrompt) => {
                            setPrompt(newPrompt);
                            // Negative prompt handling can be added here
                          }}
                          onRecommendationsChange={recs => {
                            if (recs?.steps) setSteps(recs.steps);
                            if (recs?.cfgScale) setGuidanceScale(recs.cfgScale);
                          }}
                          onScriptParsed={(parsed: Record<string, unknown>) => {
                            // 1. Set Visual Prompt
                            if (typeof parsed.visual === 'string') setPrompt(parsed.visual);

                            // 2. Configure Pipeline Stages
                            const newStages: PipelineStage[] = [];

                            // Motion Stage
                            if (parsed.motion && typeof parsed.motion === 'string') {
                              newStages.push({
                                id: crypto.randomUUID(),
                                type: 'motion',
                                model: 'fal-ai/one-to-all-animation/14b',
                                prompt: parsed.motion,
                                videoUrl: undefined,
                              });
                            }

                            // Lip Sync Stage (Dialogue)
                            if (parsed.audio && typeof parsed.audio === 'string') {
                              newStages.push({
                                id: crypto.randomUUID(),
                                type: 'lipsync',
                                model: 'fal-ai/sync-lips',
                                prompt: parsed.audio, // Storing dialogue as prompt reference
                                audioUrl: undefined, // User must provide audio
                              });
                            }

                            setPipelineStages(newStages);
                            setIsPromptBuilderOpen(false);

                            // Optional: Auto-switch engine if needed, but respecting user choice is safer.
                            // Notify user? (Toast not available, relying on UI update)
                          }}
                          onClose={() => setIsPromptBuilderOpen(false)}
                        />
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Modals and Overlays - Moved outside pointer-events-none container */}
      {/* Small thumbnail follows cursor while dragging - maintains aspect ratio, cursor centered */}
      <DragOverlay dropAnimation={null} modifiers={[snapCenterToCursor]}>
        {activeDragId
          ? (() => {
              // Check if dragging an element (starts with "element-")
              const isElement =
                typeof activeDragId === 'string' && activeDragId.startsWith('element-');

              if (isElement) {
                // Element drag overlay
                const elementId = activeDragId.replace('element-', '');
                const element = elements.find(e => e.id === elementId);
                const rawUrl = element?.url || element?.fileUrl || element?.thumbnail;
                const mediaUrl = rawUrl
                  ? rawUrl.startsWith('http') || rawUrl.startsWith('data:')
                    ? rawUrl
                    : `http://localhost:3001${rawUrl}`
                  : undefined;

                // Elements are typically square, use 64x64
                const size = 64;
                return (
                  <div
                    className="pointer-events-none overflow-hidden rounded-lg border-2 border-purple-500 bg-black shadow-xl"
                    style={{ width: size, height: size }}
                  >
                    {mediaUrl ? (
                      <img src={mediaUrl} className="h-full w-full object-cover" alt="" />
                    ) : (
                      <div className="h-full w-full bg-white/10" />
                    )}
                  </div>
                );
              }

              // Generation drag overlay
              const generation = generations.find(g => g.id === activeDragId);
              const output = generation?.outputs?.[0];
              const rawUrl = output?.thumbnail_url || output?.url;
              const mediaUrl = rawUrl
                ? rawUrl.startsWith('http') || rawUrl.startsWith('data:')
                  ? rawUrl
                  : `http://localhost:3001${rawUrl}`
                : undefined;

              // Calculate aspect ratio from generation or use 16:9 default
              // Thumbnail max size: 80px on longest edge
              const maxSize = 80;
              const genAspect = generation?.aspectRatio || aspectRatio || '16:9';
              const [w, h] = genAspect.split(':').map(Number);
              const isLandscape = w >= h;
              const thumbWidth = isLandscape ? maxSize : Math.round(maxSize * (w / h));
              const thumbHeight = isLandscape ? Math.round(maxSize * (h / w)) : maxSize;

              return (
                <div
                  className="pointer-events-none overflow-hidden rounded-lg border-2 border-blue-500 bg-black shadow-xl"
                  style={{ width: thumbWidth, height: thumbHeight }}
                >
                  {mediaUrl ? (
                    <img src={mediaUrl} className="h-full w-full object-cover" alt="" />
                  ) : (
                    <div className="h-full w-full bg-white/10" />
                  )}
                </div>
              );
            })()
          : null}
      </DragOverlay>

      <StyleSelectorModal
        isOpen={isStyleModalOpen}
        onClose={() => setIsStyleModalOpen(false)}
        onApply={handleStyleApply}
        initialAspectRatio={aspectRatio}
        projectId={projectId}
        config={styleConfig || undefined} // Pass current config to sync modal state
        currentModelId={engineConfig.model} // For LoRA base model auto-filtering
        isAnamorphicLocked={isAnamorphic} // Lock to 21:9 when anamorphic glass is enabled
      />

      {/* Virtual Gaffer: 3-Point Lighting Designer Stage */}
      <LightingStage isOpen={isLightingStageOpen} onClose={() => setIsLightingStageOpen(false)} />

      {/* Acoustic Studio: Perspective-Matched Audio */}
      <AcousticStudioPanel
        focalLength={selectedLens?.focalMm || 35}
        isOpen={isAcousticStudioOpen}
        onClose={() => setIsAcousticStudioOpen(false)}
      />

      <EditElementModal
        element={
          selectedGeneration
            ? {
                id: selectedGeneration.id,
                projectId: projectId,
                name: selectedGeneration.name || selectedGeneration.inputPrompt,
                type: selectedGeneration.outputs?.[0]?.type || 'image',
                url: selectedGeneration.outputs?.[0]?.url || '',
                tags: selectedGeneration.tags || [],
                session: selectedGeneration.session,
                metadata: {},
              }
            : null
        }
        isOpen={isEditModalOpen}
        onClose={() => {
          setIsEditModalOpen(false);
          setSelectedGeneration(null);
        }}
        onSave={(id, updates) => {
          // Map updates back to generation fields
          const genUpdates: Record<string, unknown> = {};
          if (updates.name) genUpdates.name = updates.name;
          if (updates.tags) genUpdates.tags = updates.tags;
          if (updates.sessionId !== undefined) genUpdates.sessionId = updates.sessionId;
          handleUpdateGeneration(id, genUpdates);
        }}
        sessions={sessions}
      />
      <ElementReferencePicker
        projectId={projectId}
        isOpen={isElementPickerOpen}
        onClose={() => setIsElementPickerOpen(false)}
        selectedElements={selectedElementIds}
        onSelectionChange={setSelectedElementIds}
        creativity={referenceCreativity}
        onCreativityChange={setReferenceCreativity}
        elementStrengths={elementStrengths}
        onStrengthChange={(id, val) => setElementStrengths(prev => ({ ...prev, [id]: val }))}
      />

      <VideoMaskEditor
        isOpen={isRetakeModalOpen}
        onClose={() => setIsRetakeModalOpen(false)}
        videoUrl={retakeVideoUrl || ''}
        onSave={handleSaveRetake}
      />

      <ImageMaskEditor
        isOpen={isImageInpaintModalOpen}
        onClose={() => setIsImageInpaintModalOpen(false)}
        imageUrl={inpaintImageUrl || ''}
        onSave={handleSaveInpaint}
        initialPrompt={prompt}
      />

      <AudioInputModal
        isOpen={isAudioModalOpen}
        onClose={() => setIsAudioModalOpen(false)}
        currentFile={audioFile}
        onAudioChange={async file => {
          setAudioFile(file);
          if (file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('name', file.name);
            formData.append('type', 'audio');

            try {
              const res = await fetch(`http://localhost:3001/api/projects/${projectId}/elements`, {
                method: 'POST',
                body: formData,
              });
              if (!res.ok) throw new Error('Upload failed');
              const data = await res.json();
              // elementController returns { url: ... } which is the full URL or relative path
              // If it returns relative path, we prepend localhost.
              // But elementController.ts:86 calls parseElementJsonFields which handles full URL.
              // Let's assume data.url is correct.
              setAudioUrl(data.url);
              console.log('Audio uploaded, url:', data.url);
            } catch (e) {
              console.error('Audio upload failed', e);
            }
          } else {
            setAudioUrl(null);
          }
        }}
      />

      <SaveElementModal
        isOpen={isSaveElementModalOpen}
        isBatch={isBatchSaveMode}
        onClose={() => {
          setIsSaveElementModalOpen(false);
          setIsBatchSaveMode(false);
        }}
        onSave={async (name, type) => {
          if (isBatchSaveMode) {
            await processBatchSave(type);
          } else {
            // Single Save
            if (!saveElementData) return;
            try {
              const res = await fetch(
                `http://localhost:3001/api/projects/${projectId}/elements/from-generation`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    url: saveElementData.url,
                    type: type, // Use Selected/Custom Type
                    name,
                  }),
                }
              );
              if (!res.ok) throw new Error('Failed to save element');
              loadElements();
            } catch (e) {
              console.error('Failed to save element', e);
            }
          }
        }}
      />

      <TagSelectorModal
        isOpen={isTagSelectorOpen}
        onClose={() => setIsTagSelectorOpen(false)}
        onTagsApply={(tags: Tag[]) => {
          const tagText = tags.map(t => t.promptKeyword || t.name.toLowerCase()).join(', ');
          setPrompt(prev => (prev.trim() ? `${prev.trim()}, ${tagText}` : tagText));
          setIsTagSelectorOpen(false);
        }}
      />

      {/* Prompt Variables Panel */}
      <PromptVariablesPanel
        isOpen={isVariablesPanelOpen}
        onClose={() => setIsVariablesPanelOpen(false)}
      />

      {/* Prop Bin Panel */}
      <PropBinPanel isOpen={isPropBinOpen} onClose={() => setIsPropBinOpen(false)} />

      {/* Prompt Tree Panel */}
      <PromptTreePanel
        isOpen={isPromptTreeOpen}
        onClose={() => setIsPromptTreeOpen(false)}
        projectId={projectId}
        onLoadPrompt={(loadedPrompt, negPrompt) => {
          setPrompt(loadedPrompt);
          if (negPrompt && styleConfig) {
            setStyleConfig({ ...styleConfig, negativePrompt: negPrompt });
          }
        }}
      />

      {/* Weight Hint Tooltip - Shows when Cmd/Ctrl is held */}
      <WeightHintTooltip isVisible={isModifierHeld && isFocused} />

      {/* Session Recovery Toast */}
      {showRecoveryToast && recoverableSession && (
        <div className="fixed bottom-24 left-1/2 z-[100] -translate-x-1/2 animate-in slide-in-from-bottom-4 fade-in duration-300">
          <div className="flex items-center gap-3 rounded-xl border border-amber-500/30 bg-zinc-900/95 px-4 py-3 shadow-2xl backdrop-blur-sm">
            <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-full bg-amber-500/20">
              <FilePlus className="h-5 w-5 text-amber-400" />
            </div>
            <div className="min-w-0 flex-1">
              <p className="text-sm font-medium text-white">Unsaved session found</p>
              <p className="truncate text-xs text-white/50">
                "{recoverableSession.prompt.slice(0, 40)}
                {recoverableSession.prompt.length > 40 ? '...' : ''}"  saved{' '}
                {formatTimeAgo(recoverableSession.savedAt)}
              </p>
            </div>
            <div className="flex shrink-0 items-center gap-2">
              <button
                onClick={handleDismissRecovery}
                className="rounded-lg px-3 py-1.5 text-xs text-white/60 transition-colors hover:bg-white/10 hover:text-white"
              >
                Dismiss
              </button>
              <button
                onClick={handleRestoreSession}
                className="rounded-lg bg-amber-500 px-3 py-1.5 text-xs font-medium text-black transition-colors hover:bg-amber-400"
              >
                Restore
              </button>
            </div>
          </div>
        </div>
      )}
    </DndContext>
  );
}
</file>

</files>
